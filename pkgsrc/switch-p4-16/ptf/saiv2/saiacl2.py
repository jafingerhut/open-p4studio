################################################################################
 #  Copyright (C) 2024 Intel Corporation
 #
 #  Licensed under the Apache License, Version 2.0 (the "License");
 #  you may not use this file except in compliance with the License.
 #  You may obtain a copy of the License at
 #
 #  http://www.apache.org/licenses/LICENSE-2.0
 #
 #  Unless required by applicable law or agreed to in writing,
 #  software distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions
 #  and limitations under the License.
 #
 #
 #  SPDX-License-Identifier: Apache-2.0
################################################################################

"""
Thrift SAI interface ACL tests
"""
# Trying disable=duplication-code until I enable all PTF in this file,
# but for some reason thats not working, so using disable=all for now
# pylint: disable=all

from sai_base_test import *
from saiqosmap import create_and_verify_qos_map

THIS_DIR = os.path.dirname(os.path.abspath(__file__))
sys.path.append(os.path.join(THIS_DIR, '..'))

from common.utils import *  # noqa pylint: disable=wrong-import-position

#######################################################################
# This file is used to test acl2.p4 features
#######################################################################

##########################################################################
#  Ingress Acls Below


@group('acl2')
class AclGroupTest(SaiHelper):
    '''
    ACL group test class
    '''

    def setUp(self):
        super(AclGroupTest, self).setUp()

        self.port_mac = '00:11:22:33:44:55'
        self.lag_mac = '00:11:22:33:44:56'
        self.port_mac2 = '00:11:22:33:44:57'
        self.lag_mac2 = '00:11:22:33:44:58'

        self.port_fdb_entry = sai_thrift_fdb_entry_t(
            switch_id=self.switch_id,
            mac_address=self.port_mac,
            bv_id=self.vlan10)
        sai_thrift_create_fdb_entry(
            self.client,
            self.port_fdb_entry,
            type=SAI_FDB_ENTRY_TYPE_STATIC,
            bridge_port_id=self.port0_bp)

        self.lag_fdb_entry = sai_thrift_fdb_entry_t(
            switch_id=self.switch_id,
            mac_address=self.lag_mac,
            bv_id=self.vlan10)
        sai_thrift_create_fdb_entry(
            self.client,
            self.lag_fdb_entry,
            type=SAI_FDB_ENTRY_TYPE_STATIC,
            bridge_port_id=self.lag1_bp)

        self.port24_bp = sai_thrift_create_bridge_port(
            self.client,
            bridge_id=self.default_1q_bridge,
            port_id=self.port24,
            type=SAI_BRIDGE_PORT_TYPE_PORT,
            admin_state=True)
        self.assertTrue(self.port24_bp != 0)

        self.port25_bp = sai_thrift_create_bridge_port(
            self.client,
            bridge_id=self.default_1q_bridge,
            port_id=self.port25,
            type=SAI_BRIDGE_PORT_TYPE_PORT,
            admin_state=True)
        self.assertTrue(self.port25_bp != 0)

        # LAGs
        self.lag6 = sai_thrift_create_lag(self.client)
        self.assertTrue(self.lag6 != 0)
        self.lag6_bp = sai_thrift_create_bridge_port(
            self.client,
            bridge_id=self.default_1q_bridge,
            port_id=self.lag6,
            type=SAI_BRIDGE_PORT_TYPE_PORT,
            admin_state=True)
        self.assertTrue(self.lag6_bp != 0)
        self.lag6_member26 = sai_thrift_create_lag_member(
            self.client, lag_id=self.lag6, port_id=self.port26)
        self.lag6_member27 = sai_thrift_create_lag_member(
            self.client, lag_id=self.lag6, port_id=self.port27)
        self.lag6_member28 = sai_thrift_create_lag_member(
            self.client, lag_id=self.lag6, port_id=self.port28)

        # vlan 40 with port24, port25 and lag6
        self.vlan40 = sai_thrift_create_vlan(self.client, vlan_id=40)
        self.assertTrue(self.vlan40 != 0)
        self.vlan40_member24 = sai_thrift_create_vlan_member(
            self.client,
            vlan_id=self.vlan40,
            bridge_port_id=self.port24_bp,
            vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_UNTAGGED)
        self.vlan40_member25 = sai_thrift_create_vlan_member(
            self.client,
            vlan_id=self.vlan40,
            bridge_port_id=self.port25_bp,
            vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_TAGGED)
        self.vlan40_member_lag6 = sai_thrift_create_vlan_member(
            self.client,
            vlan_id=self.vlan40,
            bridge_port_id=self.lag6_bp,
            vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_UNTAGGED)

        # setup untagged ports
        sai_thrift_set_port_attribute(
            self.client, self.port24, port_vlan_id=40)
        sai_thrift_set_lag_attribute(self.client, self.lag6, port_vlan_id=40)

        self.port_fdb_entry2 = sai_thrift_fdb_entry_t(
            switch_id=self.switch_id,
            mac_address=self.port_mac2,
            bv_id=self.vlan40)
        sai_thrift_create_fdb_entry(
            self.client,
            self.port_fdb_entry2,
            type=SAI_FDB_ENTRY_TYPE_STATIC,
            bridge_port_id=self.port24_bp)

        self.lag_fdb_entry2 = sai_thrift_fdb_entry_t(
            switch_id=self.switch_id,
            mac_address=self.lag_mac2,
            bv_id=self.vlan40)
        sai_thrift_create_fdb_entry(
            self.client,
            self.lag_fdb_entry2,
            type=SAI_FDB_ENTRY_TYPE_STATIC,
            bridge_port_id=self.lag6_bp)

        self.src_ip = '10.0.0.1'
        self.src_ip2 = '10.0.0.2'
        self.pkt1 = simple_udp_packet(
            eth_dst=self.port_mac,
            eth_src=self.lag_mac,
            ip_src=self.src_ip,
            pktlen=100)
        self.tpkt1 = simple_udp_packet(
            eth_dst=self.port_mac,
            eth_src=self.lag_mac,
            dl_vlan_enable=True,
            vlan_vid=10,
            ip_src=self.src_ip,
            pktlen=104)
        self.pkt2 = simple_udp_packet(
            eth_dst=self.lag_mac,
            eth_src=self.port_mac,
            ip_src=self.src_ip,
            pktlen=100)
        self.tpkt2 = simple_udp_packet(
            eth_dst=self.lag_mac,
            eth_src=self.port_mac,
            dl_vlan_enable=True,
            vlan_vid=10,
            ip_src=self.src_ip,
            pktlen=104)
        self.pkt3 = simple_udp_packet(
            eth_dst=self.port_mac2,
            eth_src=self.lag_mac2,
            ip_src=self.src_ip2,
            pktlen=100)
        self.pkt4 = simple_udp_packet(
            eth_dst=self.lag_mac2,
            eth_src=self.port_mac2,
            ip_src=self.src_ip2,
            pktlen=100)

        self.src_v6 = '5555:4884:8ab4:00f0:4411:1144:5555:aabb'
        self.src_v6_1 = '5555:4884:8ab4:00f0:4411:1144:5555:aaaa'
        self.pkt1_v6 = simple_udpv6_packet(
            eth_dst=self.port_mac,
            eth_src=self.lag_mac,
            ipv6_src=self.src_v6,
            ipv6_hlim=64,
            pktlen=40+14)
        self.tpkt1_v6 = simple_udpv6_packet(
            eth_dst=self.port_mac,
            eth_src=self.lag_mac,
            dl_vlan_enable=True,
            vlan_vid=10,
            ipv6_src=self.src_v6,
            ipv6_hlim=64,
            pktlen=40+18)
        self.pkt2_v6 = simple_udpv6_packet(
            eth_dst=self.lag_mac,
            eth_src=self.port_mac,
            ipv6_src=self.src_v6,
            ipv6_hlim=64)
        self.pkt3_v6 = simple_udpv6_packet(
            eth_dst=self.port_mac2,
            eth_src=self.lag_mac2,
            ipv6_src=self.src_v6_1,
            ipv6_hlim=64,
            pktlen=40+14)
        self.tpkt3_v6 = simple_udpv6_packet(
            eth_dst=self.port_mac2,
            eth_src=self.lag_mac2,
            dl_vlan_enable=True,
            vlan_vid=40,
            ipv6_src=self.src_v6_1,
            ipv6_hlim=64,
            pktlen=40+18)
        self.pkt4_v6 = simple_udpv6_packet(
            eth_dst=self.lag_mac2,
            eth_src=self.port_mac2,
            ipv6_src=self.src_v6_1,
            ipv6_hlim=64)

        # ACL table group
        group_stage = SAI_ACL_STAGE_INGRESS
        bpoints = [SAI_ACL_BIND_POINT_TYPE_SWITCH]
        self.bpoint_type_list = sai_thrift_s32_list_t(
            count=len(bpoints), int32list=bpoints)
        group_type = SAI_ACL_TABLE_GROUP_TYPE_PARALLEL

        self.acl_group = sai_thrift_create_acl_table_group(
            self.client,
            acl_stage=group_stage,
            acl_bind_point_type_list=self.bpoint_type_list,
            type=group_type)

        self.table_stage = SAI_ACL_STAGE_INGRESS

    def runTest(self):
        print("Testing AclGroupTest - ingress acl tables in same acl group")
        self.portLagBasicTrafficTest()
        self.configV4AclTableGroup('10.0.0.55')
        self.configV6AclTableGroup()
        self.configMacAclTableGroup('00:11:22:33:44:80', '00:11:22:33:44:85')
        self.configIpMirrorAclTableGroup('5555::8844')
        sai_thrift_set_switch_attribute(
            self.client, ingress_acl=self.acl_group)
        self.portLagV4AclTableGroupTest('10.0.0.55')
        self.portLagV6AclTableGroupTest()
        self.portLagMacAclTableGroupTest(
            '00:11:22:33:44:80', '00:11:22:33:44:85')
        self.lagIpMirrorAclTableGroupTest('5555::8844')
        self.cleanupV4AclTableGroup()
        self.cleanupV6AclTableGroup()
        self.cleanupMacAclTableGroup()
        self.cleanupIpMirorAclTableGroup()
        self.portLagBasicTrafficTest()
        #  self.portLagEgressAclTableGroupTest()  #todo

    def tearDown(self):
        sai_thrift_set_switch_attribute(self.client, ingress_acl=0)
        sai_thrift_remove_acl_table_group(self.client, self.acl_group)

        sai_thrift_remove_fdb_entry(self.client, self.port_fdb_entry)
        sai_thrift_remove_fdb_entry(self.client, self.lag_fdb_entry)
        sai_thrift_remove_fdb_entry(self.client, self.port_fdb_entry2)
        sai_thrift_remove_fdb_entry(self.client, self.lag_fdb_entry2)

        sai_thrift_set_port_attribute(self.client, self.port24, port_vlan_id=0)
        sai_thrift_set_lag_attribute(self.client, self.lag6, port_vlan_id=0)

        # remove vlan config
        sai_thrift_remove_vlan_member(self.client, self.vlan40_member_lag6)
        sai_thrift_remove_vlan_member(self.client, self.vlan40_member25)
        sai_thrift_remove_vlan_member(self.client, self.vlan40_member24)
        sai_thrift_remove_vlan(self.client, self.vlan40)

        # remove lag config
        sai_thrift_remove_lag_member(self.client, self.lag6_member28)
        sai_thrift_remove_lag_member(self.client, self.lag6_member27)
        sai_thrift_remove_lag_member(self.client, self.lag6_member26)
        sai_thrift_remove_bridge_port(self.client, self.lag6_bp)
        sai_thrift_remove_lag(self.client, self.lag6)

        # remove bridge ports
        sai_thrift_remove_bridge_port(self.client, self.port25_bp)
        sai_thrift_remove_bridge_port(self.client, self.port24_bp)

        super(AclGroupTest, self).tearDown()

    def portLagBasicTrafficTest(self):
        '''
        Verify port/lag traffic test before
        applying any ACLs to acl table group.
        '''
        print("portLagBasicTrafficTest")

        print(" Tx v4 packet without ACL table group")
        print(" Tx v4 packet from lag to port")
        send_packet(self, self.dev_port4, self.pkt1)
        verify_packet(self, self.pkt1, self.dev_port0)

        print(" Tx v4 packet from port to lag")
        send_packet(self, self.dev_port0, self.pkt2)
        verify_packet_any_port(
            self, self.pkt2,
            [self.dev_port4, self.dev_port5, self.dev_port6])

        print(" Tx v4 packet from tag port to lag")
        send_packet(self, self.dev_port1, self.tpkt2)
        verify_packet_any_port(
            self, self.pkt2,
            [self.dev_port4, self.dev_port5, self.dev_port6])

        print(" Tx v4 packet from lag2 to port2")
        send_packet(self, self.dev_port26, self.pkt3)
        verify_packet(self, self.pkt3, self.dev_port24)

        print(" Tx v4 packet from port2 to lag2")
        send_packet(self, self.dev_port24, self.pkt4)
        verify_packet_any_port(
            self, self.pkt4,
            [self.dev_port26, self.dev_port27, self.dev_port28])

        print(" Tx v6 packet without ACL table group")
        print(" Tx v6 packet from lag to port")
        send_packet(self, self.dev_port4, self.pkt1_v6)
        verify_packet(self, self.pkt1_v6, self.dev_port0)

        print(" Tx v6 packet from port to lag")
        send_packet(self, self.dev_port0, self.pkt2_v6)
        verify_packet_any_port(
            self, self.pkt2_v6,
            [self.dev_port4, self.dev_port5, self.dev_port6])

        print(" Tx v6 packet from lag2 to port2")
        send_packet(self, self.dev_port26, self.pkt3_v6)
        verify_packet(self, self.pkt3_v6, self.dev_port24)

        print(" Tx v6 packet from port2 to lag2")
        send_packet(self, self.dev_port24, self.pkt4_v6)
        verify_packet_any_port(
            self, self.pkt4_v6,
            [self.dev_port26, self.dev_port27, self.dev_port28])

    def configV4AclTableGroup(self, src_ip):
        '''
        configure both port/lag as in-port
        field with switch b-point to Ingress
        ipv4 ACL table group.
        '''
        print("configV4AclTableGroup")

        #  ACL table
        self.v4_acl_table = sai_thrift_create_acl_table(
            self.client,
            acl_stage=self.table_stage,
            acl_bind_point_type_list=self.bpoint_type_list,
            field_src_ip=True,
            field_in_port=True)

        #  ACL table entry
        src_ip_mask = '255.255.255.255'
        src_ip_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(ip4=src_ip),
            mask=sai_thrift_acl_field_data_mask_t(ip4=src_ip_mask))

        packet_action = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                s32=SAI_PACKET_ACTION_DROP))

        in_port_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(oid=self.port0))
        self.v4_acl_entry = sai_thrift_create_acl_entry(
            self.client,
            table_id=self.v4_acl_table,
            priority=10,
            field_src_ip=src_ip_t,
            field_in_port=in_port_t,
            action_packet_action=packet_action)

        #  ACL counter
        self.v4_acl_counter = sai_thrift_create_acl_counter(
            self.client, table_id=self.v4_acl_table)
        # attach ACL counter to ACL entry
        action_counter_t = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=self.v4_acl_counter),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, self.v4_acl_entry,
            action_counter=action_counter_t)

        in_lag_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(oid=self.lag1))
        self.v4_acl_entry1 = sai_thrift_create_acl_entry(
            self.client,
            table_id=self.v4_acl_table,
            priority=10,
            field_src_ip=src_ip_t,
            field_in_port=in_lag_t,
            action_packet_action=packet_action)

        #  ACL counter
        self.v4_acl_counter1 = sai_thrift_create_acl_counter(
            self.client, table_id=self.v4_acl_table)
        # attach ACL counter to ACL entry
        action_counter_t1 = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=self.v4_acl_counter1),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, self.v4_acl_entry1,
            action_counter=action_counter_t1)

        #  ACL table group member
        self.v4_acl_member = sai_thrift_create_acl_table_group_member(
            self.client,
            acl_table_group_id=self.acl_group,
            acl_table_id=self.v4_acl_table)

    def portLagV4AclTableGroupTest(self, src_ip):
        '''
        test traffic for v4 acl table group
        configV4AclTableGroup
        '''
        print("portLagV4AclTableGroupTest")

        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.v4_acl_counter, packets=True)
        self.assertEqual(packets['packets'], 0)

        print(" Tx v4 packet from port to lag, no drop")
        send_packet(self, self.dev_port0, self.pkt2)
        verify_packet_any_port(
            self, self.pkt2,
            [self.dev_port4, self.dev_port5, self.dev_port6])

        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.v4_acl_counter, packets=True)
        self.assertEqual(packets['packets'], 0)

        pkt2_port = self.pkt2.copy()
        pkt2_port[IP].src = src_ip

        print(" Tx v4 packet from port to lag, drop")
        send_packet(self, self.dev_port0, pkt2_port)
        verify_no_other_packets(self)

        time.sleep(2)
        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.v4_acl_counter, packets=True)
        self.assertEqual(packets['packets'], 1)

        tpkt2_port = self.tpkt2.copy()
        tpkt2_port[IP].src = src_ip

        print(" Tx v4 packet from tag port to lag, no drop")
        send_packet(self, self.dev_port1, tpkt2_port)
        verify_packet_any_port(
            self, pkt2_port,
            [self.dev_port4, self.dev_port5, self.dev_port6])

        time.sleep(2)
        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.v4_acl_counter, packets=True)
        self.assertEqual(packets['packets'], 1)

        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.v4_acl_counter1, packets=True)
        self.assertEqual(packets['packets'], 0)

        print(" Tx v4 packet from lag to port, no drop")
        send_packet(self, self.dev_port4, self.pkt1)
        verify_packet(self, self.pkt1, self.dev_port0)

        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.v4_acl_counter1, packets=True)
        self.assertEqual(packets['packets'], 0)

        pkt1_lag = self.pkt1.copy()
        pkt1_lag[IP].src = src_ip

        print(" Tx v4 packet from lag to port, drop")
        send_packet(self, self.dev_port4, pkt1_lag)
        verify_no_other_packets(self)

        time.sleep(2)
        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.v4_acl_counter1, packets=True)
        self.assertEqual(packets['packets'], 1)

        tpkt1_lag = self.tpkt1.copy()
        tpkt1_lag[IP].src = src_ip

        print(" Tx v4 packet from tag port to port, no drop")
        send_packet(self, self.dev_port1, tpkt1_lag)
        verify_packet(self, pkt1_lag, self.dev_port0)

        time.sleep(2)
        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.v4_acl_counter1, packets=True)
        self.assertEqual(packets['packets'], 1)

    def cleanupV4AclTableGroup(self):
        '''
        cleanup ipv4 ACL counters, entries,
        table, group
        '''
        print("cleanupV4AclTableGroup")

        action_counter_t = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=0),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, self.v4_acl_entry,
            action_counter=action_counter_t)
        sai_thrift_set_acl_entry_attribute(
            self.client, self.v4_acl_entry1,
            action_counter=action_counter_t)

        sai_thrift_set_acl_counter_attribute(
            self.client, self.v4_acl_counter, packets=None)
        sai_thrift_set_acl_counter_attribute(
            self.client, self.v4_acl_counter1, packets=None)

        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.v4_acl_counter, packets=True)
        self.assertEqual(packets['packets'], 0)
        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.v4_acl_counter1, packets=True)
        self.assertEqual(packets['packets'], 0)

        sai_thrift_remove_acl_counter(self.client, self.v4_acl_counter)
        sai_thrift_remove_acl_counter(self.client, self.v4_acl_counter1)

        sai_thrift_remove_acl_table_group_member(
            self.client, self.v4_acl_member)
        sai_thrift_remove_acl_entry(self.client, self.v4_acl_entry)
        sai_thrift_remove_acl_entry(self.client, self.v4_acl_entry1)
        sai_thrift_remove_acl_table(self.client, self.v4_acl_table)

    def configV6AclTableGroup(self):
        '''
        configure both port/lag as in-port
        field with switch b-point to Ingress
        V6 ACL table group.
        '''
        print("configV6AclTableGroup")

        #  ACL table
        self.v6_acl_table = sai_thrift_create_acl_table(
            self.client,
            acl_stage=self.table_stage,
            acl_bind_point_type_list=self.bpoint_type_list,
            field_src_ipv6=True,
            field_in_port=True)

        #  ACL table entry
        src_ip_mask = 'FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF'
        src_ip_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(ip6=self.src_v6),
            mask=sai_thrift_acl_field_data_mask_t(ip6=src_ip_mask))

        packet_action = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                s32=SAI_PACKET_ACTION_DROP))

        in_port_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(oid=self.port0))
        self.v6_acl_entry = sai_thrift_create_acl_entry(
            self.client,
            table_id=self.v6_acl_table,
            priority=10,
            field_src_ipv6=src_ip_t,
            field_in_port=in_port_t,
            action_packet_action=packet_action)

        #  ACL counter
        self.v6_acl_counter = sai_thrift_create_acl_counter(
            self.client, table_id=self.v6_acl_table)
        # attach ACL counter to ACL entry
        action_counter_t = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=self.v6_acl_counter),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, self.v6_acl_entry,
            action_counter=action_counter_t)

        in_lag_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(oid=self.lag1))
        self.v6_acl_entry1 = sai_thrift_create_acl_entry(
            self.client,
            table_id=self.v6_acl_table,
            priority=10,
            field_src_ipv6=src_ip_t,
            field_in_port=in_lag_t,
            action_packet_action=packet_action)

        #  ACL counter
        self.v6_acl_counter1 = sai_thrift_create_acl_counter(
            self.client, table_id=self.v6_acl_table)
        # attach ACL counter to ACL entry
        action_counter_t1 = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=self.v6_acl_counter1),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, self.v6_acl_entry1,
            action_counter=action_counter_t1)

        #  ACL table group member
        self.v6_acl_member = sai_thrift_create_acl_table_group_member(
            self.client,
            acl_table_group_id=self.acl_group,
            acl_table_id=self.v6_acl_table)

    def portLagV6AclTableGroupTest(self):
        '''
        test traffic for v6 acl table group
        configV4AclTableGroup
        '''
        print("portLagV6AclTableGroupTest")

        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.v6_acl_counter, packets=True)
        self.assertEqual(packets['packets'], 0)

        print(" Tx v6 packet from port to lag, drop")
        send_packet(self, self.dev_port0, self.pkt2_v6)
        verify_no_other_packets(self)

        time.sleep(2)
        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.v6_acl_counter, packets=True)
        self.assertEqual(packets['packets'], 1)

        print(" Tx v6 packet from port2 to lag2, no drop")
        send_packet(self, self.dev_port24, self.pkt4_v6)
        verify_packet_any_port(
            self, self.pkt4_v6,
            [self.dev_port26, self.dev_port27, self.dev_port28])

        time.sleep(2)
        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.v6_acl_counter, packets=True)
        self.assertEqual(packets['packets'], 1)

        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.v6_acl_counter1, packets=True)
        self.assertEqual(packets['packets'], 0)

        print(" Tx v6 packet from lag to port, drop")
        send_packet(self, self.dev_port4, self.pkt1_v6)
        verify_no_other_packets(self)

        time.sleep(2)
        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.v6_acl_counter1, packets=True)
        self.assertEqual(packets['packets'], 1)

        print(" Tx v6 packet from tag port to port, no drop")
        send_packet(self, self.dev_port1, self.tpkt1_v6)
        verify_packet(self, self.pkt1_v6, self.dev_port0)

        time.sleep(2)
        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.v6_acl_counter1, packets=True)
        self.assertEqual(packets['packets'], 1)

        print(" Tx v6 packet from lag2 to port2, no drop")
        send_packet(self, self.dev_port26, self.pkt3_v6)
        verify_packet(self, self.pkt3_v6, self.dev_port24)

        time.sleep(2)
        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.v6_acl_counter1, packets=True)
        self.assertEqual(packets['packets'], 1)

    def cleanupV6AclTableGroup(self):
        '''
        cleanup ipv6 ACL counters, entries,
        table, group
        '''
        print("cleanupV6AclTableGroup")

        action_counter_t = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=0),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, self.v6_acl_entry,
            action_counter=action_counter_t)
        sai_thrift_set_acl_entry_attribute(
            self.client, self.v6_acl_entry1,
            action_counter=action_counter_t)

        sai_thrift_set_acl_counter_attribute(
            self.client, self.v6_acl_counter, packets=None)
        sai_thrift_set_acl_counter_attribute(
            self.client, self.v6_acl_counter1, packets=None)

        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.v6_acl_counter, packets=True)
        self.assertEqual(packets['packets'], 0)
        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.v6_acl_counter1, packets=True)
        self.assertEqual(packets['packets'], 0)

        sai_thrift_remove_acl_counter(self.client, self.v6_acl_counter)
        sai_thrift_remove_acl_counter(self.client, self.v6_acl_counter1)

        sai_thrift_remove_acl_table_group_member(
            self.client, self.v6_acl_member)
        sai_thrift_remove_acl_entry(self.client, self.v6_acl_entry)
        sai_thrift_remove_acl_entry(self.client, self.v6_acl_entry1)
        sai_thrift_remove_acl_table(self.client, self.v6_acl_table)

    def configMacAclTableGroup(self, port_mac, lag_mac):
        '''
        configure both port/lag as in-port
        field with switch b-point to Ingress
        mac ACL table group.
        '''
        print("configMacAclTableGroup")

        #  ACL table
        self.mac_acl_table = sai_thrift_create_acl_table(
            self.client,
            acl_stage=self.table_stage,
            acl_bind_point_type_list=self.bpoint_type_list,
            field_src_mac=True,
            field_in_port=True)

        #  ACL table entry
        mac_src_mask = 'ff:ff:ff:ff:ff:ff'
        src_mac_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(mac=port_mac),
            mask=sai_thrift_acl_field_data_mask_t(mac=mac_src_mask))

        packet_action = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                s32=SAI_PACKET_ACTION_DROP))

        in_port_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(oid=self.port0))
        self.mac_acl_entry = sai_thrift_create_acl_entry(
            self.client,
            table_id=self.mac_acl_table,
            priority=10,
            field_src_mac=src_mac_t,
            field_in_port=in_port_t,
            action_packet_action=packet_action)

        #  ACL counter
        self.mac_acl_counter = sai_thrift_create_acl_counter(
            self.client, table_id=self.mac_acl_table)
        # attach ACL counter to ACL entry
        action_counter_t = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=self.mac_acl_counter),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, self.mac_acl_entry,
            action_counter=action_counter_t)

        src_mac_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(mac=lag_mac),
            mask=sai_thrift_acl_field_data_mask_t(mac=mac_src_mask))
        in_lag_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(oid=self.lag1))
        self.mac_acl_entry1 = sai_thrift_create_acl_entry(
            self.client,
            table_id=self.mac_acl_table,
            priority=10,
            field_src_mac=src_mac_t,
            field_in_port=in_lag_t,
            action_packet_action=packet_action)

        #  ACL counter
        self.mac_acl_counter1 = sai_thrift_create_acl_counter(
            self.client, table_id=self.mac_acl_table)
        # attach ACL counter to ACL entry
        action_counter_t1 = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=self.mac_acl_counter1),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, self.mac_acl_entry1,
            action_counter=action_counter_t1)

        #  ACL table group member
        self.mac_acl_member = sai_thrift_create_acl_table_group_member(
            self.client,
            acl_table_group_id=self.acl_group,
            acl_table_id=self.mac_acl_table)

    def portLagMacAclTableGroupTest(self, port_mac, lag_mac):
        '''
        test traffic for Mac acl table group
        configMacAclTableGroup
        '''
        print("portLagMacAclTableGroupTest")

        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.mac_acl_counter, packets=True)
        self.assertEqual(packets['packets'], 0)

        print(" Tx v4 packet from port to lag, no drop")
        send_packet(self, self.dev_port0, self.pkt2)
        verify_packet_any_port(
            self, self.pkt2,
            [self.dev_port4, self.dev_port5, self.dev_port6])

        time.sleep(2)
        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.mac_acl_counter, packets=True)
        self.assertEqual(packets['packets'], 0)

        pkt2_port = self.pkt2.copy()
        pkt2_port[Ether].src = port_mac

        print(" Tx v4 packet from port to lag, drop")
        send_packet(self, self.dev_port0, pkt2_port)
        verify_no_other_packets(self)

        time.sleep(2)
        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.mac_acl_counter, packets=True)
        self.assertEqual(packets['packets'], 1)

        tpkt2_port = self.tpkt2.copy()
        tpkt2_port[Ether].src = port_mac

        print(" Tx v4 packet from tag port to lag, no drop")
        send_packet(self, self.dev_port1, tpkt2_port)
        verify_packet_any_port(
            self, pkt2_port,
            [self.dev_port4, self.dev_port5, self.dev_port6])

        time.sleep(2)
        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.mac_acl_counter, packets=True)
        self.assertEqual(packets['packets'], 1)

        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.mac_acl_counter1, packets=True)
        self.assertEqual(packets['packets'], 0)

        pkt1_v6_lag = self.pkt1_v6.copy()
        pkt1_v6_lag[IPv6].src = '5555:4884:8ab4:00f0:4444:1144:5555:aabb'

        print(" Tx v6 packet from lag to port, no drop")
        send_packet(self, self.dev_port4, pkt1_v6_lag)
        verify_packet(self, pkt1_v6_lag, self.dev_port0)

        time.sleep(2)
        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.mac_acl_counter1, packets=True)
        self.assertEqual(packets['packets'], 0)

        pkt1_v6_lag[Ether].src = lag_mac

        print(" Tx v6 packet from lag to port, drop")
        send_packet(self, self.dev_port4, pkt1_v6_lag)
        verify_no_other_packets(self)

        tpkt1_v6_lag = self.tpkt1_v6.copy()
        tpkt1_v6_lag[IPv6].src = '5555:4884:8ab4:00f0:4444:1144:5555:aabb'
        tpkt1_v6_lag[Ether].src = lag_mac

        print(" Tx v6 packet from tag port to port, no drop")
        send_packet(self, self.dev_port1, tpkt1_v6_lag)
        verify_packet(self, pkt1_v6_lag, self.dev_port0)

        time.sleep(2)
        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.mac_acl_counter1, packets=True)
        self.assertEqual(packets['packets'], 1)

    def cleanupMacAclTableGroup(self):
        '''
        cleanup mac ACL counters, entries,
        table, group
        '''
        print("cleanupMacAclTableGroup")

        action_counter_t = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=0),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, self.mac_acl_entry,
            action_counter=action_counter_t)
        sai_thrift_set_acl_entry_attribute(
            self.client, self.mac_acl_entry1,
            action_counter=action_counter_t)

        sai_thrift_set_acl_counter_attribute(
            self.client, self.mac_acl_counter, packets=None)
        sai_thrift_set_acl_counter_attribute(
            self.client, self.mac_acl_counter1, packets=None)

        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.mac_acl_counter, packets=True)
        self.assertEqual(packets['packets'], 0)
        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.mac_acl_counter1, packets=True)
        self.assertEqual(packets['packets'], 0)

        sai_thrift_remove_acl_counter(self.client, self.mac_acl_counter)
        sai_thrift_remove_acl_counter(self.client, self.mac_acl_counter1)

        sai_thrift_remove_acl_table_group_member(
            self.client, self.mac_acl_member)
        sai_thrift_remove_acl_entry(self.client, self.mac_acl_entry)
        sai_thrift_remove_acl_entry(self.client, self.mac_acl_entry1)
        sai_thrift_remove_acl_table(self.client, self.mac_acl_table)

    def configIpMirrorAclTableGroup(self, src_v6):
        '''
        configure both port/lag as in-port
        field with switch b-point to Ingress
        IP Mirror ACL table group.
        '''
        print("configIpMirrorAclTableGroup")

        at = [SAI_ACL_ACTION_TYPE_MIRROR_INGRESS]
        action_type_list = sai_thrift_s32_list_t(
            count=len(at), int32list=at)

        #  ACL table
        self.mirror_acl_table = sai_thrift_create_acl_table(
            self.client,
            acl_stage=self.table_stage,
            acl_bind_point_type_list=self.bpoint_type_list,
            field_src_ipv6=True,
            field_in_port=True,
            acl_action_type_list=action_type_list)

        mirror_session = sai_thrift_create_mirror_session(
            self.client,
            monitor_port=self.port22,
            type=SAI_MIRROR_SESSION_TYPE_LOCAL)
        mirror_session_list = sai_thrift_object_list_t(
            count=1, idlist=[mirror_session])
        mirror_action = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                objlist=mirror_session_list))

        #  ACL table entry
        src_ip_mask = 'FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF'
        src_ip_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(ip6=src_v6),
            mask=sai_thrift_acl_field_data_mask_t(ip6=src_ip_mask))

        in_lag_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(oid=self.lag6))
        self.mirror_acl_entry = sai_thrift_create_acl_entry(
            self.client,
            table_id=self.mirror_acl_table,
            priority=10,
            field_src_ipv6=src_ip_t,
            field_in_port=in_lag_t,
            action_mirror_ingress=mirror_action)

        #  ACL counter
        self.mirror_acl_counter = sai_thrift_create_acl_counter(
            self.client, table_id=self.mirror_acl_table)
        # attach ACL counter to ACL entry
        action_counter_t = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=self.mirror_acl_counter),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, self.mirror_acl_entry,
            action_counter=action_counter_t)

        #  ACL table group member
        self.mirror_acl_member = sai_thrift_create_acl_table_group_member(
            self.client,
            acl_table_group_id=self.acl_group,
            acl_table_id=self.mirror_acl_table)

    def lagIpMirrorAclTableGroupTest(self, src_v6):
        '''
        test traffic for IP mirror acl table group
        configV4AclTableGroup
        '''
        print("configIPMirrorAclTableGroup")

        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.mirror_acl_counter, packets=True)
        self.assertEqual(packets['packets'], 0)

        print(" Tx v6 packet from lag B to port B --> forw to port B, "
              "  no mirror ")
        send_packet(self, self.dev_port26, self.pkt3_v6)
        verify_packet(self, self.pkt3_v6, self.dev_port24)

        time.sleep(2)
        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.mirror_acl_counter, packets=True)
        self.assertEqual(packets['packets'], 0)

        pkt3_v6_lag = self.pkt3_v6.copy()
        pkt3_v6_lag[IPv6].src = src_v6

        #  verify switch-pkt egress out of egress port
        #  verify if the mirror packet [out of port 22] is incoming pkt
        print(" Tx v6 packet from lag B to port B --> forw to port B, "
              " mirror in-pkt to port 22 ")
        send_packet(self, self.dev_port26, pkt3_v6_lag)
        verify_each_packet_on_each_port(self, [pkt3_v6_lag, pkt3_v6_lag],
                                        [self.dev_port24, self.dev_port22])

        time.sleep(2)
        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.mirror_acl_counter, packets=True)
        self.assertEqual(packets['packets'], 1)

        tpkt3_v6_lag = self.tpkt3_v6.copy()
        tpkt3_v6_lag[IPv6].src = src_v6

        print(" Tx v6 packet from port A to port B --> forw to port B, "
              "  no mirror")
        send_packet(self, self.dev_port25, tpkt3_v6_lag)
        verify_packet(self, pkt3_v6_lag, self.dev_port24)

        time.sleep(2)
        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.mirror_acl_counter, packets=True)
        self.assertEqual(packets['packets'], 1)

    def cleanupIpMirorAclTableGroup(self):
        '''
        cleanup IP mirror acl counters, entries,
        table, group
        '''
        print("cleanupIpMirorAclTableGroup")

        action_counter_t = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=0),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, self.mirror_acl_entry,
            action_counter=action_counter_t)

        sai_thrift_set_acl_counter_attribute(
            self.client, self.mirror_acl_counter, packets=None)
        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.mirror_acl_counter, packets=True)
        self.assertEqual(packets['packets'], 0)

        sai_thrift_remove_acl_counter(self.client, self.mirror_acl_counter)

        sai_thrift_remove_acl_table_group_member(
            self.client, self.mirror_acl_member)
        sai_thrift_remove_acl_entry(self.client, self.mirror_acl_entry)
        sai_thrift_remove_acl_table(self.client, self.mirror_acl_table)

    # todo
    def portLagEgressAclTableGroupTest(self):
        '''
        Verify both port/lag as out-port
        field with switch b-point to Egress
        ipv4 ACL table group.
        '''
        print("portLagEgressAclTableGroupTest")
        # create ACL table group
        group_stage = SAI_ACL_STAGE_EGRESS
        group_bind_points = [SAI_ACL_BIND_POINT_TYPE_PORT,
                             SAI_ACL_BIND_POINT_TYPE_LAG]
        group_bind_point_type_list = sai_thrift_s32_list_t(
            count=len(group_bind_points), int32list=group_bind_points)
        group_type = SAI_ACL_TABLE_GROUP_TYPE_PARALLEL

        acl_group = sai_thrift_create_acl_table_group(
            self.client,
            acl_stage=group_stage,
            acl_bind_point_type_list=group_bind_point_type_list,
            type=group_type)

        # create ACL table
        table_stage = SAI_ACL_STAGE_EGRESS
        table_bind_points = [SAI_ACL_BIND_POINT_TYPE_PORT,
                             SAI_ACL_BIND_POINT_TYPE_LAG]
        table_bind_point_type_list = sai_thrift_s32_list_t(
            count=len(table_bind_points), int32list=table_bind_points)
        acl_table = sai_thrift_create_acl_table(
            self.client,
            acl_stage=table_stage,
            acl_bind_point_type_list=table_bind_point_type_list,
            field_src_ip=True)

        # create ACL table entry
        src_ip_mask = '255.255.255.255'
        src_ip_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(ip4=self.src_ip),
            mask=sai_thrift_acl_field_data_mask_t(ip4=src_ip_mask))

        packet_action = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                s32=SAI_PACKET_ACTION_DROP))
        acl_entry = sai_thrift_create_acl_entry(
            self.client,
            table_id=acl_table,
            priority=10,
            field_src_ip=src_ip_t,
            action_packet_action=packet_action)

        # add ACL table group member
        member1 = sai_thrift_create_acl_table_group_member(
            self.client,
            acl_table_group_id=acl_group,
            acl_table_id=acl_table)

        # create ACL counter
        acl_counter = sai_thrift_create_acl_counter(
            self.client, table_id=acl_table)

        # attach ACL counter to ACL entry
        action_counter_t = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=acl_counter),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, acl_entry,
            action_counter=action_counter_t)

        try:
            pkt1 = simple_udp_packet(
                eth_dst=self.port_mac,
                eth_src=self.lag_mac,
                ip_src=self.src_ip,
                pktlen=100)
            pkt2 = simple_udp_packet(
                eth_dst=self.lag_mac,
                eth_src=self.port_mac,
                ip_src=self.src_ip,
                pktlen=100)

            pkt3 = simple_udp_packet(
                eth_dst=self.port_mac2,
                eth_src=self.lag_mac2,
                ip_src=self.src_ip2,
                pktlen=100)
            pkt4 = simple_udp_packet(
                eth_dst=self.lag_mac2,
                eth_src=self.port_mac2,
                ip_src=self.src_ip2,
                pktlen=100)

            print("Sending packet without ACL table group")
            print("Sending packet from lag to port")
            send_packet(self, self.dev_port4, pkt1)
            verify_packet(self, pkt1, self.dev_port0)

            print("Sending packet from port to lag")
            send_packet(self, self.dev_port0, pkt2)
            verify_packet_any_port(
                self, pkt2,
                [self.dev_port4, self.dev_port5, self.dev_port6])

            print("Sending packet from lag2 to port2")
            send_packet(self, self.dev_port26, pkt3)
            verify_packet(self, pkt3, self.dev_port24)

            print("Sending packet from port2 to lag2")
            send_packet(self, self.dev_port24, pkt4)
            verify_packet_any_port(
                self, pkt4,
                [self.dev_port26, self.dev_port27, self.dev_port28])

            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter, packets=True)
            self.assertEqual(packets['packets'], 0)

            print("Attach ACL table group to port")
            sai_thrift_set_port_attribute(self.client, self.port0,
                                          egress_acl=acl_group)
            print("Sending packet from lag to port, drop")
            send_packet(self, self.dev_port4, pkt1)
            verify_no_other_packets(self)

            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter, packets=True)
            self.assertEqual(packets['packets'], 1)

            print("Sending packet from lag to port, drop")
            send_packet(self, self.dev_port26, pkt3)
            verify_packet(self, pkt3, self.dev_port24)

            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter, packets=True)
            self.assertEqual(packets['packets'], 1)

            print("Attach ACL table group to lag")
            sai_thrift_set_lag_attribute(self.client, self.lag1,
                                         egress_acl=acl_group)
            print("Sending packet from port to lag, drop")
            send_packet(self, self.dev_port0, pkt2)
            verify_no_other_packets(self)

            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter, packets=True)
            self.assertEqual(packets['packets'], 2)

            print("Sending packet from port2 to lag2, do not drop")
            send_packet(self, self.dev_port24, pkt4)
            verify_packet_any_port(
                self, pkt4,
                [self.dev_port26, self.dev_port27, self.dev_port28])

            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter, packets=True)
            self.assertEqual(packets['packets'], 2)

        finally:
            action_counter_t = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=0),
                enable=True)
            sai_thrift_set_acl_entry_attribute(
                self.client, acl_entry,
                action_counter=action_counter_t)

            sai_thrift_set_acl_counter_attribute(
                self.client, acl_counter, packets=None)

            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter, packets=True)
            self.assertEqual(packets['packets'], 0)

            sai_thrift_remove_acl_counter(self.client, acl_counter)

            sai_thrift_set_port_attribute(self.client, self.port0,
                                          egress_acl=0)
            sai_thrift_set_lag_attribute(self.client, self.lag1,
                                         egress_acl=0)

            sai_thrift_remove_acl_table_group_member(self.client, member1)
            sai_thrift_remove_acl_entry(self.client, acl_entry)
            sai_thrift_remove_acl_table(self.client, acl_table)
            sai_thrift_remove_acl_table_group(self.client, acl_group)


@group('acl2')
class IngressAclTablesAllFieldTest(SaiHelper):
    """
    Verify matching on all fields of all Ingress Acl Tables
    """
    # pylint: disable=bad-whitespace,line-too-long
    table_rules = [
        #    field        ,      field value 1       ,     field value 2         ,traffic,matches,V4-Acl,V6-Acl,Qos-Acl, Mir-Acl, Pbr-Acl,  # noqa
        # ================================================================================================================================  # noqa
        ['dst_ip',          {'ip4': '100.55.155.100'}, {'ip4': '255.255.255.255'},   'v4', 'both',  True, False,   True,    True,   True],  # noqa
        ['src_ip',            {'ip4': '55.55.55.100'}, {'ip4': '255.255.255.255'},   'v4', 'port',  True, False,   True,    True,   True],  # noqa
        ['src_ip',            {'ip4': '10.10.50.100'},   {'ip4': '255.255.255.0'},   'v4',  'lag',  True, False,   True,    True,   True],  # noqa
        ['outer_vlan_id',                {'u16': 200},              {'u16': 4095}, 'both',  'lag',  True,  True,   True,    True,   True],  # noqa
        ['outer_vlan_pri',                  {'u8': 3},                  {'u8': 7}, 'both',  'lag', False, False,   True,    True,   True],  # noqa
        ['outer_vlan_cfi',                  {'u8': 0},                  {'u8': 1},   'v4',  'lag', False, False,   True,    True,   True],  # noqa
        ['ip_protocol',                     {'u8': 6},                {'u8': 127}, 'both', 'port',  True,  True,   True,    True,   True],  # noqa
        ['ip_protocol',                    {'u8': 17},                 {'u8': 63}, 'both',  'lag',  True,  True,   True,    True,   True],  # noqa
        ['dscp',                           {'u8': 14},                 {'u8': 63}, 'both', 'both',  True,  True,   True,    True,   True],  # noqa
        ['ecn',                             {'u8': 0},                  {'u8': 3}, 'both', 'port',  True,  True,   True,    True,   True],  # noqa
        ['ecn',                             {'u8': 2},                  {'u8': 3}, 'both',  'lag',  True,  True,   True,    True,   True],  # noqa
        ['tcp_flags',                      {'u8': 41},                 {'u8': 63}, 'both', 'port',  True,  True,   True,    True,   True],  # noqa
        ['icmp_code',                      {'u8': 25},                {'u8': 127},   'v4', 'port',  True, False,   True,    True,   True],  # noqa
        ['icmp_type',                      {'u8': 40},                 {'u8': 63},   'v4', 'port',  True, False,   True,    True,   True],  # noqa
        ['icmp_code',                      {'u8': 55},                {'u8': 127},   'v4',  'lag',  True, False,   True,    True,   True],  # noqa
        ['icmp_type',                       {'u8': 5},                {'u8': 127},   'v4',  'lag',  True, False,   True,    True,   True],  # noqa
        ['l4_src_port',                 {'u16': 4444},             {'u16': 32767}, 'both', 'both',  True,  True,   True,    True,   True],  # noqa
        ['l4_dst_port',                {'u16': 28055},             {'u16': 32767}, 'both',  'lag',  True,  True,   True,    True,   True],  # noqa
        ['l4_dst_port',                 {'u16': 5555},              {'u16': 8191}, 'both', 'port',  True,  True,   True,    True,   True],  # noqa
        ['acl_range_type',             {'min': 28000},             {'max': 28555}, 'both',  'lag',  True,  True,   True,    True,   True],  # noqa
        ['acl_range_type',              {'min': 4055},              {'max': 5855}, 'both', 'both',  True,  True,   True,    True,   True],  # noqa

        ['ipv6_next_header',                {'u8': 6},                 {'u8': 31},   'v6', 'port', False,  True,   True,    True,   True],  # noqa
        ['ipv6_next_header',               {'u8': 17},                 {'u8': 63},   'v6',  'lag', False,  True,   True,    True,   True],  # noqa
        ['icmpv6_code',                    {'u8': 25},                {'u8': 127},   'v6', 'port', False,  True,   True,    True,   True],  # noqa
        ['icmpv6_type',                    {'u8': 40},                 {'u8': 63},   'v6', 'port', False,  True,   True,    True,   True],  # noqa
        ['icmpv6_code',                    {'u8': 55},                {'u8': 127},   'v6',  'lag', False,  True,   True,    True,   True],  # noqa
        ['icmpv6_type',                     {'u8': 5},                {'u8': 127},   'v6',  'lag', False,  True,   True,    True,   True],  # noqa
        ['dst_ipv6',
         {'ip6': '1234:5678:8ab4:5ef0:4422:1133:5500:55aa'},
         {'ip6': 'FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:0000'},                         'v6', 'both', False,  True,   True,    True,   True],  # noqa
        ['src_ipv6',              {'ip6': '5000::1000:100'},
         {'ip6': 'FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FF00'},                         'v6',  'lag', False,  True,   True,    True,   True],  # noqa
        ['src_ipv6',                   {'ip6': '2000::100'},
         {'ip6': 'FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF'},                         'v6', 'port', False,  True,   True,    True,   True]   # noqa
        # ["{'eth_type': 0x0800, 'eth_type_mask': 0x7FFF}", True, None],
    ]
    # pylint: enable=bad-whitespace,line-too-long

    dst_ip_subnet = '100.55.155.0'
    dst_ip = '100.55.155.100'
    dst_mac = '00:11:22:33:44:55'
    port_smac = '00:22:22:22:22:22'
    lag_smac = '00:44:44:44:44:44'
    port_src_ip = '55.55.55.100'
    lag_src_ip = '10.10.50.100'
    tcp_dst_port = 5555
    tcp_src_port = 4444
    udp_dst_port = 28055
    udp_src_port = 4444

    dst_v6_subnet = '1234:5678:8ab4:5ef0:4422:1133:5500:0000/114'
    dst_v6 = '1234:5678:8ab4:5ef0:4422:1133:5500:55aa'
    port_src_v6 = '2000::100'
    lag_src_v6 = '5000::1000:100'
    dscp_val = 14
    ecn_val = 2
    tos_val = dscp_val << 2 | ecn_val

    high_prio = 500
    low_prio = 50
    lower_prio = 5

    def setUp(self):
        super(IngressAclTablesAllFieldTest, self).setUp()

        egress_rif1 = self.port10_rif

        #  allocate v4 neighbor, nhop, route
        print("Allocate V4 neighbor with ip %s, router interface %x"
              " dst_mac %s " % (self.dst_ip, egress_rif1, self.dst_mac))
        self.nbr_entry = sai_thrift_neighbor_entry_t(
            rif_id=egress_rif1,
            ip_address=sai_ipaddress(self.dst_ip))
        sai_thrift_create_neighbor_entry(
            self.client,
            self.nbr_entry,
            dst_mac_address=self.dst_mac)

        print("Allocate nhop with ip %s, router interface %x"
              % (self.dst_ip, egress_rif1))
        self.nhop = sai_thrift_create_next_hop(
            self.client,
            ip=sai_ipaddress(self.dst_ip),
            router_interface_id=egress_rif1,
            type=SAI_NEXT_HOP_TYPE_IP)

        print("Allocate route with ip subnet %s --> router interface %x"
              % (self.dst_ip_subnet, egress_rif1))
        self.route_entry = sai_thrift_route_entry_t(
            vr_id=self.default_vrf,
            destination=sai_ipprefix(self.dst_ip_subnet))
        sai_thrift_create_route_entry(
            self.client,
            self.route_entry,
            next_hop_id=egress_rif1)

        #  allocate v6 neighbor, nhop, route
        print("Allocate V6 neighbor with ip %s, router interface %x"
              " dst_mac %s " % (self.dst_v6, egress_rif1, self.dst_mac))
        self.v6_nbr_entry = sai_thrift_neighbor_entry_t(
            rif_id=egress_rif1,
            ip_address=sai_ipaddress(self.dst_v6))
        sai_thrift_create_neighbor_entry(
            self.client,
            self.v6_nbr_entry,
            dst_mac_address=self.dst_mac)

        print("Allocate v6 nhop with ip %s, router interface %x"
              % (self.dst_v6, egress_rif1))
        self.v6_nhop = sai_thrift_create_next_hop(
            self.client,
            ip=sai_ipaddress(self.dst_v6),
            router_interface_id=egress_rif1,
            type=SAI_NEXT_HOP_TYPE_IP)

        print("Allocate v6 route with ip prefix %s --> nhop %x"
              % (self.dst_v6_subnet, self.v6_nhop))
        self.v6_route_entry = sai_thrift_route_entry_t(
            vr_id=self.default_vrf,
            destination=sai_ipprefix(self.dst_v6_subnet))
        sai_thrift_create_route_entry(
            self.client,
            self.v6_route_entry,
            next_hop_id=self.v6_nhop)

        #  vlan200 with member lag 1 untag with rif
        self.vlan200 = sai_thrift_create_vlan(self.client, vlan_id=200)
        self.vlan_member1 = sai_thrift_create_vlan_member(
            self.client,
            vlan_id=self.vlan200,
            bridge_port_id=self.lag1_bp,
            vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_TAGGED)
        self.vlan200_rif = sai_thrift_create_router_interface(
            self.client,
            type=SAI_ROUTER_INTERFACE_TYPE_VLAN,
            virtual_router_id=self.default_vrf,
            vlan_id=self.vlan200)

        #  ACL table group
        self.table_stage = SAI_ACL_STAGE_INGRESS

        bpoints = [SAI_ACL_BIND_POINT_TYPE_SWITCH]
        self.bpoint_type_list = sai_thrift_s32_list_t(
            count=len(bpoints), int32list=bpoints)
        group_type = SAI_ACL_TABLE_GROUP_TYPE_PARALLEL

        self.acl_group = sai_thrift_create_acl_table_group(
            self.client,
            acl_stage=self.table_stage,
            acl_bind_point_type_list=self.bpoint_type_list,
            type=group_type)
        sai_thrift_set_switch_attribute(
            self.client, ingress_acl=self.acl_group)

        #  v4 pkt for in-port 11
        self.pkt = simple_tcp_packet(
            eth_dst=ROUTER_MAC,
            eth_src=self.port_smac,
            ip_dst=self.dst_ip,
            ip_src=self.port_src_ip,
            ip_id=105,
            tcp_sport=self.tcp_src_port,
            tcp_dport=self.tcp_dst_port,
            tcp_flags=41,
            ip_ttl=64,
            ip_dscp=self.dscp_val)
        self.e_pkt = simple_tcp_packet(
            eth_dst=self.dst_mac,
            eth_src=ROUTER_MAC,
            ip_dst=self.dst_ip,
            ip_src=self.port_src_ip,
            ip_id=105,
            tcp_sport=self.tcp_src_port,
            tcp_dport=self.tcp_dst_port,
            tcp_flags=41,
            ip_ttl=63,
            ip_dscp=self.dscp_val)
        #  v4 pkt for in-port lag 1
        self.tpkt = simple_udp_packet(
            eth_dst=ROUTER_MAC,
            eth_src=self.lag_smac,
            dl_vlan_enable=True,
            vlan_vid=200,
            vlan_pcp=3,
            dl_vlan_cfi=0,
            ip_src=self.lag_src_ip,
            ip_dst=self.dst_ip,
            udp_sport=self.udp_src_port,
            udp_dport=self.udp_dst_port,
            pktlen=104,
            ip_ttl=64,
            ip_tos=self.tos_val)
        self.e_tpkt = simple_udp_packet(
            eth_dst=self.dst_mac,
            eth_src=ROUTER_MAC,
            ip_src=self.lag_src_ip,
            ip_dst=self.dst_ip,
            udp_sport=self.udp_src_port,
            udp_dport=self.udp_dst_port,
            pktlen=100,
            ip_ttl=63,
            ip_tos=self.tos_val)

        #  v4 icmp pkt for in-port 11
        self.icmp_pkt = simple_icmp_packet(
            eth_dst=ROUTER_MAC,
            eth_src=self.port_smac,
            ip_dst=self.dst_ip,
            ip_src=self.port_src_ip,
            icmp_type=40,
            icmp_code=25,
            ip_ttl=64,
            ip_dscp=self.dscp_val)
        self.e_icmp_pkt = simple_icmp_packet(
            eth_dst=self.dst_mac,
            eth_src=ROUTER_MAC,
            ip_dst=self.dst_ip,
            ip_src=self.port_src_ip,
            icmp_type=40,
            icmp_code=25,
            ip_ttl=63,
            ip_dscp=self.dscp_val)
        #  v4 icmp pkt for in-port lag 1
        self.icmp_tpkt = simple_icmp_packet(
            eth_dst=ROUTER_MAC,
            eth_src=self.lag_smac,
            dl_vlan_enable=True,
            vlan_vid=200,
            vlan_pcp=3,
            ip_src=self.lag_src_ip,
            ip_dst=self.dst_ip,
            icmp_type=5,
            icmp_code=55,
            pktlen=68,
            ip_ttl=64,
            ip_tos=self.tos_val)
        self.e_icmp_tpkt = simple_icmp_packet(
            eth_dst=self.dst_mac,
            eth_src=ROUTER_MAC,
            ip_src=self.lag_src_ip,
            ip_dst=self.dst_ip,
            icmp_type=5,
            icmp_code=55,
            pktlen=64,
            ip_ttl=63,
            ip_tos=self.tos_val)

        #  v6 pkt for in-port 11
        self.pkt6 = simple_tcpv6_packet(
            eth_dst=ROUTER_MAC,
            eth_src=self.port_smac,
            ipv6_dst=self.dst_v6,
            ipv6_src=self.port_src_v6,
            tcp_sport=self.tcp_src_port,
            tcp_dport=self.tcp_dst_port,
            tcp_flags=41,
            ipv6_hlim=64,
            ipv6_dscp=self.dscp_val)
        self.e_pkt6 = simple_tcpv6_packet(
            eth_dst=self.dst_mac,
            eth_src=ROUTER_MAC,
            ipv6_dst=self.dst_v6,
            ipv6_src=self.port_src_v6,
            tcp_sport=self.tcp_src_port,
            tcp_dport=self.tcp_dst_port,
            tcp_flags=41,
            ipv6_hlim=63,
            ipv6_dscp=self.dscp_val)
        #  v6 pkt for in-port lag 1
        self.tpkt6 = simple_udpv6_packet(
            eth_dst=ROUTER_MAC,
            eth_src=self.lag_smac,
            dl_vlan_enable=True,
            vlan_vid=200,
            vlan_pcp=3,
            ipv6_src=self.lag_src_v6,
            ipv6_dst=self.dst_v6,
            udp_sport=self.udp_src_port,
            udp_dport=self.udp_dst_port,
            pktlen=40+18,
            ipv6_hlim=64,
            ipv6_tc=self.tos_val)
        self.e_tpkt6 = simple_udpv6_packet(
            eth_dst=self.dst_mac,
            eth_src=ROUTER_MAC,
            ipv6_src=self.lag_src_v6,
            ipv6_dst=self.dst_v6,
            udp_sport=self.udp_src_port,
            udp_dport=self.udp_dst_port,
            pktlen=40+14,
            ipv6_hlim=63,
            ipv6_tc=self.tos_val)

        #  v6 icmp pkt for in-port 11
        self.icmp_pkt6 = simple_icmpv6_packet(
            eth_dst=ROUTER_MAC,
            eth_src=self.port_smac,
            ipv6_dst=self.dst_v6,
            ipv6_src=self.port_src_v6,
            icmp_type=40,
            icmp_code=25,
            ipv6_hlim=64,
            ipv6_dscp=self.dscp_val)
        self.e_icmp_pkt6 = simple_icmpv6_packet(
            eth_dst=self.dst_mac,
            eth_src=ROUTER_MAC,
            ipv6_dst=self.dst_v6,
            ipv6_src=self.port_src_v6,
            icmp_type=40,
            icmp_code=25,
            ipv6_hlim=63,
            ipv6_dscp=self.dscp_val)
        #  v6 icmp pkt for in-port lag 1
        self.icmp_tpkt6 = simple_icmpv6_packet(
            eth_dst=ROUTER_MAC,
            eth_src=self.lag_smac,
            dl_vlan_enable=True,
            vlan_vid=200,
            vlan_pcp=3,
            ipv6_src=self.lag_src_v6,
            ipv6_dst=self.dst_v6,
            icmp_type=5,
            icmp_code=55,
            pktlen=68,
            ipv6_hlim=64,
            ipv6_tc=self.tos_val)
        self.e_icmp_tpkt6 = simple_icmpv6_packet(
            eth_dst=self.dst_mac,
            eth_src=ROUTER_MAC,
            ipv6_src=self.lag_src_v6,
            ipv6_dst=self.dst_v6,
            icmp_type=5,
            icmp_code=55,
            pktlen=64,
            ipv6_hlim=63,
            ipv6_tc=self.tos_val)

    def AllTrafficTest(self,
                       table_type,
                       pkt_test_type="v4",
                       exact_match_on=None,
                       port_counter=None,
                       lag_counter=None,
                       icmp_pkt=False):
        '''
        Verify v4/v6 tcp/udp/icmp traffic test for
        ingress ACl tables/entries
        '''
        print("    Test with %s traffic on port/lag " % (pkt_test_type))

        if pkt_test_type != "v4" and pkt_test_type != "v6":
            print("    Incorrect traffic pkt type, must be v4 or v6 ")
            return

        if port_counter is not None:
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, port_counter, packets=True)
            port_counter_cnt = packets['packets']

        if lag_counter is not None:
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, lag_counter, packets=True)
            lag_counter_cnt = packets['packets']

        print('   -----------------------------------------------------------')
        if icmp_pkt:
            if pkt_test_type == "v6":
                port_pkt = self.icmp_pkt6
                port_e_pkt = self.e_icmp_pkt6
                print("    Tx below V6 icmp packet from port 11 ")
                print("     [%s to %s], icmp code 25 type 40 "
                      % (self.port_src_v6, self.dst_v6))
            else:
                port_pkt = self.icmp_pkt
                port_e_pkt = self.e_icmp_pkt
                print("    Tx below V4 icmp packet from port 11 ")
                print("     [%s to %s], icmp code 25 type 40 "
                      % (self.port_src_ip, self.dst_ip))
        else:
            if pkt_test_type == "v6":
                port_pkt = self.pkt6
                port_e_pkt = self.e_pkt6
                print("    Tx below V6 tcp packet from port 11 ")
                print("     [%s to %s] " % (self.port_src_v6, self.dst_v6))
                print("     L4 port src [%d] dst [%d], flags 41, ip dscp 14"
                      % (self.tcp_src_port, self.tcp_dst_port))
            else:
                port_pkt = self.pkt
                port_e_pkt = self.e_pkt
                print("    Tx below V4 tcp packet from port 11 ")
                print("     [%s to %s] " % (self.port_src_ip, self.dst_ip))
                print("     L4 port src [%d] dst [%d], flags 41, ip dscp 14"
                      % (self.tcp_src_port, self.tcp_dst_port))

        #  Qos Acl set-tc action --> verify tc-dscp map
        #  To verify, change Rx pkt to have new tos value
        #  For port catch-all entry action tc 10 --> 40 dscp
        if table_type == "Qos-Acl":
            temp_e_pkt = port_e_pkt.copy()
            if pkt_test_type == "v6":
                temp_e_pkt[IPv6].tc = 40 << 2
            else:
                temp_e_pkt[IP].tos = 40 << 2
            port_e_pkt = temp_e_pkt

        #  verify traffic for acl rule on port
        send_packet(self, self.dev_port11, port_pkt)
        if port_counter is None or exact_match_on == 'lag':
            #  verify port catch-all entry action/stats
            if table_type == "Mir-Acl":
                print("      ----> route to port 10 [catch-all action]  ")
                print("      ----> mirror in-pkt to port 8 [catch-all]  ")
                verify_each_packet_on_each_port(
                    self,
                    [port_e_pkt, port_pkt],
                    [self.dev_port10, self.catch_all_rx_m_port])
            elif table_type == "Pbr-Acl":
                print("      ----> pbr to nhop[port 13] [catch-all action]  ")
                verify_packets(self, port_e_pkt, [self.catch_all_rx_pbr_port])
            else:
                print("      ----> route to port 10 [catch-all action]  ")
                verify_packets(self, port_e_pkt, [self.dev_port10])
            self.port_catch_all_cnt += 1
            time.sleep(1)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, self.port_catch_all_counter, packets=True)
            self.assertEqual(packets['packets'], self.port_catch_all_cnt)
        else:
            #  verify port rule entry action/stats
            if table_type == "Qos-Acl":
                #  Qos Acl set-tc action --> verify tc-dscp map
                #  To verify, change Rx pkt to have new tos value
                #  For port rule entry action tc 7 --> 25 dscp
                if pkt_test_type == "v6":
                    port_e_pkt[IPv6].tc = 25 << 2
                else:
                    port_e_pkt[IP].tos = 25 << 2
                #  pkt will still be forw here
                print("      ----> route to port 10, with 25 dscp  ")
                verify_packets(self, port_e_pkt, [self.dev_port10])
            elif table_type == "Mir-Acl":
                #  pkt will be forw here
                #  in-pkt will also get mirror
                print("      ----> route to port 10  ")
                print("      ----> mirror in-pkt to port 12  ")
                verify_each_packet_on_each_port(
                    self,
                    [port_e_pkt, port_pkt],
                    [self.dev_port10, self.port_rule_rx_m_port])
            elif table_type == "Pbr-Acl":
                #  pkt will be pbr forw to port 12
                print("      ----> pbr to lag 3  ")
                verify_packet_any_port(self, port_pkt,
                                       [self.port_rule_rx_pbr_lag_p1,
                                        self.port_rule_rx_pbr_lag_p2,
                                        self.port_rule_rx_pbr_lag_p3])
                verify_no_other_packets(self, timeout=2)
            else:
                #  pkt will get drop for v4/v6 acl
                print("      ----> drop ")
                verify_no_other_packets(self, timeout=1)
            port_counter_cnt += 1
            time.sleep(1)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, port_counter, packets=True)
            self.assertEqual(packets['packets'], port_counter_cnt)
        print('   -----------------------------------------------------------')

        if icmp_pkt:
            if pkt_test_type == "v6":
                lag_pkt = self.icmp_tpkt6
                lag_e_pkt = self.e_icmp_tpkt6
                print("    Tx below V6 icmp packet from lag 1 ")
                print("     [%s to %s]" % (self.lag_src_v6, self.dst_v6))
                print("     Vlan 200, icmp code 55 type 5 ")
            else:
                lag_pkt = self.icmp_tpkt
                lag_e_pkt = self.e_icmp_tpkt
                print("    Tx below V4 icmp packet from lag 1 ")
                print("     [%s to %s]" % (self.lag_src_ip, self.dst_ip))
                print("     Vlan 200, icmp code 55 type 5 ")
        else:
            if pkt_test_type == "v6":
                lag_pkt = self.tpkt6
                lag_e_pkt = self.e_tpkt6
                print("    Tx below V6 udp packet from lag 1 ")
                print("     [%s to %s]" % (self.lag_src_v6, self.dst_v6))
                print("     Vlan 200, L4 port src [%d] dst [%d], ip tos 58 "
                      % (self.udp_src_port, self.udp_dst_port))
            else:
                lag_pkt = self.tpkt
                lag_e_pkt = self.e_tpkt
                print("    Tx below V4 udp packet from lag 1 ")
                print("     [%s to %s]" % (self.lag_src_ip, self.dst_ip))
                print("     Vlan 200, L4 port src [%d] dst [%d], ip tos 58 "
                      % (self.udp_src_port, self.udp_dst_port))

        #  Qos Acl set-tc action --> verify tc-dscp map
        #  To verify, change Rx pkt to have new tos value
        #  For lag catch-all entry action tc 10 --> 40 dscp
        if table_type == "Qos-Acl":
            temp_e_pkt = lag_e_pkt.copy()
            if pkt_test_type == "v6":
                temp_e_pkt[IPv6].tc = 40 << 2 | self.ecn_val
            else:
                temp_e_pkt[IP].tos = 40 << 2 | self.ecn_val
            lag_e_pkt = temp_e_pkt

        #  verify traffic for acl rule on lag
        send_packet(self, self.dev_port5, lag_pkt)
        if lag_counter is None or exact_match_on == 'port':
            #  verify lag catch-all entry action/stats
            if table_type == "Mir-Acl":
                print("      ----> route to port 10 [catch-all action]  ")
                print("      ----> mirror in-pkt to port 8 [catch-all]  ")
                verify_each_packet_on_each_port(
                    self,
                    [lag_e_pkt, lag_pkt],
                    [self.dev_port10, self.catch_all_rx_m_port])
            elif table_type == "Pbr-Acl":
                print("      ----> pbr to nhop[port 13] [catch-all action]  ")
                verify_packets(self, lag_e_pkt, [self.catch_all_rx_pbr_port])
            else:
                print("      ----> route to port 10 [catch-all action]  ")
                verify_packets(self, lag_e_pkt, [self.dev_port10])
            self.lag_catch_all_cnt += 1
            time.sleep(1)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, self.lag_catch_all_counter, packets=True)
            self.assertEqual(packets['packets'], self.lag_catch_all_cnt)
        else:
            #  verify lag rule entry action/stats
            if table_type == "Qos-Acl":
                #  Qos Acl set-tc action --> verify tc-dscp map
                #  To verify, change Rx pkt to have new tos value
                #  For lag rule entry action tc 5 --> 55 dscp
                if pkt_test_type == "v6":
                    lag_e_pkt[IPv6].tc = 55 << 2 | self.ecn_val
                else:
                    lag_e_pkt[IP].tos = 55 << 2 | self.ecn_val
                #  pkt will still be forw here
                print("      ----> route to port 10, with 55 dscp  ")
                verify_packets(self, lag_e_pkt, [self.dev_port10])
            elif table_type == "Mir-Acl":
                #  pkt will be forw here
                #  in-pkt will also get mirror
                print("      ----> route to port 10  ")
                print("      ----> mirror in-pkt to port 14  ")
                verify_each_packet_on_each_port(
                    self,
                    [lag_e_pkt, lag_pkt],
                    [self.dev_port10, self.lag_rule_rx_m_port])
            elif table_type == "Pbr-Acl":
                #  pkt will be pbr forw to port 12
                print("      ----> pbr to port 12  ")
                verify_packets(self, lag_pkt, [self.lag_rule_rx_pbr_port])
            else:
                #  pkt will get drop for v4/v6 acl
                print("      ----> drop ")
                verify_no_other_packets(self, timeout=1)
            lag_counter_cnt += 1
            time.sleep(1)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, lag_counter, packets=True)
            self.assertEqual(packets['packets'], lag_counter_cnt)
        print('   -----------------------------------------------------------')

    def ingressV4AclTableTest(self):
        '''
        Verify all the match fields, along with
        both port/lag as in-port field using switch
        b-point in ipv4 ACL table
        '''
        print(" ingressV4AclTableTest")

        try:
            acl_range_type = sai_thrift_s32_list_t(count=0, int32list=[])
            acl_table = sai_thrift_create_acl_table(
                self.client,
                acl_stage=self.table_stage,
                acl_bind_point_type_list=self.bpoint_type_list,
                field_src_ip=True,
                field_dst_ip=True,
                field_ip_protocol=True,
                field_dscp=True,
                field_ecn=True,
                field_l4_src_port=True,
                field_l4_dst_port=True,
                field_tcp_flags=True,
                field_acl_range_type=acl_range_type,
                field_icmp_code=True,
                field_icmp_type=True,
                field_outer_vlan_id=True,
                field_in_port=True)
            self.assertNotEqual(acl_table, 0)

            acl_group_member = sai_thrift_create_acl_table_group_member(
                self.client,
                acl_table_group_id=self.acl_group,
                acl_table_id=acl_table)
            self.assertNotEqual(acl_group_member, 0)

            print("  V4-Acl catch all entry with action permit ")
            #  setup action for catch all entries
            action_forw = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    s32=SAI_PACKET_ACTION_FORWARD))
            a_type_t = "action_packet_action"
            a_value_t = {a_type_t: action_forw}

            self.testAllTableField(acl_table, a_value_t, "V4-Acl", "v4")

        finally:
            #  cleanup acl group member, table
            sai_thrift_remove_acl_table_group_member(
                self.client, acl_group_member)
            sai_thrift_remove_acl_table(self.client, acl_table)

    def ingressV6AclTableTest(self):
        '''
        Verify all the match fields, along with
        both port/lag as in-port field using switch
        b-point in V6 ACL table
        '''
        print(" ingressV6AclTableTest")

        try:
            acl_range_type = sai_thrift_s32_list_t(count=0, int32list=[])
            v6_acl_table = sai_thrift_create_acl_table(
                self.client,
                acl_stage=self.table_stage,
                acl_bind_point_type_list=self.bpoint_type_list,
                field_src_ipv6=True,
                field_dst_ipv6=True,
                field_ip_protocol=True,
                field_ipv6_next_header=True,
                field_dscp=True,
                field_ecn=True,
                field_l4_src_port=True,
                field_l4_dst_port=True,
                field_tcp_flags=True,
                field_acl_range_type=acl_range_type,
                field_icmpv6_code=True,
                field_icmpv6_type=True,
                field_outer_vlan_id=True,
                field_in_port=True)
            self.assertNotEqual(v6_acl_table, 0)

            acl_group_member = sai_thrift_create_acl_table_group_member(
                self.client,
                acl_table_group_id=self.acl_group,
                acl_table_id=v6_acl_table)
            self.assertNotEqual(acl_group_member, 0)

            print("  V6-Acl catch all entry with action permit ")
            #  setup action for catch all entries
            action_forw = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    s32=SAI_PACKET_ACTION_FORWARD))
            a_type_t = "action_packet_action"
            a_value_t = {a_type_t: action_forw}

            self.testAllTableField(v6_acl_table, a_value_t, "V6-Acl", "v6")

        finally:
            #  cleanup acl group member, table
            sai_thrift_remove_acl_table_group_member(
                self.client, acl_group_member)
            sai_thrift_remove_acl_table(self.client, v6_acl_table)

    def ingressQosAclTableTest(self):
        '''
        Verify all the match fields, along with
        both port/lag as in-port field using switch
        b-point in QoS ACL table
        '''
        print(" ingressQosAclTableTest")

        try:
            action_type = [SAI_ACL_ACTION_TYPE_SET_TC]
            qos_action_type_list = sai_thrift_s32_list_t(
                count=len(action_type), int32list=action_type)

            acl_range_type = sai_thrift_s32_list_t(count=0, int32list=[])
            qos_acl_table = sai_thrift_create_acl_table(
                self.client,
                acl_stage=self.table_stage,
                acl_bind_point_type_list=self.bpoint_type_list,
                field_src_mac=True,
                field_dst_mac=True,
                field_ether_type=True,
                field_src_ip=True,
                field_dst_ip=True,
                field_src_ipv6=True,
                field_dst_ipv6=True,
                field_ip_protocol=True,
                field_ipv6_next_header=True,
                field_dscp=True,
                field_ecn=True,
                field_l4_src_port=True,
                field_l4_dst_port=True,
                field_tcp_flags=True,
                field_acl_range_type=acl_range_type,
                field_icmp_code=True,
                field_icmp_type=True,
                field_icmpv6_code=True,
                field_icmpv6_type=True,
                field_outer_vlan_id=True,
                field_outer_vlan_pri=True,
                field_in_port=True,
                acl_action_type_list=qos_action_type_list)
            self.assertNotEqual(qos_acl_table, 0)

            acl_group_member = sai_thrift_create_acl_table_group_member(
                self.client,
                acl_table_group_id=self.acl_group,
                acl_table_id=qos_acl_table)
            self.assertNotEqual(acl_group_member, 0)

            #  map all tc values with color green to dscp
            #  This will change the dscp value on egress
            #  based of tc value set by qos Acl entry
            egress_tc_color_list = [
                [10, 0],
                [7, 0],
                [8, 0],
                [5, 0],  # green
            ]
            egress_dscp_list = [
                40, 25, 18, 55,  # mapping green
            ]
            qos_tc_color_to_dscp_map = create_and_verify_qos_map(
                self.client,
                SAI_QOS_MAP_TYPE_TC_AND_COLOR_TO_DSCP,
                egress_tc_color_list,
                egress_dscp_list)
            self.assertTrue(qos_tc_color_to_dscp_map != 0,
                            "  Fail to alloc tc_color_to_dscp map  ")

            #  map above qos map to egress port
            status = sai_thrift_set_port_attribute(
                self.client,
                self.port10,
                qos_tc_and_color_to_dscp_map=qos_tc_color_to_dscp_map)
            self.assertEqual(status, SAI_STATUS_SUCCESS,
                             "  Fail to set tc_color_to_dscp map to port 10  ")
            attr = sai_thrift_get_port_attribute(
                self.client, self.port10,
                qos_tc_and_color_to_dscp_map=True)
            self.assertEqual(attr['qos_tc_and_color_to_dscp_map'],
                             qos_tc_color_to_dscp_map)

            print("  Qos Acl catch all entry action set-tc to 10-->40 dscp  ")
            #  setup action for catch all entries
            action_tc_set = sai_thrift_acl_action_data_t(
                enable=True,
                parameter=sai_thrift_acl_action_parameter_t(u8=10))
            a_type_t = "action_set_tc"
            a_value_t = {a_type_t: action_tc_set}

            self.testAllTableField(qos_acl_table, a_value_t, "Qos-Acl", "v4")
            self.testAllTableField(qos_acl_table, a_value_t, "Qos-Acl", "v6")

        finally:
            #  cleanup egress qos map
            status = sai_thrift_set_port_attribute(
                self.client, self.port10,
                qos_tc_and_color_to_dscp_map=0)
            self.assertEqual(status, SAI_STATUS_SUCCESS,
                             "  Fail to reset tc_color_to_dscp for port 10  ")
            sai_thrift_remove_qos_map(self.client, qos_tc_color_to_dscp_map)

            #  cleanup acl group member, table
            sai_thrift_remove_acl_table_group_member(
                self.client, acl_group_member)
            sai_thrift_remove_acl_table(self.client, qos_acl_table)

    def ingressMirrorAclTableTest(self):
        '''
        Verify all the match fields, along with
        both port/lag as in-port field using switch
        b-point in IP Mirror ACL table
        '''
        print(" ingressMirrorAclTableTest ")

        self.catch_all_rx_m_port = self.dev_port8
        self.catch_all_m_port = self.port8
        self.port_rule_rx_m_port = self.dev_port12
        self.port_rule_m_port = self.port12
        self.lag_rule_rx_m_port = self.dev_port14
        self.lag_rule_m_port = self.port14

        try:
            action_type = [SAI_ACL_ACTION_TYPE_MIRROR_INGRESS]
            action_type_list = sai_thrift_s32_list_t(
                count=len(action_type), int32list=action_type)

            acl_range_type = sai_thrift_s32_list_t(count=0, int32list=[])
            mir_acl_table = sai_thrift_create_acl_table(
                self.client,
                acl_stage=self.table_stage,
                acl_bind_point_type_list=self.bpoint_type_list,
                field_src_ip=True,
                field_dst_ip=True,
                field_src_ipv6=True,
                field_dst_ipv6=True,
                field_ip_protocol=True,
                field_ipv6_next_header=True,
                field_dscp=True,
                field_ecn=True,
                field_l4_src_port=True,
                field_l4_dst_port=True,
                field_tcp_flags=True,
                field_acl_range_type=acl_range_type,
                field_icmp_code=True,
                field_icmp_type=True,
                field_icmpv6_code=True,
                field_icmpv6_type=True,
                field_outer_vlan_id=True,
                field_outer_vlan_pri=True,
                field_in_port=True,
                acl_action_type_list=action_type_list)
            self.assertNotEqual(mir_acl_table, 0)

            acl_group_member = sai_thrift_create_acl_table_group_member(
                self.client,
                acl_table_group_id=self.acl_group,
                acl_table_id=mir_acl_table)
            self.assertNotEqual(acl_group_member, 0)

            #  alloc mirror port 8 for catch all rule
            self.catch_all_mirror_session = sai_thrift_create_mirror_session(
                self.client,
                monitor_port=self.catch_all_m_port,
                type=SAI_MIRROR_SESSION_TYPE_LOCAL)
            #  alloc mirror port 12 for rule matching in-port 11
            self.port_entry_mirror_session = sai_thrift_create_mirror_session(
                self.client,
                monitor_port=self.port_rule_m_port,
                type=SAI_MIRROR_SESSION_TYPE_LOCAL)
            #  alloc mirror port 14 for rule matching in-port lag 1
            self.lag_entry_mirror_session = sai_thrift_create_mirror_session(
                self.client,
                monitor_port=self.lag_rule_m_port,
                type=SAI_MIRROR_SESSION_TYPE_LOCAL)

            print("  IP Mirror Acl catch all entry action in-mirror port 8 ")
            #  setup action for catch all entries
            mirror_session_list = sai_thrift_object_list_t(
                count=1, idlist=[self.catch_all_mirror_session])
            action_mirror = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    objlist=mirror_session_list))
            a_type_t = "action_mirror_ingress"
            a_value_t = {a_type_t: action_mirror}

            self.testAllTableField(mir_acl_table, a_value_t, "Mir-Acl", "v4")
            self.testAllTableField(mir_acl_table, a_value_t, "Mir-Acl", "v6")

        finally:
            #  cleanup mirror sessions
            sai_thrift_remove_mirror_session(
                self.client,
                self.catch_all_mirror_session)
            sai_thrift_remove_mirror_session(
                self.client,
                self.port_entry_mirror_session)
            sai_thrift_remove_mirror_session(
                self.client,
                self.lag_entry_mirror_session)

            #  cleanup acl group member, table
            sai_thrift_remove_acl_table_group_member(
                self.client, acl_group_member)
            sai_thrift_remove_acl_table(self.client, mir_acl_table)

    def ingressPbrAclTableTest(self):
        '''
        Verify all the match fields, along with
        both port/lag as in-port field using switch
        b-point in Pbr ACL table
        '''
        print(" ingressPbrAclTableTest ")

        self.catch_all_rx_pbr_port = self.dev_port13
        self.catch_all_pbr_nhop = self.port13
        self.port_rule_rx_pbr_lag_p1 = self.dev_port14
        self.port_rule_rx_pbr_lag_p2 = self.dev_port15
        self.port_rule_rx_pbr_lag_p3 = self.dev_port16
        self.port_rule_pbr_lag = self.lag3
        self.lag_rule_rx_pbr_port = self.dev_port12
        self.lag_rule_pbr_port = self.port12

        try:
            action_type = [SAI_ACL_ACTION_TYPE_REDIRECT]
            action_type_list = sai_thrift_s32_list_t(
                count=len(action_type), int32list=action_type)

            acl_range_type = sai_thrift_s32_list_t(count=0, int32list=[])
            pbr_acl_table = sai_thrift_create_acl_table(
                self.client,
                acl_stage=self.table_stage,
                acl_bind_point_type_list=self.bpoint_type_list,
                field_src_ip=True,
                field_dst_ip=True,
                field_src_ipv6=True,
                field_dst_ipv6=True,
                field_ip_protocol=True,
                field_ipv6_next_header=True,
                field_dscp=True,
                field_ecn=True,
                field_l4_src_port=True,
                field_l4_dst_port=True,
                field_tcp_flags=True,
                field_acl_range_type=acl_range_type,
                field_icmp_code=True,
                field_icmp_type=True,
                field_icmpv6_code=True,
                field_icmpv6_type=True,
                field_outer_vlan_id=True,
                field_outer_vlan_pri=True,
                field_in_port=True,
                acl_action_type_list=action_type_list)
            self.assertNotEqual(pbr_acl_table, 0)

            acl_group_member = sai_thrift_create_acl_table_group_member(
                self.client,
                acl_table_group_id=self.acl_group,
                acl_table_id=pbr_acl_table)
            self.assertNotEqual(acl_group_member, 0)

            pbr_nbr = sai_thrift_neighbor_entry_t(
                rif_id=self.port13_rif,
                ip_address=sai_ipaddress(self.dst_ip))
            sai_thrift_create_neighbor_entry(
                self.client,
                pbr_nbr,
                dst_mac_address=self.dst_mac,
                no_host_route=True)
            pbr_nhop = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_IP,
                router_interface_id=self.port13_rif,
                ip=sai_ipaddress(self.dst_ip))

            print("  Pbr Acl catch all entry action forw to port 13 ")
            #  setup action for catch all entries
            action_re = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    s32=SAI_ACL_ENTRY_ATTR_ACTION_REDIRECT,
                    oid=pbr_nhop))
            a_type_t = "action_redirect"
            a_value_t = {a_type_t: action_re}

            self.testAllTableField(pbr_acl_table, a_value_t, "Pbr-Acl", "v4")
            self.testAllTableField(pbr_acl_table, a_value_t, "Pbr-Acl", "v6")

        finally:
            sai_thrift_remove_next_hop(self.client, pbr_nhop)
            sai_thrift_remove_neighbor_entry(self.client, pbr_nbr)

            #  cleanup acl group member, table
            sai_thrift_remove_acl_table_group_member(
                self.client, acl_group_member)
            sai_thrift_remove_acl_table(self.client, pbr_acl_table)

    def setPortLagRuleAction(self, table_type):
        print("  Set rule action for port/lag in %s Table " % table_type)

        #   action config for every port/lag rule
        if table_type == "V4-Acl" or table_type == "V6-Acl":
            """
            V4/V6 Acl rule matching actions
                Matching on in-port 11
                    --> action drop
                Matching on in-port lag 1
                    --> action drop
            """
            print("  Set port/lag v4/v6 acl rule action to drop  ")
            action_value = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    s32=SAI_PACKET_ACTION_DROP))
            a_type_t = "action_packet_action"
            self.port_rule_action = {a_type_t: action_value}
            self.lag_rule_action = {a_type_t: action_value}
        elif table_type == "Qos-Acl":
            """
            Qos Acl rule matching actions
                Matching on in-port 11
                    --> route to port 10
                    --> action set-tc 7 --> 25 dscp
                Matching on in-port lag 1
                    --> route to port 10
                    --> action set-tc 5 --> 55 dscp
            """
            print("  Set port qos acl rule action to set-tc 7 --> 25 dscp  ")
            port_action_value = sai_thrift_acl_action_data_t(
                enable=True,
                parameter=sai_thrift_acl_action_parameter_t(u8=7))
            a_type_t = "action_set_tc"
            self.port_rule_action = {a_type_t: port_action_value}

            print("  Set lag qos acl rule action to set-tc 5 --> 55 dscp  ")
            lag_action_value = sai_thrift_acl_action_data_t(
                enable=True,
                parameter=sai_thrift_acl_action_parameter_t(u8=5))
            self.lag_rule_action = {a_type_t: lag_action_value}
        elif table_type == "Mir-Acl":
            """
            Mirror Acl rule matching actions
                Matching on in-port 11
                    --> route to port 10
                    --> action in-pkt mirror to port 12
                Matching on in-port lag 1
                    --> route to port 10
                    --> action in-pkt mirror to port 14
            """
            print("  Set port mirror acl rule action in-mirror to port 12  ")
            mirror_session_list = sai_thrift_object_list_t(
                count=1, idlist=[self.port_entry_mirror_session])
            port_action_value = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    objlist=mirror_session_list))
            a_type_t = "action_mirror_ingress"
            self.port_rule_action = {a_type_t: port_action_value}

            print("  Set lag mirror acl rule action in-mirror to port 14  ")
            mirror_session_list = sai_thrift_object_list_t(
                count=1, idlist=[self.lag_entry_mirror_session])
            lag_action_value = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    objlist=mirror_session_list))
            a_type_t = "action_mirror_ingress"
            self.lag_rule_action = {a_type_t: lag_action_value}
        elif table_type == "Pbr-Acl":
            """
            Pbr Acl rule matching actions
                Matching on in-port 11
                    --> action forw to lag 3
                Matching on in-port lag 1
                    --> action forw to port 12
            """
            print("  Set port pbr acl rule action forw to lag 3  ")
            port_action_value = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    s32=SAI_ACL_ENTRY_ATTR_ACTION_REDIRECT,
                    oid=self.port_rule_pbr_lag))
            a_type_t = "action_redirect"
            self.port_rule_action = {a_type_t: port_action_value}

            print("  Set lag pbr acl rule action forw to port 12  ")
            lag_action_value = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    s32=SAI_ACL_ENTRY_ATTR_ACTION_REDIRECT,
                    oid=self.lag_rule_pbr_port))
            a_type_t = "action_redirect"
            self.lag_rule_action = {a_type_t: lag_action_value}

    def testAllTableField(self, acl_table, action_catch_all,
                          table_type, pkt_test_type):
        print("  Test all match fields in %s Table with %s traffic "
              % (table_type, pkt_test_type))

        #  install/verify traffic with catch-all rules first
        print("  Acl catch all entry for in-port 11 ")
        in_port_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(oid=self.port11))
        port_catch_all_acl_entry = sai_thrift_create_acl_entry(
            self.client,
            table_id=acl_table,
            priority=self.lower_prio,
            field_in_port=in_port_t,
            **action_catch_all)
        self.assertNotEqual(port_catch_all_acl_entry, 0)

        #  ACL catch all counter for port 11
        self.port_catch_all_counter = sai_thrift_create_acl_counter(
            self.client, table_id=acl_table)
        #  Attach port catch all counter to port catch all entry
        action_counter_t = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=self.port_catch_all_counter),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, port_catch_all_acl_entry,
            action_counter=action_counter_t)

        print("  Acl catch all entry for in-port lag 1 ")
        in_lag_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(oid=self.lag1))
        lag_catch_all_acl_entry = sai_thrift_create_acl_entry(
            self.client,
            table_id=acl_table,
            priority=self.lower_prio,
            field_in_port=in_lag_t,
            **action_catch_all)
        self.assertNotEqual(lag_catch_all_acl_entry, 0)

        #  ACL catch all counter for lag 1
        self.lag_catch_all_counter = sai_thrift_create_acl_counter(
            self.client, table_id=acl_table)
        #  Attach lag catch all counter to lag catch all entry
        action_counter_t1 = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=self.lag_catch_all_counter),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, lag_catch_all_acl_entry,
            action_counter=action_counter_t1)

        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.port_catch_all_counter, packets=True)
        self.assertEqual(packets['packets'], 0)
        self.port_catch_all_cnt = packets['packets']

        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.lag_catch_all_counter, packets=True)
        self.assertEqual(packets['packets'], 0)
        self.lag_catch_all_cnt = packets['packets']

        print("  Test %s traffic only with catch-all acl entries "
              % (pkt_test_type))
        self.AllTrafficTest(table_type, pkt_test_type)

        no_action_counter = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=0),
            enable=True)

        self.setPortLagRuleAction(table_type)

        #  walk through the table_rules to install/verify/remove
        #  rule for each field
        for i_rule in self.table_rules:
            print("  ==================================================== ")
            print("  ---------- Rule/Field for %s -----------" % table_type)
            print("   Field type:       %s " % i_rule[0])
            print("   Field value1:     %s " % i_rule[1])
            print("   Field value2:     %s " % i_rule[2])
            print("   Field pkt type:   %s " % i_rule[3])
            print("   Field matches on: %s " % i_rule[4])
            print("   Field in V4-Acl:  %s " % i_rule[5])
            print("   Field in V6-Acl:  %s " % i_rule[6])
            print("   Field in Qos-Acl: %s " % i_rule[7])
            print("   Field in Mir-Acl: %s " % i_rule[8])
            print("   Field in Pbr-Acl: %s " % i_rule[9])
            print(" ")

            #  if field not part of this acl table type, continue
            if ((table_type == "V4-Acl" and i_rule[5] is False) or
                    (table_type == "V6-Acl" and i_rule[6] is False) or
                    (table_type == "Qos-Acl" and i_rule[7] is False) or
                    (table_type == "Mir-Acl" and i_rule[8] is False) or
                    (table_type == "Pbr-Acl" and i_rule[9] is False)):
                print("   Skip, rule field %s not part of table_type %s "
                      % (i_rule[0], table_type))
                continue

            #  if traffic type req for field i.e.[v4, v6] is not same
            #  as traffic type tested, continue
            if i_rule[3] != 'both' and pkt_test_type != i_rule[3]:
                print("   Skip rule field %s in table type %s, "
                      "  traffic req for this rule %s - testing %s traffic "
                      % (table_type, i_rule[0], i_rule[3], pkt_test_type))
                continue

            #  if fields are icmp param, use icmp packet
            icmp_pkt = False
            if ((i_rule[0] == 'icmp_code') or
                    (i_rule[0] == 'icmp_type') or
                    (i_rule[0] == 'icmpv6_code') or
                    (i_rule[0] == 'icmpv6_type')):
                icmp_pkt = True

            #  field value
            if i_rule[0] == 'acl_range_type':
                #  For acl range
                if i_rule[4] == 'lag':
                    range_type = SAI_ACL_RANGE_TYPE_L4_DST_PORT_RANGE
                else:
                    range_type = SAI_ACL_RANGE_TYPE_L4_SRC_PORT_RANGE
                u32range = sai_thrift_u32_range_t(
                    **i_rule[1], **i_rule[2])
                acl_range = sai_thrift_create_acl_range(
                    self.client,
                    type=range_type,
                    limit=u32range)
                range_list = [acl_range]
                print("  ACL range alloc 0x%lx for range type %d "
                      % (acl_range, range_type))

                field_value_t = sai_thrift_acl_field_data_t(
                    data=sai_thrift_acl_field_data_data_t(
                        objlist=sai_thrift_object_list_t(
                            count=len(range_list),
                            idlist=range_list)))
            else:
                #  For all other field
                field_value_t = sai_thrift_acl_field_data_t(
                    data=sai_thrift_acl_field_data_data_t(**i_rule[1]),
                    mask=sai_thrift_acl_field_data_mask_t(**i_rule[2]))

            field_t = 'field_'+i_rule[0]
            field_value = {field_t: field_value_t}

            #  program the rule with in-port port 11
            print("  Acl entry with field %s [%s %s], in-port 11 "
                  % (i_rule[0], i_rule[1], i_rule[2]))
            port_acl_entry = sai_thrift_create_acl_entry(
                self.client,
                table_id=acl_table,
                priority=self.low_prio,
                field_in_port=in_port_t,
                **self.port_rule_action,
                **field_value)
            self.assertNotEqual(port_acl_entry, 0)

            #  acl counter
            port_acl_counter = sai_thrift_create_acl_counter(
                self.client, table_id=acl_table)
            #  Attach acl counter to port acl entry
            port_action_counter = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=port_acl_counter),
                enable=True)
            sai_thrift_set_acl_entry_attribute(
                self.client, port_acl_entry,
                action_counter=port_action_counter)

            self.AllTrafficTest(table_type, pkt_test_type, i_rule[4],
                                port_acl_counter, None, icmp_pkt)

            #  program the rule with in-port lag 1
            print("  Acl entry with field %s [%s %s], in-port lag 1 "
                  % (i_rule[0], i_rule[1], i_rule[2]))
            lag_acl_entry = sai_thrift_create_acl_entry(
                self.client,
                table_id=acl_table,
                priority=self.low_prio,
                field_in_port=in_lag_t,
                **self.lag_rule_action,
                **field_value)
            self.assertNotEqual(lag_acl_entry, 0)

            #  acl counter
            lag_acl_counter = sai_thrift_create_acl_counter(
                self.client, table_id=acl_table)
            #  Attach acl counter to lag acl entry
            lag_action_counter = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=lag_acl_counter),
                enable=True)
            sai_thrift_set_acl_entry_attribute(
                self.client, lag_acl_entry,
                action_counter=lag_action_counter)

            self.AllTrafficTest(table_type, pkt_test_type, i_rule[4],
                                port_acl_counter, lag_acl_counter, icmp_pkt)

            #  cleanup acl entry, counter on lag 1
            sai_thrift_set_acl_entry_attribute(
                self.client, lag_acl_entry,
                action_counter=no_action_counter)
            sai_thrift_remove_acl_counter(self.client, lag_acl_counter)
            sai_thrift_remove_acl_entry(self.client, lag_acl_entry)

            #  cleanup acl entry, counter on port 11
            sai_thrift_set_acl_entry_attribute(
                self.client, port_acl_entry,
                action_counter=no_action_counter)
            sai_thrift_remove_acl_counter(self.client, port_acl_counter)
            sai_thrift_remove_acl_entry(self.client, port_acl_entry)

            #  cleanup acl range if exists
            if i_rule[0] == 'acl_range_type':
                sai_thrift_remove_acl_range(self.client, acl_range)

        #  cleanup catch all acl entry, counter on lag 1
        sai_thrift_set_acl_entry_attribute(
            self.client, lag_catch_all_acl_entry,
            action_counter=no_action_counter)
        sai_thrift_remove_acl_counter(self.client, self.lag_catch_all_counter)
        sai_thrift_remove_acl_entry(self.client, lag_catch_all_acl_entry)

        #  cleanup catch all acl entry, counter on port 11
        sai_thrift_set_acl_entry_attribute(
            self.client, port_catch_all_acl_entry,
            action_counter=no_action_counter)
        sai_thrift_remove_acl_counter(self.client, self.port_catch_all_counter)
        sai_thrift_remove_acl_entry(self.client, port_catch_all_acl_entry)

    def runTest(self):
        print(" AclTableAllFieldTest ")
        self.ingressV4AclTableTest()
        print(" ")
        self.ingressV6AclTableTest()
        print(" ")
        self.ingressQosAclTableTest()
        print(" ")
        self.ingressMirrorAclTableTest()
        self.ingressPbrAclTableTest()

    def tearDown(self):
        sai_thrift_set_switch_attribute(self.client, ingress_acl=0)
        sai_thrift_remove_acl_table_group(self.client, self.acl_group)
        sai_thrift_remove_router_interface(self.client, self.vlan200_rif)
        sai_thrift_remove_vlan_member(self.client, self.vlan_member1)
        sai_thrift_remove_vlan(self.client, self.vlan200)

        sai_thrift_remove_route_entry(self.client, self.v6_route_entry)
        sai_thrift_remove_next_hop(self.client, self.v6_nhop)
        sai_thrift_remove_neighbor_entry(self.client, self.v6_nbr_entry)
        sai_thrift_remove_route_entry(self.client, self.route_entry)
        sai_thrift_remove_next_hop(self.client, self.nhop)
        sai_thrift_remove_neighbor_entry(self.client, self.nbr_entry)
        super(IngressAclTablesAllFieldTest, self).tearDown()


@group('acl2')
class DstIpAclTest(SaiHelper):
    """
    Verify matching on dst ip address field
    """

    def setUp(self):
        super(DstIpAclTest, self).setUp()

        l4_dst_port = 1000

        rif_id1 = self.port10_rif
        self.rif_id2 = self.port11_rif

        ip_addr_subnet = '172.16.10.0'
        ip_addr = '172.16.10.1'
        dmac = '00:11:22:33:44:55'
        mac_src = '00:22:22:22:22:22'
        ip_addr_src = '192.168.100.100'

        print("Create neighbor with %s ip address, %d router interface"
              " id and %s destination mac" % (
                  ip_addr, rif_id1, dmac))
        self.nbr_entry = sai_thrift_neighbor_entry_t(
            rif_id=rif_id1,
            ip_address=sai_ipaddress(ip_addr))
        sai_thrift_create_neighbor_entry(
            self.client, self.nbr_entry, dst_mac_address=dmac)

        print("Create nhop with %s ip address and %d router"
              " interface id" % (ip_addr, rif_id1))
        self.nhop = sai_thrift_create_next_hop(
            self.client,
            ip=sai_ipaddress(ip_addr),
            router_interface_id=rif_id1,
            type=SAI_NEXT_HOP_TYPE_IP)

        print("Create route with %s ip prefix and %d router"
              " interface id" % (ip_addr_subnet, rif_id1))
        self.route_entry = sai_thrift_route_entry_t(
            vr_id=self.default_vrf, destination=sai_ipprefix(
                ip_addr_subnet))
        sai_thrift_create_route_entry(self.client, self.route_entry,
                                      next_hop_id=rif_id1)

        self.pkt = simple_tcp_packet(eth_dst=ROUTER_MAC,
                                     eth_src=mac_src,
                                     ip_dst=ip_addr,
                                     ip_src=ip_addr_src,
                                     tcp_sport=l4_dst_port,
                                     ip_id=105,
                                     ip_ttl=64)
        self.exp_pkt = simple_tcp_packet(eth_dst=dmac,
                                         eth_src=ROUTER_MAC,
                                         ip_dst=ip_addr,
                                         ip_src=ip_addr_src,
                                         tcp_sport=l4_dst_port,
                                         ip_id=105,
                                         ip_ttl=63)

    def basicV4TrafficTest(self):
        '''
        Verify V4 traffic test before
        applying ingress ipv4 ACl table entry.
        '''
        print("basicV4TrafficTest")

        print('--------------------------------------------------------------'
              '--------------------------------')
        print("Sending packet port 11 -> port 10 (192.168.100.100 "
              "---> 172.16.10.1 [id = 105])")

        try:
            print('#### NO ACL Applied ####')
            print('#### Sending  ', ROUTER_MAC, '| 00:22:22:22:22:22 | '
                  '172.16.10.1 | 192.168.100.100 | SPORT 1000 | @ port 11')
            send_packet(self, self.dev_port11, self.pkt)
            print('#### Expecting 00:11:22:33:44:55 |', ROUTER_MAC, '| '
                  '172.16.10.1 | 192.168.100.100 | SPORT 1000 | @ port 10')
            verify_packets(self, self.exp_pkt, [self.dev_port10])
        finally:
            print('----------------------------------------------------------')

        print("Sending packet port 11 -[ACL]-> port 10 (192.168.0.1"
              "-[ACL]-> 172.16.10.1 [id = 105])")

    def ingressV4AclTableTest(self):
        '''
        Verify both port/lag as in-port
        field with switch b-point to Ingress
        ipv4 ACL table entry with dst-ip match
        '''
        print("ingressV4AclTableTest")

        table_stage_ingress = SAI_ACL_STAGE_INGRESS
        entry_priority = 1
        ip_dst = "172.16.10.1"
        ip_dst_mask = "255.255.255.0"

        table_bind_points = [SAI_ACL_BIND_POINT_TYPE_SWITCH]
        table_bind_point_type_list = sai_thrift_s32_list_t(
            count=len(table_bind_points), int32list=table_bind_points)

        acl_ingress_table_id = sai_thrift_create_acl_table(
            self.client,
            acl_stage=table_stage_ingress,
            acl_bind_point_type_list=table_bind_point_type_list,
            field_src_ip=True,
            field_in_port=True)
        self.assertNotEqual(acl_ingress_table_id, 0)

        dst_ip_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(ip4=ip_dst),
            mask=sai_thrift_acl_field_data_mask_t(ip4=ip_dst_mask))
        in_port_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(oid=self.port11))

        packet_action = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                s32=SAI_PACKET_ACTION_DROP))

        acl_ingress_entry_id = sai_thrift_create_acl_entry(
            self.client,
            table_id=acl_ingress_table_id,
            priority=entry_priority,
            field_dst_ip=dst_ip_t,
            field_in_port=in_port_t,
            action_packet_action=packet_action)
        self.assertNotEqual(acl_ingress_entry_id, 0)

        # create ACL counter
        acl_counter_ingress = sai_thrift_create_acl_counter(
            self.client, table_id=acl_ingress_table_id)
        # attach ACL counter to ACL entry
        action_counter_ingress = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=acl_counter_ingress),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, acl_ingress_entry_id,
            action_counter=action_counter_ingress)
        sai_thrift_set_switch_attribute(
            self.client, ingress_acl=acl_ingress_table_id)

        try:
            print('#### ACL \'DROP, src ip 192.168.100.1/255.255.255.0, SPORT'
                  ' 1000, in_port port 11 \' Applied ####')
            print('#### Sending      ', ROUTER_MAC, '| 00:22:22:22:22:22 | '
                  '172.16.10.1 | 192.168.100.100 | SPORT 1000 | @ port 11')
            send_packet(self, self.dev_port11, self.pkt)
            print('#### NOT Expecting 00:11:22:33:44:55 |', ROUTER_MAC, '| '
                  '172.16.10.1 | 192.168.100.100 | SPORT 1000 | @ port 10')
            verify_no_other_packets(self, timeout=1)

            time.sleep(2)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter_ingress, packets=True)
            self.assertEqual(packets['packets'], 1)

            print('----------------------------------------------------------'
                  '------------------------------------')

            print('#### Sending  ', ROUTER_MAC, '| 00:22:22:22:22:22 | '
                  '172.16.10.1 | 192.168.100.100 | SPORT 1000 | @ port 12')
            send_packet(self, self.dev_port12, self.pkt)
            print('#### Expecting 00:11:22:33:44:55 |', ROUTER_MAC, '| '
                  '172.16.10.1 | 192.168.100.100 | SPORT 1000 | @ port 10')
            verify_packets(self, self.exp_pkt, [self.dev_port10])

            time.sleep(2)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter_ingress, packets=True)
            self.assertEqual(packets['packets'], 1)

        finally:
            sai_thrift_set_switch_attribute(self.client, ingress_acl=0)
            # cleanup ACL
            action_counter_ingress = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=0),
                enable=True)
            sai_thrift_set_acl_entry_attribute(
                self.client, acl_ingress_entry_id,
                action_counter=action_counter_ingress)
            sai_thrift_set_acl_counter_attribute(
                self.client, acl_counter_ingress, packets=None)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter_ingress, packets=True)
            self.assertEqual(packets['packets'], 0)
            sai_thrift_remove_acl_counter(self.client, acl_counter_ingress)

            sai_thrift_remove_acl_entry(self.client, acl_ingress_entry_id)
            sai_thrift_remove_acl_table(self.client, acl_ingress_table_id)

    def egressAclTableTest(self):
        '''
        Verify both port/lag as out-port
        field with switch b-point to egress
        ipv4 ACL table entry with dst-ip match
        '''
        print("egressV4AclTableTest")

        table_stage_egress = SAI_ACL_STAGE_EGRESS
        entry_priority = 1
        ip_dst = "172.16.10.1"
        ip_dst_mask = "255.255.255.0"

        table_bind_points = [SAI_ACL_BIND_POINT_TYPE_SWITCH]
        table_bind_point_type_list = sai_thrift_s32_list_t(
            count=len(table_bind_points), int32list=table_bind_points)

        acl_egress_table_id = sai_thrift_create_acl_table(
            self.client,
            acl_stage=table_stage_egress,
            acl_bind_point_type_list=table_bind_point_type_list,
            field_dst_ip=True)
        self.assertNotEqual(acl_egress_table_id, 0)

        dst_ip_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(ip4=ip_dst),
            mask=sai_thrift_acl_field_data_mask_t(ip4=ip_dst_mask))

        acl_egress_entry_id = sai_thrift_create_acl_entry(
            self.client,
            table_id=acl_egress_table_id,
            priority=entry_priority,
            field_dst_ip=dst_ip_t,
            action_packet_action=packet_action)
        self.assertNotEqual(acl_egress_entry_id, 0)

        # create ACL counter
        acl_counter_egress = sai_thrift_create_acl_counter(
            self.client, table_id=acl_egress_table_id)
        # attach ACL counter to ACL entry
        action_counter_egress = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=acl_counter_egress),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, acl_egress_entry_id,
            action_counter=action_counter_egress)

        # todo
        sai_thrift_set_router_interface_attribute(
            self.client, self.rif_id2, egress_acl=acl_egress_table_id)

        try:
            print('#### ACL \'DROP, src ip 192.168.100.1/255.255.255.0, SPORT'
                  ' 1000, in_ports[ptf_intf_1,2]\' Applied ####')
            print('#### Sending      ', ROUTER_MAC, '| 00:22:22:22:22:22 | '
                  '172.16.10.1 | 192.168.100.100 | SPORT 1000 | @ ptf_intf 1')
            send_packet(self, self.dev_port11, self.pkt)
            print('#### NOT Expecting 00:11:22:33:44:55 |', ROUTER_MAC, '| '
                  '172.16.10.1 | 192.168.100.100 | SPORT 1000 | @ ptf_intf 0')
            verify_no_other_packets(self, timeout=1)

            time.sleep(2)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter_egress, packets=True)
            self.assertEqual(packets['packets'], 1)

        finally:
            # cleanup ACL
            action_counter_egress = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=0),
                enable=True)
            sai_thrift_set_acl_entry_attribute(
                self.client, acl_egress_entry_id,
                action_counter=action_counter_egress)
            sai_thrift_set_acl_counter_attribute(
                self.client, acl_counter_egress, packets=None)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter_egress, packets=True)
            self.assertEqual(packets['packets'], 0)
            sai_thrift_remove_acl_counter(self.client, acl_counter_egress)

            sai_thrift_remove_acl_entry(self.client, acl_egress_entry_id)
            sai_thrift_remove_acl_table(self.client, acl_egress_table_id)

    def runTest(self):
        print("Testing DstIpAclTest")
        self.basicV4TrafficTest()
        self.ingressV4AclTableTest()
        #  self.egressV4AclTableTest()  #todo

    def tearDown(self):
        sai_thrift_remove_route_entry(self.client, self.route_entry)
        sai_thrift_remove_next_hop(self.client, self.nhop)
        sai_thrift_remove_neighbor_entry(self.client, self.nbr_entry)
        super(DstIpAclTest, self).tearDown()


@group('acl2')
class MACSrcAclTest(SaiHelper):
    """
    Verify matching on src mac address field
    """

    def setUp(self):
        super(MACSrcAclTest, self).setUp()

        rif_id1 = self.port10_rif
        self.rif_id2 = self.port11_rif

        ip_addr_subnet = '172.16.10.0'
        ip_addr = '172.16.10.1'
        dmac = '00:11:22:33:44:55'
        self.mac_src = '00:22:22:22:22:22'
        ip_addr_src = '192.168.0.1'

        print("Create neighbor with %s ip address, %d router interface"
              " id and %s destination mac" % (
                  ip_addr, rif_id1, dmac))
        self.nbr_entry = sai_thrift_neighbor_entry_t(
            rif_id=rif_id1,
            ip_address=sai_ipaddress(ip_addr))
        sai_thrift_create_neighbor_entry(
            self.client, self.nbr_entry, dst_mac_address=dmac)

        print("Create nhop with %s ip address and %d router"
              " interface id" % (ip_addr, rif_id1))
        self.nhop = sai_thrift_create_next_hop(
            self.client,
            ip=sai_ipaddress(ip_addr),
            router_interface_id=rif_id1,
            type=SAI_NEXT_HOP_TYPE_IP)

        print("Create route with %s ip prefix and %d router"
              " interface id" % (ip_addr_subnet, rif_id1))
        self.route_entry = sai_thrift_route_entry_t(
            vr_id=self.default_vrf, destination=sai_ipprefix(
                ip_addr_subnet))
        sai_thrift_create_route_entry(self.client, self.route_entry,
                                      next_hop_id=rif_id1)

        self.pkt = simple_tcp_packet(eth_dst=ROUTER_MAC,
                                     eth_src=self.mac_src,
                                     ip_dst=ip_addr,
                                     ip_src=ip_addr_src,
                                     ip_id=105,
                                     ip_ttl=64)
        self.exp_pkt = simple_tcp_packet(eth_dst=dmac,
                                         eth_src=ROUTER_MAC,
                                         ip_dst=ip_addr,
                                         ip_src=ip_addr_src,
                                         ip_id=105,
                                         ip_ttl=63)

    def basicMacTrafficTest(self):
        '''
        Verify mac traffic test before
        applying ingress mac ACl table entry.
        '''
        print("basicMacTrafficTest")

        print('--------------------------------------------------------------')
        print("Sending packet port 11 -> port 10 (192.168.0.1 --->"
              " 172.16.10.1 [id = 105])")

        try:
            print('#### NO ACL Applied ####')
            print('#### Sending  ', ROUTER_MAC, '| 00:22:22:22:22:22 | '
                  '172.16.10.1 | 192.168.100.1 | @ port 11 ')
            send_packet(self, self.dev_port11, self.pkt)
            print('#### Expecting 00:11:22:33:44:55 |', ROUTER_MAC, '| '
                  '172.16.10.1 | 192.168.100.1 | @ port 10 ')
            verify_packets(self, self.exp_pkt, [self.dev_port10])
        finally:
            print('----------------------------------------------------------')

            print("Sending packet port 11 -[ACL]-> port 10 (192.168.0.1-"
                  "[ACL]-> 172.16.10.1 [id = 105])")
            # setup ACL to block based on Source MAC

    def ingressMacAclTableTest(self):
        '''
        Verify both port/lag as in-port
        field with switch b-point to Ingress
        mac ACL table entry with src-mac match
        '''
        print("ingressMacAclTableTest")

        table_stage_ingress = SAI_ACL_STAGE_INGRESS
        entry_priority = 1
        mac_src_mask = 'ff:ff:ff:ff:ff:ff'

        table_bind_points = [SAI_ACL_BIND_POINT_TYPE_SWITCH]
        table_bind_point_type_list = sai_thrift_s32_list_t(
            count=len(table_bind_points), int32list=table_bind_points)

        acl_ingress_table_id = sai_thrift_create_acl_table(
            self.client,
            acl_stage=table_stage_ingress,
            acl_bind_point_type_list=table_bind_point_type_list,
            field_src_mac=True,
            field_in_port=True)
        self.assertNotEqual(acl_ingress_table_id, 0)

        src_mac_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(mac=self.mac_src),
            mask=sai_thrift_acl_field_data_mask_t(mac=mac_src_mask))
        in_port_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(oid=self.port11))

        packet_action = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                s32=SAI_PACKET_ACTION_DROP))

        acl_ingress_entry_id = sai_thrift_create_acl_entry(
            self.client,
            table_id=acl_ingress_table_id,
            priority=entry_priority,
            field_src_mac=src_mac_t,
            field_in_port=in_port_t,
            action_packet_action=packet_action)
        self.assertNotEqual(acl_ingress_entry_id, 0)

        # create ACL counter
        acl_counter_ingress = sai_thrift_create_acl_counter(
            self.client, table_id=acl_ingress_table_id)
        # attach ACL counter to ACL entry
        action_counter_ingress = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=acl_counter_ingress),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, acl_ingress_entry_id,
            action_counter=action_counter_ingress)
        sai_thrift_set_switch_attribute(
            self.client, ingress_acl=acl_ingress_table_id)

        try:
            print('#### ACL \'DROP, src mac 00:22:22:22:22:22, '
                  'in_port port 11\' Applied ####')
            print('#### Sending      ', ROUTER_MAC, '| 00:22:22:22:22:22 | '
                  '172.16.10.1 | 192.168.0.1 | @ port 11 ')
            # send the same packet
            send_packet(self, self.dev_port11, self.pkt)
            # ensure packet is dropped
            # check for absence of packet here!
            print('#### NOT Expecting 00:11:22:33:44:55 |', ROUTER_MAC,
                  '| 172.16.10.1 | 192.168.0.1 | @ port 10')
            verify_no_other_packets(self, timeout=2)

            time.sleep(2)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter_ingress, packets=True)
            self.assertEqual(packets['packets'], 1)

            print('----------------------------------------------------------')

            print('#### Sending  ', ROUTER_MAC, '| 00:22:22:22:22:22 | '
                  '172.16.10.1 | 192.168.100.1 | @ port 12 ')
            send_packet(self, self.dev_port12, self.pkt)
            print('#### Expecting 00:11:22:33:44:55 |', ROUTER_MAC, '| '
                  '172.16.10.1 | 192.168.100.1 | @ port 10 ')
            verify_packets(self, self.exp_pkt, [self.dev_port10])

            time.sleep(2)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter_ingress, packets=True)
            self.assertEqual(packets['packets'], 1)

        finally:
            sai_thrift_set_switch_attribute(self.client, ingress_acl=0)
            # cleanup ACL
            action_counter_ingress = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=0),
                enable=True)
            sai_thrift_set_acl_entry_attribute(
                self.client, acl_ingress_entry_id,
                action_counter=action_counter_ingress)
            sai_thrift_set_acl_counter_attribute(
                self.client, acl_counter_ingress, packets=None)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter_ingress, packets=True)
            self.assertEqual(packets['packets'], 0)
            sai_thrift_remove_acl_counter(self.client, acl_counter_ingress)

            sai_thrift_remove_acl_entry(self.client, acl_ingress_entry_id)
            sai_thrift_remove_acl_table(self.client, acl_ingress_table_id)

    def egressMacAclTableTest(self):
        '''
        Verify both port/lag as out-port
        field with switch b-point to Egress
        mac ACL table entry with src-mac match
        '''
        print("egressMacAclTableTest")

        table_stage_egress = SAI_ACL_STAGE_EGRESS
        entry_priority = 1
        mac_src_mask = 'ff:ff:ff:ff:ff:ff'

        table_bind_points = [SAI_ACL_BIND_POINT_TYPE_SWITCH]
        table_bind_point_type_list = sai_thrift_s32_list_t(
            count=len(table_bind_points), int32list=table_bind_points)

        acl_egress_table_id = sai_thrift_create_acl_table(
            self.client,
            acl_stage=table_stage_egress,
            acl_bind_point_type_list=table_bind_point_type_list,
            field_src_mac=True)
        self.assertNotEqual(acl_egress_table_id, 0)

        src_mac_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(mac=self.mac_src),
            mask=sai_thrift_acl_field_data_mask_t(mac=mac_src_mask))

        acl_egress_entry_id = sai_thrift_create_acl_entry(
            self.client,
            table_id=acl_egress_table_id,
            priority=entry_priority,
            field_src_mac=src_mac_t,
            action_packet_action=packet_action)
        self.assertNotEqual(acl_egress_entry_id, 0)

        # create ACL counter
        acl_counter_egress = sai_thrift_create_acl_counter(
            self.client, table_id=acl_egress_table_id)
        # attach ACL counter to ACL entry
        action_counter_egress = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=acl_counter_egress),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, acl_egress_entry_id,
            action_counter=action_counter_egress)

        # bind this ACL table to rif_id2s object id
        sai_thrift_set_router_interface_attribute(
            self.client, self.rif_id2, egress_acl=acl_egress_table_id)

        try:
            print('#### ACL \'DROP, src mac 00:22:22:22:22:22, '
                  'in_ports[ptf_intf_1,2]\' Applied ####')
            print('#### Sending      ', ROUTER_MAC, '| 00:22:22:22:22:22 | '
                  '172.16.10.1 | 192.168.0.1 | @ ptf_intf 2')
            # send the same packet
            send_packet(self, self.dev_port11, pkt)
            # ensure packet is dropped
            # check for absence of packet here!
            print('#### NOT Expecting 00:11:22:33:44:55 |', ROUTER_MAC,
                  '| 172.16.10.1 | 192.168.0.1 | @ ptf_intf 1')
            verify_no_other_packets(self, timeout=2)

            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter_egress, packets=True)
            self.assertEqual(packets['packets'], 1)

        finally:
            # cleanup ACL
            action_counter_egress = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=0),
                enable=True)
            sai_thrift_set_acl_entry_attribute(
                self.client, acl_egress_entry_id,
                action_counter=action_counter_egress)
            sai_thrift_set_acl_counter_attribute(
                self.client, acl_counter_egress, packets=None)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter_egress, packets=True)
            self.assertEqual(packets['packets'], 0)
            sai_thrift_remove_acl_counter(self.client, acl_counter_egress)

            # cleanup ACL
            sai_thrift_remove_acl_entry(self.client, acl_egress_entry_id)
            sai_thrift_remove_acl_table(self.client, acl_egress_table_id)

    def runTest(self):
        print("Testing MACSrcAclTest")
        self.basicMacTrafficTest()
        self.ingressMacAclTableTest()
        #  self.egressMacAclTableTest()  #todo

    def tearDown(self):
        sai_thrift_remove_route_entry(self.client, self.route_entry)
        sai_thrift_remove_next_hop(self.client, self.nhop)
        sai_thrift_remove_neighbor_entry(self.client, self.nbr_entry)
        super(MACSrcAclTest, self).tearDown()


@group('acl2')
class L3L4PortTest(SaiHelper):
    """
    Verify matching on l4_dst_port and l4_src_port fields
    """

    def setUp(self):
        super(L3L4PortTest, self).setUp()
        self.l4_dst_port = 1000
        self.l4_src_port = 500

        rif_id1 = self.port10_rif
        self.rif_id2 = self.port11_rif

        ip_addr_subnet = '172.16.10.0'
        ip_addr = '172.16.10.1'
        dmac = '00:11:22:33:44:55'
        mac_src = '00:22:22:22:22:22'
        ip_addr_src = '192.168.100.100'

        print("Create neighbor with %s ip address, %d router interface"
              " id and %s destination mac" % (
                  ip_addr, rif_id1, dmac))
        self.nbr_entry = sai_thrift_neighbor_entry_t(
            rif_id=rif_id1,
            ip_address=sai_ipaddress(ip_addr))
        sai_thrift_create_neighbor_entry(
            self.client, self.nbr_entry, dst_mac_address=dmac)

        print("Create nhop with %s ip address and %d router"
              " interface id" % (ip_addr, rif_id1))
        self.nhop = sai_thrift_create_next_hop(
            self.client,
            ip=sai_ipaddress(ip_addr),
            router_interface_id=rif_id1,
            type=SAI_NEXT_HOP_TYPE_IP)

        print("Create route with %s ip prefix and %d router"
              " interface id" % (ip_addr_subnet, rif_id1))
        self.route_entry = sai_thrift_route_entry_t(
            vr_id=self.default_vrf, destination=sai_ipprefix(
                ip_addr_subnet))
        sai_thrift_create_route_entry(self.client, self.route_entry,
                                      next_hop_id=rif_id1)

        self.pkt = simple_tcp_packet(eth_dst=ROUTER_MAC,
                                     eth_src=mac_src,
                                     ip_dst=ip_addr,
                                     ip_src=ip_addr_src,
                                     tcp_sport=self.l4_src_port,
                                     tcp_dport=self.l4_dst_port,
                                     ip_id=105,
                                     ip_ttl=64)
        self.exp_pkt = simple_tcp_packet(eth_dst=dmac,
                                         eth_src=ROUTER_MAC,
                                         ip_dst=ip_addr,
                                         ip_src=ip_addr_src,
                                         tcp_sport=self.l4_src_port,
                                         tcp_dport=self.l4_dst_port,
                                         ip_id=105,
                                         ip_ttl=63)

    def basicV4TrafficTest(self):
        '''
        Verify v4 L4 port traffic test before
        applying ingress ipv4 ACl table entry.
        '''
        print("basicV4TrafficTest")

        print("Testing L4 src/dest port ACL filter")
        print('--------------------------------------------------------------'
              '--------------------------------')
        print("Sending packet port 11 -> port 10 (192.168.100.100 --->"
              " 172.16.10.1 [id = 105])")

        try:
            print('#### NO ACL Applied ####')
            print('#### Sending  ', ROUTER_MAC, '| 00:22:22:22:22:22 | '
                  '172.16.10.1 | 192.168.100.100 | DP 1000 SP 500 | @ port 11')
            send_packet(self, self.dev_port11, self.pkt)
            print('#### Expecting 00:11:22:33:44:55 |', ROUTER_MAC, '| '
                  '172.16.10.1 | 192.168.100.100 | DP 1000 SP 500 | @ port 10')
            verify_packets(self, self.exp_pkt, [self.dev_port10])
        finally:
            print('----------------------------------------------------------'
                  '------------------------------------')

        print("Sending packet port 11 -[acl]-> port 10 (192.168.0.1"
              "-[a]cl]-> 172.16.10.1 [id = 105])")

    def ingressV4AclTableTest(self):
        '''
        Verify both port/lag as in-port
        field with switch b-point to Ingress
        ipv4 ACL table entry with L4 port match
        '''
        print("ingressV4AclTableTest")

        table_stage_ingress = SAI_ACL_STAGE_INGRESS
        entry_priority = 1

        ip_src = "192.168.100.1"
        ip_src_mask = "255.255.255.0"

        table_bind_points = [SAI_ACL_BIND_POINT_TYPE_ROUTER_INTF]
        table_bind_point_type_list = sai_thrift_s32_list_t(
            count=len(table_bind_points), int32list=table_bind_points)

        acl_ingress_table_id = sai_thrift_create_acl_table(
            self.client,
            acl_stage=table_stage_ingress,
            acl_bind_point_type_list=table_bind_point_type_list,
            field_src_ip=True,
            field_in_port=True)
        self.assertNotEqual(acl_ingress_table_id, 0)

        src_ip_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(ip4=ip_src),
            mask=sai_thrift_acl_field_data_mask_t(ip4=ip_src_mask))

        l4_dst_port_mask = 32759
        l4_dst_port_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(u16=self.l4_dst_port),
            mask=sai_thrift_acl_field_data_mask_t(u16=l4_dst_port_mask))
        l4_src_port_mask = 32759
        l4_src_port_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(u16=self.l4_src_port),
            mask=sai_thrift_acl_field_data_mask_t(u16=l4_src_port_mask))
        in_port_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(oid=self.port11))

        packet_action = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                s32=SAI_PACKET_ACTION_DROP))

        acl_ingress_entry_id = sai_thrift_create_acl_entry(
            self.client,
            table_id=acl_ingress_table_id,
            priority=entry_priority,
            field_src_ip=src_ip_t,
            field_in_port=in_port_t,
            action_packet_action=packet_action,
            field_l4_dst_port=l4_dst_port_t,
            field_l4_src_port=l4_src_port_t)
        self.assertNotEqual(acl_ingress_entry_id, 0)

        #  ACL counter
        acl_counter_ingress = sai_thrift_create_acl_counter(
            self.client, table_id=acl_ingress_table_id)

        #  attach ACL counter to ACL entry
        action_counter_ingress = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=acl_counter_ingress),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, acl_ingress_entry_id,
            action_counter=action_counter_ingress)
        sai_thrift_set_switch_attribute(
            self.client, ingress_acl=acl_ingress_table_id)

        try:
            print('#### ACL \'DROP, src ip 192.168.100.1/255.255.255.0, '
                  ' DP 1000 SP 500, in_port port 11 \' Applied ####')
            print('#### Sending      ', ROUTER_MAC, '| 00:22:22:22:22:22 | '
                  '172.16.10.1 | 192.168.100.100 | DP 1000 SP 500 | @ port 11')
            # send the same packet
            send_packet(self, self.dev_port11, self.pkt)
            # ensure packet is dropped
            # check for absence of packet here!
            print('#### NOT Expecting 00:11:22:33:44:55 |', ROUTER_MAC, '| '
                  '172.16.10.1 | 192.168.100.100 | SPORT 1000 | @ port 10')
            verify_no_other_packets(self, timeout=1)

            time.sleep(2)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter_ingress, packets=True)
            self.assertEqual(packets['packets'], 1)

            print('----------------------------------------------------------')

            print('#### Sending  ', ROUTER_MAC, '| 00:22:22:22:22:22 | '
                  '172.16.10.1 | 192.168.100.100 | DP 1000 SP 500 | @ port 12')
            send_packet(self, self.dev_port12, self.pkt)
            print('#### Expecting 00:11:22:33:44:55 |', ROUTER_MAC, '| '
                  '172.16.10.1 | 192.168.100.100 | DP 1000 SP 500 | @ port 10')
            verify_packets(self, self.exp_pkt, [self.dev_port10])

            time.sleep(2)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter_ingress, packets=True)
            self.assertEqual(packets['packets'], 1)

        finally:
            sai_thrift_set_switch_attribute(self.client, ingress_acl=0)
            # cleanup ACL
            action_counter_ingress = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=0),
                enable=True)
            sai_thrift_set_acl_entry_attribute(
                self.client, acl_ingress_entry_id,
                action_counter=action_counter_ingress)
            sai_thrift_set_acl_counter_attribute(
                self.client, acl_counter_ingress, packets=None)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter_ingress, packets=True)
            self.assertEqual(packets['packets'], 0)
            sai_thrift_remove_acl_counter(self.client, acl_counter_ingress)

            sai_thrift_remove_acl_entry(self.client, acl_ingress_entry_id)
            sai_thrift_remove_acl_table(self.client, acl_ingress_table_id)

    def egressV4AclTableTest(self):
        '''
        Verify both port/lag as out-port
        field with switch b-point to egress
        ipv4 ACL table entry with L4 port match
        '''
        print("egressV4AclTableTest")

        table_stage_egress = SAI_ACL_STAGE_EGRESS
        entry_priority = 1

        ip_src = "192.168.100.1"
        ip_src_mask = "255.255.255.0"

        table_bind_points = [SAI_ACL_BIND_POINT_TYPE_SWITCH]
        table_bind_point_type_list = sai_thrift_s32_list_t(
            count=len(table_bind_points), int32list=table_bind_points)

        acl_egress_table_id = sai_thrift_create_acl_table(
            self.client,
            acl_stage=table_stage_egress,
            acl_bind_point_type_list=table_bind_point_type_list,
            field_src_ip=True)
        self.assertNotEqual(acl_egress_table_id, 0)

        src_ip_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(ip4=ip_src),
            mask=sai_thrift_acl_field_data_mask_t(ip4=ip_src_mask))

        acl_egress_entry_id = sai_thrift_create_acl_entry(
            self.client,
            table_id=acl_egress_table_id,
            priority=entry_priority,
            field_src_ip=src_ip_t,
            action_packet_action=packet_action,
            field_l4_dst_port=l4_dst_port_t,
            field_l4_src_port=l4_src_port_t)
        self.assertNotEqual(acl_egress_entry_id, 0)

        # create ACL counter
        acl_counter_egress = sai_thrift_create_acl_counter(
            self.client, table_id=acl_egress_table_id)
        # attach ACL counter to ACL entry
        action_counter_egress = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=acl_counter_egress),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, acl_egress_entry_id,
            action_counter=action_counter_egress)

        # bind this ACL table to rif_id2s object id
        sai_thrift_set_router_interface_attribute(
            self.client, self.rif_id2, egress_acl=acl_egress_table_id)

        try:
            print('#### ACL \'DROP, src mac 00:22:22:22:22:22, '
                  'in_ports[ptf_intf_1,2]\' Applied ####')
            print('#### Sending      ', ROUTER_MAC, '| 00:22:22:22:22:22 | '
                  '172.16.10.1 | 192.168.0.1 | @ ptf_intf 2')
            # send the same packet
            send_packet(self, self.dev_port11, self.pkt)
            # ensure packet is dropped
            # check for absence of packet here!
            print('#### NOT Expecting 00:11:22:33:44:55 |', ROUTER_MAC,
                  '| 172.16.10.1 | 192.168.0.1 | @ ptf_intf 1')
            verify_no_other_packets(self, timeout=2)

            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter_egress, packets=True)
            self.assertEqual(packets['packets'], 1)

        finally:
            # cleanup ACL
            action_counter_egress = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=0),
                enable=True)
            sai_thrift_set_acl_entry_attribute(
                self.client, acl_egress_entry_id,
                action_counter=action_counter_egress)
            sai_thrift_set_acl_counter_attribute(
                self.client, acl_counter_egress, packets=None)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter_egress, packets=True)
            self.assertEqual(packets['packets'], 0)
            sai_thrift_remove_acl_counter(self.client, acl_counter_egress)

            sai_thrift_remove_acl_entry(self.client, acl_egress_entry_id)
            sai_thrift_remove_acl_table(self.client, acl_egress_table_id)

    def runTest(self):
        print("Testing L3L4PortTest")
        self.basicV4TrafficTest()
        self.ingressV4AclTableTest()
        #  self.egressV4AclTableTest()  #todo

    def tearDown(self):
        sai_thrift_remove_route_entry(self.client, self.route_entry)
        sai_thrift_remove_next_hop(self.client, self.nhop)
        sai_thrift_remove_neighbor_entry(self.client, self.nbr_entry)
        super(L3L4PortTest, self).tearDown()


@group('acl2')
class L3AclRangeTest(SaiHelper):
    """
    Verify matching on ACL range
    """

    def setUp(self):
        super(L3AclRangeTest, self).setUp()

        u_l4_port = 800
        t_l4_port = 1000

        rif_id1 = self.port10_rif
        self.rif_id2 = self.port11_rif

        ip_addr_subnet = '172.16.10.0'
        ip_addr = '172.16.10.1'
        dmac = '00:11:22:33:44:55'
        mac_src = '00:22:22:22:22:22'
        ip_addr_src = '192.168.100.100'

        print("Create neighbor with %s ip address, %d router interface"
              " id and %s destination mac" % (
                  ip_addr, rif_id1, dmac))
        self.nbr_entry = sai_thrift_neighbor_entry_t(
            rif_id=rif_id1,
            ip_address=sai_ipaddress(ip_addr))
        sai_thrift_create_neighbor_entry(
            self.client, self.nbr_entry, dst_mac_address=dmac)

        print("Create nhop with %s ip address and %d router"
              " interface id" % (ip_addr, rif_id1))
        self.nhop = sai_thrift_create_next_hop(
            self.client,
            ip=sai_ipaddress(ip_addr),
            router_interface_id=rif_id1,
            type=SAI_NEXT_HOP_TYPE_IP)

        print("Create route with %s ip prefix and %d router "
              "interface id" % (ip_addr_subnet, rif_id1))
        self.route_entry = sai_thrift_route_entry_t(
            vr_id=self.default_vrf, destination=sai_ipprefix(
                ip_addr_subnet))
        sai_thrift_create_route_entry(self.client, self.route_entry,
                                      next_hop_id=rif_id1)

        self.tcp_pkt = simple_tcp_packet(eth_dst=ROUTER_MAC,
                                         eth_src=mac_src,
                                         ip_dst=ip_addr,
                                         ip_src=ip_addr_src,
                                         tcp_dport=t_l4_port,
                                         ip_id=105,
                                         ip_ttl=64)
        self.tcp_e_pkt = simple_tcp_packet(eth_dst=dmac,
                                           eth_src=ROUTER_MAC,
                                           ip_dst=ip_addr,
                                           ip_src=ip_addr_src,
                                           tcp_dport=t_l4_port,
                                           ip_id=105,
                                           ip_ttl=63)

        self.udp_pkt = simple_udp_packet(eth_dst=ROUTER_MAC,
                                         eth_src=mac_src,
                                         ip_dst=ip_addr,
                                         udp_dport=u_l4_port,
                                         ip_src=ip_addr_src,
                                         ip_id=105,
                                         ip_ttl=64)
        self.udp_e_pkt = simple_udp_packet(eth_dst=dmac,
                                           eth_src=ROUTER_MAC,
                                           ip_dst=ip_addr,
                                           ip_src=ip_addr_src,
                                           udp_dport=u_l4_port,
                                           ip_id=105,
                                           ip_ttl=63)

        self.table_stage_ingress = SAI_ACL_STAGE_INGRESS
        self.table_stage_egress = SAI_ACL_STAGE_EGRESS

        self.tcp_protocol = 0x06
        self.udp_protocol = 0x11

    def runTest(self):
        print("Testing L3AclRangeTest")

        self.routingTest()
        print("Tx TCP packet  "
              "[192.168.0.1-[ingress ACL]-> 172.16.10.1 [id = 105]]")
        self.aclTest(self.table_stage_ingress, self.tcp_protocol)
        print("Tx UDP packet  "
              "[192.168.0.1-[ingress ACL]-> 172.16.10.1 [id = 105]]")
        self.aclTest(self.table_stage_ingress, self.udp_protocol)

        # todo
        # print("Sending TCP packet ptf_intf 2 -[egress ACL]-> ptf_intf 1 "
        #      "(192.168.0.1-[egress ACL]-> 172.16.10.1 [id = 105])")
        # self.aclTest(self.table_stage_egress, self.tcp_protocol)
        # print("Sending UDP packet ptf_intf 2 -[egress ACL]-> ptf_intf 1 "
        #       "(192.168.0.1-[egress ACL]-> 172.16.10.1 [id = 105])")
        # self.aclTest(self.table_stage_egress, self.udp_protocol)

    def routingTest(self):
        """
        Verifies routing for TCP, UDP traffic
        """
        print('--------------------------------------------------------------')
        print("Sending TCP packet port 11 -> port 10 (192.168.100.100 "
              "---> 172.16.10.1 [id = 105])")
        print('#### NO ACL Applied ####')
        print('#### Sending  ', ROUTER_MAC, '| 00:22:22:22:22:22 | '
              '172.16.10.1 | 192.168.100.100 | DP 1000 | @ port 11 ')
        send_packet(self, self.dev_port11, self.tcp_pkt)
        print('#### Expecting 00:11:22:33:44:55 |', ROUTER_MAC, '| '
              '172.16.10.1 | 192.168.100.100 | DP 1000 | @ port 10 ')
        verify_packets(self, self.tcp_e_pkt, [self.dev_port10])
        print('----------------------------------------------------------')
        print("Sending UDP packet port 11 -> port 10 (192.168.100.100 "
              "---> 172.16.10.1 [id = 105])")
        print('#### NO ACL Applied ####')
        print('#### Sending  ', ROUTER_MAC, '| 00:22:22:22:22:22 | '
              '172.16.10.1 | 192.168.100.100 | DP 800 | @ port 11 ')
        send_packet(self, self.dev_port11, self.udp_pkt)
        print('#### Expecting 00:11:22:33:44:55 |', ROUTER_MAC, '| '
              '172.16.10.1 | 192.168.100.100 | DP 800 | @ port 10 ')
        verify_packets(self, self.udp_e_pkt, [self.dev_port10])
        print('----------------------------------------------------------')

    def aclTest(self, stage, protocol):
        """
        Verifies ingress or egress ACLs for range and TCP or UDP traffic

        Args:
            stage (int): specifies ingress or egress type of ACL
            protocol (int): specifies protocol field value
        """
        acl_range_type = sai_thrift_s32_list_t(count=0, int32list=[])

        if protocol == 0x06:
            pkt = self.tcp_pkt
            e_pkt = self.tcp_e_pkt
        elif protocol == 0x11:
            pkt = self.udp_pkt
            e_pkt = self.udp_e_pkt

        field_protocol = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(u8=protocol),
            mask=sai_thrift_acl_field_data_mask_t(u8=0x0F))
        in_port_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(oid=self.port11))

        entry_priority = 1

        table_bind_points = [SAI_ACL_BIND_POINT_TYPE_SWITCH]
        table_bind_point_type_list = sai_thrift_s32_list_t(
            count=len(table_bind_points), int32list=table_bind_points)

        acl_table = sai_thrift_create_acl_table(
            self.client,
            acl_stage=stage,
            acl_bind_point_type_list=table_bind_point_type_list,
            field_src_ip=True,
            field_ip_protocol=True,
            field_acl_range_type=acl_range_type)
        self.assertNotEqual(acl_table, 0)
        print("ACL ingress table 0x%lx" % (acl_table))

        packet_action = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                s32=SAI_PACKET_ACTION_DROP))

        u32range = sai_thrift_u32_range_t(min=500, max=1000)
        acl_range = sai_thrift_create_acl_range(
            self.client,
            type=SAI_ACL_RANGE_TYPE_L4_DST_PORT_RANGE,
            limit=u32range)
        range_list = [acl_range]
        print(" ACL range alloc 0x%lx" % (acl_range))

        range_list_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(
                objlist=sai_thrift_object_list_t(
                    count=len(range_list),
                    idlist=range_list)))

        acl_entry = sai_thrift_create_acl_entry(
            self.client,
            table_id=acl_table,
            priority=entry_priority,
            action_packet_action=packet_action,
            field_acl_range_type=range_list_t,
            field_in_port=in_port_t,
            field_ip_protocol=field_protocol)

        # create ACL counter
        acl_counter = sai_thrift_create_acl_counter(
            self.client, table_id=acl_table)
        # attach ACL counter to ACL entry
        action_counter = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=acl_counter),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, acl_entry,
            action_counter=action_counter)

        if stage == SAI_ACL_STAGE_EGRESS:
            # bind this ACL table to rif_id2s object id
            sai_thrift_set_router_interface_attribute(
                self.client, self.rif_id2, egress_acl=acl_table)
        else:
            sai_thrift_set_switch_attribute(self.client, ingress_acl=acl_table)

        try:
            print('#### ACL \'DROP, src ip 192.168.100.1/255.255.255.0, '
                  ' DP 500-1000, in_port port 11\' Applied ####')
            print('#### Sending      ', ROUTER_MAC, '| 00:22:22:22:22:22 | '
                  '172.16.10.1 | 192.168.100.100 | DP 500-1000 | @ port 11 ')
            # send the same packet
            send_packet(self, self.dev_port11, pkt)
            # ensure packet is dropped
            # check for absence of packet here!
            print('#### NOT Expecting 00:11:22:33:44:55 |', ROUTER_MAC, '| '
                  '172.16.10.1 | 192.168.100.100 | DP 500-1000 | @ port 10 ')
            verify_no_other_packets(self, timeout=1)

            time.sleep(2)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter, packets=True)
            self.assertEqual(packets['packets'], 1)

            print('----------------------------------------------------------')

            print('#### Sending  ', ROUTER_MAC, '| 00:22:22:22:22:22 | '
                  '172.16.10.1 | 192.168.100.100 | DP 500-1000 | @ port 12 ')
            # tx the same packet, should go through
            send_packet(self, self.dev_port12, pkt)
            print('#### Expecting 00:11:22:33:44:55 |', ROUTER_MAC, '| '
                  '172.16.10.1 | 192.168.100.100 | DP 500-1000 | @ port 10 ')
            verify_packets(self, e_pkt, [self.dev_port10])

            time.sleep(2)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter, packets=True)
            self.assertEqual(packets['packets'], 1)

            print('----------------------------------------------------------')

        finally:
            if stage == SAI_ACL_STAGE_EGRESS:
                sai_thrift_set_router_interface_attribute(
                    self.client, self.rif_id2, egress_acl=int(
                        SAI_NULL_OBJECT_ID))
            else:
                sai_thrift_set_switch_attribute(self.client, ingress_acl=0)

            # cleanup ACL
            action_counter = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=0),
                enable=True)
            sai_thrift_set_acl_entry_attribute(
                self.client, acl_entry,
                action_counter=action_counter)
            sai_thrift_set_acl_counter_attribute(
                self.client, acl_counter, packets=None)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter, packets=True)
            self.assertEqual(packets['packets'], 0)
            sai_thrift_remove_acl_counter(self.client, acl_counter)

            sai_thrift_remove_acl_entry(self.client, acl_entry)
            sai_thrift_remove_acl_range(self.client, acl_range)
            sai_thrift_remove_acl_table(self.client, acl_table)

    def tearDown(self):
        sai_thrift_remove_route_entry(self.client, self.route_entry)
        sai_thrift_remove_next_hop(self.client, self.nhop)
        sai_thrift_remove_neighbor_entry(self.client, self.nbr_entry)
        super(L3AclRangeTest, self).tearDown()


@group('acl2')
class AclTableTypeTest(SaiHelper):
    '''
    ACL Type class. This test creates tables with various match fields
    '''
    acl_range_type = sai_thrift_s32_list_t(count=0, int32list=[])

    def setUp(self):
        super(AclTableTypeTest, self).setUp()

        self.dmac = '00:11:22:33:44:55'
        self.src_mac = '00:22:22:22:22:22'
        self.ip_1 = '10.0.0.1'
        self.ip_2 = '10.10.10.2'

        self.port24_rif = sai_thrift_create_router_interface(
            self.client,
            type=SAI_ROUTER_INTERFACE_TYPE_PORT,
            virtual_router_id=self.default_vrf,
            port_id=self.port24)

        self.port25_rif = sai_thrift_create_router_interface(
            self.client,
            type=SAI_ROUTER_INTERFACE_TYPE_PORT,
            virtual_router_id=self.default_vrf,
            port_id=self.port25)

        self.nhop1 = sai_thrift_create_next_hop(
            self.client,
            ip=sai_ipaddress(self.ip_2),
            router_interface_id=self.port25_rif,
            type=SAI_NEXT_HOP_TYPE_IP)
        self.neighbor_entry1 = sai_thrift_neighbor_entry_t(
            rif_id=self.port25_rif, ip_address=sai_ipaddress(self.ip_2))
        sai_thrift_create_neighbor_entry(
            self.client, self.neighbor_entry1, dst_mac_address=self.dmac)

        self.route_entry0 = sai_thrift_route_entry_t(
            vr_id=self.default_vrf, destination=sai_ipprefix('10.0.0.1/32'))
        sai_thrift_create_route_entry(
            self.client, self.route_entry0, next_hop_id=self.nhop1)

        self.route_entry1 = sai_thrift_route_entry_t(
            vr_id=self.default_vrf,
            destination=sai_ipprefix(
                '1234:5678:9abc:def0:4422:1133:5577:99aa/128'))
        sai_thrift_create_route_entry(
            self.client, self.route_entry1, next_hop_id=self.nhop1)

        self.vlan_oid = sai_thrift_create_vlan(self.client, 100)
        mac_action = SAI_PACKET_ACTION_FORWARD

        self.port26_bp = sai_thrift_create_bridge_port(
            self.client,
            bridge_id=self.default_1q_bridge,
            port_id=self.port26,
            type=SAI_BRIDGE_PORT_TYPE_PORT,
            admin_state=True)

        self.vlan_member1 = sai_thrift_create_vlan_member(
            self.client,
            vlan_id=self.vlan_oid,
            bridge_port_id=self.port26_bp,
            vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_TAGGED)

        self.port27_bp = sai_thrift_create_bridge_port(
            self.client,
            bridge_id=self.default_1q_bridge,
            port_id=self.port27,
            type=SAI_BRIDGE_PORT_TYPE_PORT,
            admin_state=True)

        self.vlan_member2 = sai_thrift_create_vlan_member(
            self.client,
            vlan_id=self.vlan_oid,
            bridge_port_id=self.port27_bp,
            vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_TAGGED)

        self.fdb_entry1 = sai_thrift_fdb_entry_t(
            switch_id=self.switch_id,
            mac_address=self.src_mac,
            bv_id=self.vlan_oid)
        sai_thrift_create_fdb_entry(
            self.client,
            self.fdb_entry1,
            type=SAI_FDB_ENTRY_TYPE_STATIC,
            bridge_port_id=self.port26_bp,
            packet_action=mac_action)

        self.fdb_entry2 = sai_thrift_fdb_entry_t(
            switch_id=self.switch_id,
            mac_address=self.dmac,
            bv_id=self.vlan_oid)
        sai_thrift_create_fdb_entry(
            self.client,
            self.fdb_entry2,
            type=SAI_FDB_ENTRY_TYPE_STATIC,
            bridge_port_id=self.port27_bp,
            packet_action=mac_action)

    def runTest(self):
        print("Testing AclTableTypeTest")
        self.testIPv4Acl(
            self.port24, self.dev_port24, self.dev_port25)
        self.testIPv4Acl(
            self.port26, self.dev_port26, self.dev_port27)
        self.testIPv6Acl(
            self.port24, self.dev_port24, self.dev_port25)
        self.testIPv6Acl(
            self.port26, self.dev_port26, self.dev_port27)
        self.testIngressIPAclMirrorIn(
            self.port24, self.dev_port24, self.dev_port25)
        self.testIngressIPAclMirrorIn(
            self.port26, self.dev_port26, self.dev_port27)

    def tearDown(self):
        sai_thrift_remove_fdb_entry(self.client, self.fdb_entry1)
        sai_thrift_remove_fdb_entry(self.client, self.fdb_entry2)
        sai_thrift_remove_vlan_member(self.client, self.vlan_member1)
        sai_thrift_remove_vlan_member(self.client, self.vlan_member2)
        sai_thrift_remove_bridge_port(self.client, self.port26_bp)
        sai_thrift_remove_bridge_port(self.client, self.port27_bp)
        sai_thrift_remove_vlan(self.client, self.vlan_oid)

        sai_thrift_remove_route_entry(self.client, self.route_entry0)
        sai_thrift_remove_route_entry(self.client, self.route_entry1)
        sai_thrift_remove_next_hop(self.client, self.nhop1)
        sai_thrift_remove_neighbor_entry(self.client, self.neighbor_entry1)
        sai_thrift_remove_router_interface(self.client, self.port25_rif)
        sai_thrift_remove_router_interface(self.client, self.port24_rif)
        super(AclTableTypeTest, self).tearDown()

    def testIPv4Acl(self, in_port, tx_port, rx_port):
        """
        Verify various IPv4 field combinations for
        V4 user acl table allocation

        Args:
            in_port (int): specifies port object for in-port field
            tx_port (int): specifies tx port object for pkt-tx
            rx_port (int): specifies rx port object for pkt-rx
        """
        print("testIPv4Acl")

        if in_port == self.port24:
            pkt = simple_tcp_packet(eth_dst=ROUTER_MAC,
                                    eth_src=self.src_mac,
                                    ip_dst=self.ip_1,
                                    ip_ttl=64)
            e_pkt = simple_tcp_packet(eth_dst=self.dmac,
                                      eth_src=ROUTER_MAC,
                                      ip_dst=self.ip_1,
                                      ip_ttl=63)
        else:
            pkt = simple_tcp_packet(eth_dst=self.dmac,
                                    eth_src=self.src_mac,
                                    dl_vlan_enable=True,
                                    vlan_vid=100,
                                    ip_src=self.ip_2,
                                    ip_dst=self.ip_1,
                                    ip_id=102,
                                    ip_ttl=64)
            e_pkt = simple_tcp_packet(eth_dst=self.dmac,
                                      eth_src=self.src_mac,
                                      ip_dst=self.ip_1,
                                      ip_src=self.ip_2,
                                      ip_id=102,
                                      dl_vlan_enable=True,
                                      vlan_vid=100,
                                      ip_ttl=64)

        # verify packet forwarding without ACL
        print(" Tx packet from port A to port B --> forw")
        send_packet(self, tx_port, pkt)
        verify_packet(self, e_pkt, rx_port)

        #  ACL table
        table_stage = SAI_ACL_STAGE_INGRESS
        table_bind_points = [SAI_ACL_BIND_POINT_TYPE_SWITCH]
        table_bind_point_type_list = sai_thrift_s32_list_t(
            count=len(table_bind_points), int32list=table_bind_points)
        acl_table = sai_thrift_create_acl_table(
            self.client,
            acl_stage=table_stage,
            acl_bind_point_type_list=table_bind_point_type_list,
            field_src_ip=True,
            field_dst_ip=True,
            field_ip_protocol=True,
            field_dscp=True,
            field_l4_src_port=True,
            field_l4_dst_port=True,
            field_tcp_flags=True,
            field_acl_range_type=self.acl_range_type,
            field_icmp_code=True,
            field_icmp_type=True,
            field_outer_vlan_id=True,
            field_in_port=True)

        #  ACL table entry
        dst_ip_mask = '255.255.255.255'
        dst_ip_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(ip4=self.ip_1),
            mask=sai_thrift_acl_field_data_mask_t(ip4=dst_ip_mask))

        packet_action = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                s32=SAI_PACKET_ACTION_DROP))

        in_port_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(oid=in_port))
        acl_entry = sai_thrift_create_acl_entry(
            self.client,
            table_id=acl_table,
            priority=10,
            field_dst_ip=dst_ip_t,
            field_in_port=in_port_t,
            action_packet_action=packet_action)

        #  ACL counter
        acl_counter_ingress = sai_thrift_create_acl_counter(
            self.client, table_id=acl_table)
        # attach ACL counter to ACL entry
        action_counter_ingress = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=acl_counter_ingress),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, acl_entry,
            action_counter=action_counter_ingress)
        sai_thrift_set_switch_attribute(self.client, ingress_acl=acl_table)

        try:
            # verify packet dropped after ACL apply
            print(" Tx packet from port A to port B --> acl drop on port A ")
            send_packet(self, tx_port, pkt)
            verify_no_other_packets(self, timeout=2)

            time.sleep(2)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter_ingress, packets=True)
            self.assertEqual(packets['packets'], 1)

            if in_port == self.port24:
                print(" Tx packet from port C to port B --> forw")
                send_packet(self, self.dev_port10, pkt)
                verify_packet(self, e_pkt, rx_port)

                time.sleep(2)
                packets = sai_thrift_get_acl_counter_attribute(
                    self.client, acl_counter_ingress, packets=True)
                self.assertEqual(packets['packets'], 1)

        finally:
            sai_thrift_set_switch_attribute(self.client, ingress_acl=0)
            # cleanup ACL entry
            action_counter_ingress = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=0),
                enable=True)
            sai_thrift_set_acl_entry_attribute(
                self.client, acl_entry,
                action_counter=action_counter_ingress)
            sai_thrift_set_acl_counter_attribute(
                self.client, acl_counter_ingress, packets=None)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter_ingress, packets=True)
            self.assertEqual(packets['packets'], 0)
            sai_thrift_remove_acl_counter(self.client, acl_counter_ingress)

            sai_thrift_remove_acl_entry(self.client, acl_entry)
            sai_thrift_remove_acl_table(self.client, acl_table)

    def testIPv6Acl(self, in_port, tx_port, rx_port):
        """
        Verify various V6 field combinations for
        V6 user acl table allocation

        Args:
            in_port (int): specifies port object for in-port field
            tx_port (int): specifies tx port object for pkt-tx
            rx_port (int): specifies rx port object for pkt-rx
        """
        print("testIPv6Acl")

        if in_port == self.port24:
            pkt = simple_tcpv6_packet(
                eth_dst=ROUTER_MAC,
                ipv6_dst='1234:5678:9abc:def0:4422:1133:5577:99aa',
                ipv6_hlim=64)
            e_pkt = simple_tcpv6_packet(
                eth_dst=self.dmac,
                eth_src=ROUTER_MAC,
                ipv6_dst='1234:5678:9abc:def0:4422:1133:5577:99aa',
                ipv6_hlim=63)
        else:
            pkt = simple_tcpv6_packet(
                eth_dst=self.dmac,
                eth_src=self.src_mac,
                dl_vlan_enable=True,
                vlan_vid=100,
                ipv6_dst='1234:5678:9abc:def0:4422:1133:5577:99aa',
                ipv6_src='2000::1',
                ipv6_hlim=64)
            e_pkt = simple_tcpv6_packet(
                eth_dst=self.dmac,
                eth_src=self.src_mac,
                dl_vlan_enable=True,
                vlan_vid=100,
                ipv6_dst='1234:5678:9abc:def0:4422:1133:5577:99aa',
                ipv6_src='2000::1',
                ipv6_hlim=64)

        # verify packet forwarding without ACL
        print(" Tx v6 packet from port A to port B --> forw")
        send_packet(self, tx_port, pkt)
        verify_packet(self, e_pkt, rx_port)

        #  ACL table
        table_stage = SAI_ACL_STAGE_INGRESS
        table_bind_points = [SAI_ACL_BIND_POINT_TYPE_SWITCH]
        table_bind_point_type_list = sai_thrift_s32_list_t(
            count=len(table_bind_points), int32list=table_bind_points)

        acl_table = sai_thrift_create_acl_table(
            self.client,
            acl_stage=table_stage,
            acl_bind_point_type_list=table_bind_point_type_list,
            field_src_ipv6=True,
            field_dst_ipv6=True,
            field_ip_protocol=True,
            field_ipv6_next_header=True,
            field_dscp=True,
            field_l4_src_port=True,
            field_l4_dst_port=True,
            field_tcp_flags=True,
            field_acl_range_type=self.acl_range_type,
            field_icmpv6_code=True,
            field_icmpv6_type=True,
            field_outer_vlan_id=True,
            field_in_port=True)

        #  ACL table entry
        dst_ip = '1234:5678:9abc:def0:4422:1133:5577:99aa'
        dst_ip_mask = 'FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF'
        dst_ip_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(ip6=dst_ip),
            mask=sai_thrift_acl_field_data_mask_t(ip6=dst_ip_mask))

        packet_action = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                s32=SAI_PACKET_ACTION_DROP))

        in_port_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(oid=in_port))
        acl_entry = sai_thrift_create_acl_entry(
            self.client,
            table_id=acl_table,
            priority=10,
            field_dst_ipv6=dst_ip_t,
            field_in_port=in_port_t,
            action_packet_action=packet_action)

        # ACL counter
        acl_counter_ingress = sai_thrift_create_acl_counter(
            self.client, table_id=acl_table)
        # attach ACL counter to ACL entry
        action_counter_ingress = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=acl_counter_ingress),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, acl_entry,
            action_counter=action_counter_ingress)
        sai_thrift_set_switch_attribute(self.client, ingress_acl=acl_table)

        try:
            # verify packet dropped after ACL apply
            print(" Tx v6 packet from port A to port B --> acl drop on port A")
            send_packet(self, tx_port, pkt)
            verify_no_other_packets(self, timeout=2)

            time.sleep(2)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter_ingress, packets=True)
            self.assertEqual(packets['packets'], 1)

            if in_port == self.port24:
                print(" Tx v6 packet from port C to port B --> forw")
                send_packet(self, self.dev_port10, pkt)
                verify_packet(self, e_pkt, rx_port)

                time.sleep(2)
                packets = sai_thrift_get_acl_counter_attribute(
                    self.client, acl_counter_ingress, packets=True)
                self.assertEqual(packets['packets'], 1)

        finally:
            sai_thrift_set_switch_attribute(self.client, ingress_acl=0)
            # cleanup ACL entry
            action_counter_ingress = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=0),
                enable=True)
            sai_thrift_set_acl_entry_attribute(
                self.client, acl_entry,
                action_counter=action_counter_ingress)
            sai_thrift_set_acl_counter_attribute(
                self.client, acl_counter_ingress, packets=None)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter_ingress, packets=True)
            self.assertEqual(packets['packets'], 0)
            sai_thrift_remove_acl_counter(self.client, acl_counter_ingress)

            sai_thrift_remove_acl_entry(self.client, acl_entry)
            sai_thrift_remove_acl_table(self.client, acl_table)

    def testIngressIPAclMirrorIn(self, in_port, tx_port, rx_port):
        """
        Verify various field combinations for
        IP mirror acl table allocation

        Args:
            in_port (int): specifies port object for in-port field
            tx_port (int): specifies tx port object for pkt-tx
            rx_port (int): specifies rx port object for pkt-rx
        """
        print("testIngressIPAclMirrorIn  ")

        if in_port == self.port24:
            pkt = simple_tcpv6_packet(
                eth_dst=ROUTER_MAC,
                ipv6_dst='1234:5678:9abc:def0:4422:1133:5577:99aa',
                ipv6_hlim=64)
            e_pkt = simple_tcpv6_packet(
                eth_dst=self.dmac,
                eth_src=ROUTER_MAC,
                ipv6_dst='1234:5678:9abc:def0:4422:1133:5577:99aa',
                ipv6_hlim=63)
        else:
            pkt = simple_tcpv6_packet(
                eth_dst=self.dmac,
                eth_src=self.src_mac,
                dl_vlan_enable=True,
                vlan_vid=100,
                ipv6_dst='1234:5678:9abc:def0:4422:1133:5577:99aa',
                ipv6_src='2000::1',
                ipv6_hlim=64)
            e_pkt = simple_tcpv6_packet(
                eth_dst=self.dmac,
                eth_src=self.src_mac,
                dl_vlan_enable=True,
                vlan_vid=100,
                ipv6_dst='1234:5678:9abc:def0:4422:1133:5577:99aa',
                ipv6_src='2000::1',
                ipv6_hlim=64)

        #  verify packet forwarding without ACL
        print(" Tx v6 packet from port A to port B --> forw")
        send_packet(self, tx_port, pkt)
        verify_packet(self, e_pkt, rx_port)

        mirror_session = sai_thrift_create_mirror_session(
            self.client,
            monitor_port=self.port28,
            type=SAI_MIRROR_SESSION_TYPE_LOCAL)

        #  ACL table
        table_stage = SAI_ACL_STAGE_INGRESS
        table_bind_points = [SAI_ACL_BIND_POINT_TYPE_SWITCH]
        table_bind_point_type_list = sai_thrift_s32_list_t(
            count=len(table_bind_points), int32list=table_bind_points)

        actions = [SAI_ACL_ACTION_TYPE_MIRROR_INGRESS]
        action_type_list = sai_thrift_s32_list_t(
            count=len(actions), int32list=actions)
        acl_table = sai_thrift_create_acl_table(
            self.client,
            acl_stage=table_stage,
            acl_bind_point_type_list=table_bind_point_type_list,
            acl_action_type_list=action_type_list,
            field_src_ipv6=True,
            field_dst_ipv6=True,
            field_ip_protocol=True,
            field_ipv6_next_header=True,
            field_dscp=True,
            field_l4_src_port=True,
            field_l4_dst_port=True,
            field_tcp_flags=True,
            field_ether_type=True,
            field_acl_range_type=self.acl_range_type,
            field_icmpv6_code=True,
            field_icmpv6_type=True,
            field_outer_vlan_id=True,
            field_in_port=True)

        #  ACL table entry
        dst_ip = '1234:5678:9abc:def0:4422:1133:5577:99aa'
        dst_ip_mask = 'FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF'
        dst_ip_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(ip6=dst_ip),
            mask=sai_thrift_acl_field_data_mask_t(ip6=dst_ip_mask))

        mirror_session_list = sai_thrift_object_list_t(
            count=1, idlist=[mirror_session])
        mirror_action = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                objlist=mirror_session_list))

        in_port_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(oid=in_port))
        acl_entry = sai_thrift_create_acl_entry(
            self.client,
            table_id=acl_table,
            priority=10,
            field_dst_ipv6=dst_ip_t,
            field_in_port=in_port_t,
            action_mirror_ingress=mirror_action)

        #  ACL counter
        acl_counter_ingress = sai_thrift_create_acl_counter(
            self.client, table_id=acl_table)
        #  attach ACL counter to ACL entry
        action_counter_ingress = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=acl_counter_ingress),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, acl_entry,
            action_counter=action_counter_ingress)
        sai_thrift_set_switch_attribute(self.client, ingress_acl=acl_table)

        try:
            #  verify route-pkt egress out of egress port 25
            #  verify if the mirror packet [out of port 28] is incoming pkt
            print(" Tx v6 packet from port A to port B --> forw to B,"
                  " mirror in-pkt to port 28 ")
            send_packet(self, tx_port, pkt)
            verify_each_packet_on_each_port(self, [e_pkt, pkt],
                                            [rx_port, self.dev_port28])

            time.sleep(2)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter_ingress, packets=True)
            self.assertEqual(packets['packets'], 1)

            if in_port == self.port24:
                print(" Tx v6 packet from port C to port B --> forw to B,"
                      "  no mirror")
                send_packet(self, self.dev_port10, pkt)
                verify_packet(self, e_pkt, rx_port)

                time.sleep(2)
                packets = sai_thrift_get_acl_counter_attribute(
                    self.client, acl_counter_ingress, packets=True)
                self.assertEqual(packets['packets'], 1)

        finally:
            sai_thrift_set_switch_attribute(self.client, ingress_acl=0)
            #  cleanup ACL
            action_counter_ingress = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=0),
                enable=True)
            sai_thrift_set_acl_entry_attribute(
                self.client, acl_entry,
                action_counter=action_counter_ingress)
            sai_thrift_set_acl_counter_attribute(
                self.client, acl_counter_ingress, packets=None)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter_ingress, packets=True)
            self.assertEqual(packets['packets'], 0)
            sai_thrift_remove_acl_counter(self.client, acl_counter_ingress)
            sai_thrift_set_port_attribute(self.client, self.port24,
                                          ingress_acl=0)
            sai_thrift_set_port_attribute(self.client, self.port26,
                                          ingress_acl=0)
            sai_thrift_remove_acl_entry(self.client, acl_entry)
            sai_thrift_remove_acl_table(self.client, acl_table)
            sai_thrift_remove_mirror_session(self.client, mirror_session)


@group('acl2')
class AclRifTest(SaiHelper):
    """
    Verify ACL RIF tests for ports and lags
    """
    def setUp(self):
        super(AclRifTest, self).setUp()
        self.acl_entries = []
        self.acl_counters = []

        self.vr_id = sai_thrift_create_virtual_router(self.client,
                                                      admin_v4_state=True,
                                                      admin_v6_state=True)
        # RIF port11
        dst_ip = "11.1.1.1"
        dst_mask_ip = "11.1.1.1/24"
        self.neighbor_dmac11 = "00:11:11:11:11:11"
        self.neighbor_entry11 = sai_thrift_neighbor_entry_t(
            self.switch_id,
            self.port11_rif,
            sai_ipaddress(dst_ip))
        sai_thrift_create_neighbor_entry(self.client,
                                         self.neighbor_entry11,
                                         dst_mac_address=self.neighbor_dmac11)

        self.nhop11 = sai_thrift_create_next_hop(
            self.client,
            type=SAI_NEXT_HOP_TYPE_IP,
            router_interface_id=self.port11_rif,
            ip=sai_ipaddress(dst_ip))

        self.route11 = sai_thrift_route_entry_t(
            switch_id=self.switch_id,
            destination=sai_ipprefix(dst_mask_ip),
            vr_id=self.vr_id)
        status = sai_thrift_create_route_entry(self.client,
                                               self.route11,
                                               next_hop_id=self.nhop11)

        # RIF port12
        dst_ip = "12.1.1.1"
        dst_mask_ip = "12.1.1.1/24"
        neighbor_dmac = "00:12:12:12:12:12"
        self.neighbor_entry12 = sai_thrift_neighbor_entry_t(
            self.switch_id,
            self.port12_rif,
            sai_ipaddress(dst_ip))
        sai_thrift_create_neighbor_entry(
            self.client,
            self.neighbor_entry12,
            dst_mac_address=neighbor_dmac)

        self.nhop12 = sai_thrift_create_next_hop(
            self.client,
            type=SAI_NEXT_HOP_TYPE_IP,
            router_interface_id=self.port12_rif,
            ip=sai_ipaddress(dst_ip))

        self.route12 = sai_thrift_route_entry_t(
            switch_id=self.switch_id,
            destination=sai_ipprefix(dst_mask_ip),
            vr_id=self.vr_id)
        status = sai_thrift_create_route_entry(self.client,
                                               self.route12,
                                               next_hop_id=self.nhop12)

        # SVI configuration
        self.vlan10_rif = sai_thrift_create_router_interface(
            self.client,
            type=SAI_ROUTER_INTERFACE_TYPE_VLAN,
            virtual_router_id=self.default_vrf,
            vlan_id=self.vlan10)

        dst_ip = "13.1.1.1"
        dst_mask_ip = "13.1.1.1/24"
        neighbor_dmac = "00:13:13:13:13:13"
        self.neighbor_entry13 = sai_thrift_neighbor_entry_t(
            self.switch_id,
            self.vlan10_rif,
            sai_ipaddress(dst_ip))
        sai_thrift_create_neighbor_entry(
            self.client,
            self.neighbor_entry13,
            dst_mac_address=neighbor_dmac)

        self.nhop13 = sai_thrift_create_next_hop(
            self.client,
            type=SAI_NEXT_HOP_TYPE_IP,
            router_interface_id=self.vlan10_rif,
            ip=sai_ipaddress(dst_ip))

        self.route13 = sai_thrift_route_entry_t(
            switch_id=self.switch_id,
            destination=sai_ipprefix(dst_mask_ip),
            vr_id=self.vr_id)
        status = sai_thrift_create_route_entry(self.client,
                                               self.route13,
                                               next_hop_id=self.nhop13)

        # SVI mac config
        self.fdb_entry = sai_thrift_fdb_entry_t(
            switch_id=self.switch_id,
            mac_address=neighbor_dmac,
            bv_id=self.vlan10)

        mac_action = SAI_PACKET_ACTION_FORWARD
        sai_thrift_create_fdb_entry(
            self.client,
            self.fdb_entry,
            type=SAI_FDB_ENTRY_TYPE_STATIC,
            bridge_port_id=self.port0_bp,
            packet_action=mac_action)

        # Sub-port configuration
        self.sub100_rif = sai_thrift_create_router_interface(
            self.client,
            type=SAI_ROUTER_INTERFACE_TYPE_SUB_PORT,
            virtual_router_id=self.default_vrf,
            port_id=self.port26,
            outer_vlan_id=100,
            vlan_id=100,
            admin_v4_state=True)

        dst_ip = "14.1.1.1"
        dst_mask_ip = "14.1.1.1/24"
        neighbor_dmac = "00:14:14:14:14:14"
        self.neighbor_entry14 = sai_thrift_neighbor_entry_t(
            self.switch_id,
            self.sub100_rif,
            sai_ipaddress(dst_ip))
        sai_thrift_create_neighbor_entry(
            self.client,
            self.neighbor_entry14,
            dst_mac_address=neighbor_dmac)

        self.nhop14 = sai_thrift_create_next_hop(
            self.client,
            type=SAI_NEXT_HOP_TYPE_IP,
            router_interface_id=self.sub100_rif,
            ip=sai_ipaddress(dst_ip))

        self.route14 = sai_thrift_route_entry_t(
            switch_id=self.switch_id,
            destination=sai_ipprefix(dst_mask_ip),
            vr_id=self.vr_id)
        status = sai_thrift_create_route_entry(self.client,
                                               self.route14,
                                               next_hop_id=self.nhop14)

        # check L3 traffic flows
        pkt = simple_ip_packet(eth_dst=ROUTER_MAC,
                               eth_src="00:00:00:00:00:22",
                               ip_src="10.1.1.1",
                               ip_dst="11.1.1.1",
                               ip_ttl=64)

        exp_pkt = simple_ip_packet(eth_dst=self.neighbor_dmac11,
                                   eth_src=ROUTER_MAC,
                                   ip_src="10.1.1.1",
                                   ip_dst="11.1.1.1",
                                   ip_ttl=63)

        print("Sending L3 Test packet port10 -> port11")
        send_packet(self, self.dev_port10, pkt)
        verify_packet(self, exp_pkt, self.dev_port11)

        print("Sending L3 Test packet port12 -> port11")
        send_packet(self, self.dev_port12, pkt)
        verify_packet(self, exp_pkt, self.dev_port11)

        print("Sending L3 Test packet vlan10 (port0) -> port11")
        send_packet(self, self.dev_port0, pkt)
        verify_packet(self, exp_pkt, self.dev_port11)

        sub_pkt = simple_ip_packet(eth_dst=ROUTER_MAC,
                                   eth_src="00:00:00:00:00:22",
                                   ip_src="10.1.1.1",
                                   ip_dst="11.1.1.1",
                                   dl_vlan_enable=True,
                                   vlan_vid=100,
                                   ip_ttl=64,
                                   pktlen=104)

        sub_exp_pkt = simple_ip_packet(eth_dst=self.neighbor_dmac11,
                                       eth_src=ROUTER_MAC,
                                       ip_src="10.1.1.1",
                                       ip_dst="11.1.1.1",
                                       ip_ttl=63,
                                       pktlen=100)

        print("Sending L3 Test packet sub100 (port26) -> port11")
        send_packet(self, self.dev_port26, sub_pkt)
        verify_packet(self, sub_exp_pkt, self.dev_port11)

        pkt[IP].dst = "12.1.1.1"
        exp_pkt[Ether].dst = "00:12:12:12:12:12"
        exp_pkt[IP].dst = "12.1.1.1"

        print("Sending L3 Test packet port10 -> port12")
        send_packet(self, self.dev_port10, pkt)
        verify_packet(self, exp_pkt, self.dev_port12)

        print("Sending L3 Test packet port11 -> port12")
        send_packet(self, self.dev_port11, pkt)
        verify_packet(self, exp_pkt, self.dev_port12)

        print("Sending L3 Test packet vlan10 (port0) -> port12")
        send_packet(self, self.dev_port0, pkt)
        verify_packet(self, exp_pkt, self.dev_port12)

        pkt[IP].dst = "13.1.1.1"
        exp_pkt[Ether].dst = "00:13:13:13:13:13"
        exp_pkt[IP].dst = "13.1.1.1"

        print("Sending L3 Test packet port10 -> vlan10 (port0)")
        send_packet(self, self.dev_port10, pkt)
        verify_packet(self, exp_pkt, self.dev_port0)

        print("Sending L3 Test packet port11 -> vlan10 (port0)")
        send_packet(self, self.dev_port11, pkt)
        verify_packet(self, exp_pkt, self.dev_port0)

        print("Sending L3 Test packet port12 -> vlan10 (port0)")
        send_packet(self, self.dev_port12, pkt)
        verify_packet(self, exp_pkt, self.dev_port0)

        sub_pkt = simple_ip_packet(eth_dst=ROUTER_MAC,
                                   eth_src="00:00:00:00:00:22",
                                   ip_src="10.1.1.1",
                                   ip_dst="14.1.1.1",
                                   ip_ttl=64,
                                   pktlen=100)

        sub_exp_pkt = simple_ip_packet(eth_dst="00:14:14:14:14:14",
                                       eth_src=ROUTER_MAC,
                                       ip_src="10.1.1.1",
                                       ip_dst="14.1.1.1",
                                       dl_vlan_enable=True,
                                       vlan_vid=100,
                                       ip_ttl=63,
                                       pktlen=104)

        print("Sending L3 Test packet port10 -> sub100 (port26)")
        send_packet(self, self.dev_port10, sub_pkt)
        verify_packet(self, sub_exp_pkt, self.dev_port26)

    def runTest(self):
        print("Testing AclRifTest")
        print('-------------------------------------------------------------')
        self.configIngressAclRifTest()
        self.runIngressAclRifTest()
        self.cleanupIngressAclRifTest()
        self.configEgressAclRifTest()
        self.runEgressAclRifTest()
        self.cleanupEgressAclRifTest()

    def configIngressAclRifTest(self):
        # setup ACL table
        table_bpoints = [SAI_ACL_BIND_POINT_TYPE_SWITCH]
        table_bpoint_type_list = sai_thrift_s32_list_t(
            count=len(table_bpoints),
            int32list=table_bpoints)

        # custom attribute for In Router Interface
        attr_value = sai_thrift_attribute_value_t(booldata=True)
        attr = sai_thrift_attribute_t(id=(SAI_ACL_TABLE_ATTR_END),
                                      value=attr_value)

        # create ACL table
        self.acl_table = sai_thrift_create_acl_table(
            self.client,
            acl_stage=SAI_ACL_STAGE_INGRESS,
            acl_bind_point_type_list=table_bpoint_type_list,
            field_src_ip=True,
            field_dst_ip=True,
            custom_attribute=attr)

        # Bind acl table to switch
        sai_thrift_set_switch_attribute(
            self.client, ingress_acl=self.acl_table)

        # setup IPv4 ACL entry
        src_v4 = '10.1.1.1'
        src_ip_mask = '255.255.255.255'
        src_ip_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(ip4=src_v4),
            mask=sai_thrift_acl_field_data_mask_t(ip4=src_ip_mask))

        dst_v4 = '11.1.1.1'
        dst_ip_mask = '255.255.255.255'
        dst_ip_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(ip4=dst_v4),
            mask=sai_thrift_acl_field_data_mask_t(ip4=dst_ip_mask))

        # action is drop
        packet_action_t = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                s32=SAI_PACKET_ACTION_DROP))

        # RIF in-port is Port10
        in_port_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(oid=self.port10_rif))

        # custom attribute for In Router Interface
        attr_value = sai_thrift_attribute_value_t(aclfield=in_port_t)
        attr = sai_thrift_attribute_t(id=(SAI_ACL_ENTRY_ATTR_ACTION_END + 0x1),
                                      value=attr_value)
        # create IPv4 ACL entry
        self.acl_entry_v4_ip = sai_thrift_create_acl_entry(
            self.client,
            table_id=self.acl_table,
            field_src_ip=src_ip_t,
            field_dst_ip=dst_ip_t,
            action_packet_action=packet_action_t,
            custom_attribute=attr)

        # create ACL counter
        self.acl_counter_v4_ip = sai_thrift_create_acl_counter(
            self.client, table_id=self.acl_table)

        # attach ACL counter to ACL entry
        action_counter_t = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=self.acl_counter_v4_ip),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, self.acl_entry_v4_ip,
            action_counter=action_counter_t)

        # Add ACL on SVI vlan10
        src_v4 = '13.1.1.1'
        src_ip_mask = '255.255.255.255'
        src_ip_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(ip4=src_v4),
            mask=sai_thrift_acl_field_data_mask_t(ip4=src_ip_mask))

        # RIF in-port is vlan10
        in_port_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(oid=self.vlan10_rif))

        attr_value = sai_thrift_attribute_value_t(aclfield=in_port_t)
        attr = sai_thrift_attribute_t(id=(SAI_ACL_ENTRY_ATTR_ACTION_END + 0x1),
                                      value=attr_value)

        self.acl_entry_v4_ip_svi = sai_thrift_create_acl_entry(
            self.client,
            table_id=self.acl_table,
            field_src_ip=src_ip_t,
            field_dst_ip=dst_ip_t,
            action_packet_action=packet_action_t,
            custom_attribute=attr)

        self.acl_counter_v4_ip_svi = sai_thrift_create_acl_counter(
            self.client, table_id=self.acl_table)

        # attach ACL counter to ACL entry
        action_counter_t = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=self.acl_counter_v4_ip_svi),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, self.acl_entry_v4_ip_svi,
            action_counter=action_counter_t)

        # Add ACL on sub-port sub100
        src_v4 = '14.1.1.1'
        src_ip_mask = '255.255.255.255'
        src_ip_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(ip4=src_v4),
            mask=sai_thrift_acl_field_data_mask_t(ip4=src_ip_mask))

        # RIF in-port is sub100
        in_port_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(oid=self.sub100_rif))

        attr_value = sai_thrift_attribute_value_t(aclfield=in_port_t)
        attr = sai_thrift_attribute_t(id=(SAI_ACL_ENTRY_ATTR_ACTION_END + 0x1),
                                      value=attr_value)

        self.acl_entry_v4_ip_sub = sai_thrift_create_acl_entry(
            self.client,
            table_id=self.acl_table,
            field_src_ip=src_ip_t,
            field_dst_ip=dst_ip_t,
            action_packet_action=packet_action_t,
            custom_attribute=attr)

        self.acl_counter_v4_ip_sub = sai_thrift_create_acl_counter(
            self.client, table_id=self.acl_table)

        # attach ACL counter to ACL entry
        action_counter_t = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=self.acl_counter_v4_ip_sub),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, self.acl_entry_v4_ip_sub,
            action_counter=action_counter_t)

    def runIngressAclRifTest(self):
        print("Testing Ingress RIF ACL")

        print("Sending IPv4 packet port10 -> port11 (verify drop)")
        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.acl_counter_v4_ip, packets=True)
        self.assertEqual(packets['packets'], 0)
        pkt = simple_ip_packet(
            eth_dst=ROUTER_MAC,
            eth_src="00:00:00:00:00:22",
            ip_src="10.1.1.1",
            ip_dst="11.1.1.1",
            ip_ttl=64)

        # packet should be dropped by ACL
        send_packet(self, self.dev_port10, pkt)
        verify_no_other_packets(self, timeout=1)
        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.acl_counter_v4_ip, packets=True)
        self.assertEqual(packets['packets'], 1)

        # check packet from different port is not dropped
        exp_pkt = simple_ip_packet(
            eth_dst=self.neighbor_dmac11,
            eth_src=ROUTER_MAC,
            ip_src="10.1.1.1",
            ip_dst="11.1.1.1",
            ip_ttl=63)

        # Test SVI RIF
        print("Sending IPv4 packet vlan10 (port0) -> port11 (verify drop)")
        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.acl_counter_v4_ip_svi, packets=True)
        self.assertEqual(packets['packets'], 0)
        pkt = simple_ip_packet(
            eth_dst=ROUTER_MAC,
            eth_src="00:00:00:00:00:22",
            ip_src="13.1.1.1",
            ip_dst="11.1.1.1",
            ip_ttl=64)

        # packet should be dropped by ACL
        send_packet(self, self.dev_port0, pkt)
        verify_no_other_packets(self, timeout=1)
        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.acl_counter_v4_ip_svi, packets=True)
        self.assertEqual(packets['packets'], 1)

        # Test sub-port RIF
        print("Sending IPv4 packet sub100 (port26) -> port11 (verify drop)")
        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.acl_counter_v4_ip_sub, packets=True)
        self.assertEqual(packets['packets'], 0)
        sub_pkt = simple_ip_packet(
            eth_dst=ROUTER_MAC,
            eth_src="00:00:00:00:00:22",
            ip_src="14.1.1.1",
            ip_dst="11.1.1.1",
            dl_vlan_enable=True,
            vlan_vid=100,
            ip_ttl=64,
            pktlen=104)

        # packet should be dropped by ACL
        send_packet(self, self.dev_port26, sub_pkt)
        verify_no_other_packets(self, timeout=1)
        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.acl_counter_v4_ip_sub, packets=True)
        self.assertEqual(packets['packets'], 1)

        # check packet from different port is not dropped
        exp_pkt = simple_ip_packet(
            eth_dst=self.neighbor_dmac11,
            eth_src=ROUTER_MAC,
            ip_src="13.1.1.1",
            ip_dst="11.1.1.1",
            ip_ttl=63)

        print("Sending IPv4 packet port12 -> port11 (verify no drop)")
        send_packet(self, self.dev_port12, pkt)
        verify_packet(self, exp_pkt, self.dev_port11)
        verify_no_other_packets(self, timeout=1)
        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.acl_counter_v4_ip, packets=True)
        self.assertEqual(packets['packets'], 1)
        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.acl_counter_v4_ip_svi, packets=True)
        self.assertEqual(packets['packets'], 1)
        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.acl_counter_v4_ip_sub, packets=True)
        self.assertEqual(packets['packets'], 1)

    def cleanupIngressAclRifTest(self):
        # Clean up ACL configuration
        sai_thrift_set_switch_attribute(
            self.client, ingress_acl=int(SAI_NULL_OBJECT_ID))

        action_counter_t = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=0),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, self.acl_entry_v4_ip,
            action_counter=action_counter_t)

        sai_thrift_set_acl_counter_attribute(
            self.client, self.acl_counter_v4_ip, packets=None)
        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.acl_counter_v4_ip, packets=True)
        self.assertEqual(packets['packets'], 0)

        sai_thrift_remove_acl_counter(self.client, self.acl_counter_v4_ip)
        sai_thrift_remove_acl_entry(self.client, self.acl_entry_v4_ip)

        sai_thrift_set_acl_entry_attribute(
            self.client, self.acl_entry_v4_ip_svi,
            action_counter=action_counter_t)

        sai_thrift_set_acl_counter_attribute(
            self.client, self.acl_counter_v4_ip_svi, packets=None)
        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.acl_counter_v4_ip_svi, packets=True)
        self.assertEqual(packets['packets'], 0)

        sai_thrift_remove_acl_counter(self.client, self.acl_counter_v4_ip_svi)
        sai_thrift_remove_acl_entry(self.client, self.acl_entry_v4_ip_svi)

        sai_thrift_set_acl_entry_attribute(
            self.client, self.acl_entry_v4_ip_sub,
            action_counter=action_counter_t)

        sai_thrift_set_acl_counter_attribute(
            self.client, self.acl_counter_v4_ip_sub, packets=None)
        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.acl_counter_v4_ip_sub, packets=True)
        self.assertEqual(packets['packets'], 0)

        sai_thrift_remove_acl_counter(self.client, self.acl_counter_v4_ip_sub)
        sai_thrift_remove_acl_entry(self.client, self.acl_entry_v4_ip_sub)

    def configEgressAclRifTest(self):
        # setup ACL table
        table_bpoints = [SAI_ACL_BIND_POINT_TYPE_SWITCH]
        table_bpoint_type_list = sai_thrift_s32_list_t(
            count=len(table_bpoints),
            int32list=table_bpoints)

        # custom attribute for In Router Interface
        attr_value = sai_thrift_attribute_value_t(booldata=True)
        attr = sai_thrift_attribute_t(id=(SAI_ACL_TABLE_ATTR_END + 1),
                                      value=attr_value)

        # create ACL table
        self.acl_table = sai_thrift_create_acl_table(
            self.client,
            acl_stage=SAI_ACL_STAGE_EGRESS,
            acl_bind_point_type_list=table_bpoint_type_list,
            field_src_ip=True,
            field_dst_ip=True,
            custom_attribute=attr)

        # Bind acl table to switch
        sai_thrift_set_switch_attribute(
            self.client, ingress_acl=self.acl_table)

        # setup IPv4 ACL entry
        src_v4 = '10.1.1.1'
        src_ip_mask = '255.255.255.255'
        src_ip_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(ip4=src_v4),
            mask=sai_thrift_acl_field_data_mask_t(ip4=src_ip_mask))

        dst_v4 = '11.1.1.1'
        dst_ip_mask = '255.255.255.255'
        dst_ip_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(ip4=dst_v4),
            mask=sai_thrift_acl_field_data_mask_t(ip4=dst_ip_mask))

        # action is drop
        packet_action_t = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                s32=SAI_PACKET_ACTION_DROP))

        # RIF out-port is Port11
        out_port_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(oid=self.port11_rif))

        # custom attribute for Out Router Interface
        attr_value = sai_thrift_attribute_value_t(aclfield=out_port_t)
        attr = sai_thrift_attribute_t(id=(SAI_ACL_ENTRY_ATTR_ACTION_END + 0x2),
                                      value=attr_value)
        # create IPv4 ACL entry
        self.acl_entry_v4_ip = sai_thrift_create_acl_entry(
            self.client,
            table_id=self.acl_table,
            field_src_ip=src_ip_t,
            field_dst_ip=dst_ip_t,
            action_packet_action=packet_action_t,
            custom_attribute=attr)

        # create ACL counter
        self.acl_counter_v4_ip = sai_thrift_create_acl_counter(
            self.client, table_id=self.acl_table)

        # attach ACL counter to ACL entry
        action_counter_t = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=self.acl_counter_v4_ip),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, self.acl_entry_v4_ip,
            action_counter=action_counter_t)

        # Add ACL on SVI vlan10
        dst_v4 = '13.1.1.1'
        dst_ip_mask = '255.255.255.255'
        dst_ip_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(ip4=dst_v4),
            mask=sai_thrift_acl_field_data_mask_t(ip4=dst_ip_mask))

        # RIF out-port is vlan10
        out_port_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(oid=self.vlan10_rif))

        # custom attribute for Out Router Interface
        attr_value = sai_thrift_attribute_value_t(aclfield=out_port_t)
        attr = sai_thrift_attribute_t(id=(SAI_ACL_ENTRY_ATTR_ACTION_END + 0x2),
                                      value=attr_value)
        # create IPv4 ACL entry
        self.acl_entry_v4_ip_svi = sai_thrift_create_acl_entry(
            self.client,
            table_id=self.acl_table,
            field_src_ip=src_ip_t,
            field_dst_ip=dst_ip_t,
            action_packet_action=packet_action_t,
            custom_attribute=attr)

        # create ACL counter
        self.acl_counter_v4_ip_svi = sai_thrift_create_acl_counter(
            self.client, table_id=self.acl_table)

        # attach ACL counter to ACL entry
        action_counter_t = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=self.acl_counter_v4_ip_svi),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, self.acl_entry_v4_ip_svi,
            action_counter=action_counter_t)

        # Add ACL on sub-port sub100
        dst_v4 = '14.1.1.1'
        dst_ip_mask = '255.255.255.255'
        dst_ip_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(ip4=dst_v4),
            mask=sai_thrift_acl_field_data_mask_t(ip4=dst_ip_mask))

        # RIF out-port is vlan10
        out_port_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(oid=self.sub100_rif))

        # custom attribute for Out Router Interface
        attr_value = sai_thrift_attribute_value_t(aclfield=out_port_t)
        attr = sai_thrift_attribute_t(id=(SAI_ACL_ENTRY_ATTR_ACTION_END + 0x2),
                                      value=attr_value)
        # create IPv4 ACL entry
        self.acl_entry_v4_ip_sub = sai_thrift_create_acl_entry(
            self.client,
            table_id=self.acl_table,
            field_src_ip=src_ip_t,
            field_dst_ip=dst_ip_t,
            action_packet_action=packet_action_t,
            custom_attribute=attr)

        # create ACL counter
        self.acl_counter_v4_ip_sub = sai_thrift_create_acl_counter(
            self.client, table_id=self.acl_table)

        # attach ACL counter to ACL entry
        action_counter_t = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=self.acl_counter_v4_ip_sub),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, self.acl_entry_v4_ip_sub,
            action_counter=action_counter_t)

    def runEgressAclRifTest(self):
        print("Testing Egress RIF ACL")

        print("Sending IPv4 packet port10 -> port11 (verify drop)")
        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.acl_counter_v4_ip, packets=True)
        self.assertEqual(packets['packets'], 0)
        pkt = simple_ip_packet(
            eth_dst=ROUTER_MAC,
            eth_src="00:00:00:00:00:22",
            ip_src="10.1.1.1",
            ip_dst="11.1.1.1",
            ip_ttl=64)

        # packet should be dropped by egress ACL
        send_packet(self, self.dev_port10, pkt)
        verify_no_other_packets(self, timeout=1)
        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.acl_counter_v4_ip, packets=True)
        self.assertEqual(packets['packets'], 1)

        # Test SVI RIF
        print("Sending IPv4 packet port10 -> vlan10 (verify drop)")
        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.acl_counter_v4_ip_svi, packets=True)
        self.assertEqual(packets['packets'], 0)
        pkt = simple_ip_packet(
            eth_dst=ROUTER_MAC,
            eth_src="00:00:00:00:00:22",
            ip_src="10.1.1.1",
            ip_dst="13.1.1.1",
            ip_ttl=64)

        # packet should be dropped by egress ACL
        send_packet(self, self.dev_port10, pkt)
        verify_no_other_packets(self, timeout=1)
        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.acl_counter_v4_ip_svi, packets=True)
        self.assertEqual(packets['packets'], 1)

        # Test sub-port RIF
        print("Sending IPv4 packet port10 -> sub100 (verify drop)")
        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.acl_counter_v4_ip_sub, packets=True)
        self.assertEqual(packets['packets'], 0)
        pkt = simple_ip_packet(
            eth_dst=ROUTER_MAC,
            eth_src="00:00:00:00:00:22",
            ip_src="10.1.1.1",
            ip_dst="14.1.1.1",
            ip_ttl=64)

        # packet should be dropped by egress ACL
        send_packet(self, self.dev_port10, pkt)
        verify_no_other_packets(self, timeout=1)
        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.acl_counter_v4_ip_sub, packets=True)
        self.assertEqual(packets['packets'], 1)

        # check packet to different port is not dropped
        pkt[IP].dst = "12.1.1.1"
        exp_pkt = simple_ip_packet(
            eth_dst="00:12:12:12:12:12",
            eth_src=ROUTER_MAC,
            ip_src="10.1.1.1",
            ip_dst="12.1.1.1",
            ip_ttl=63)

        print("Sending IPv4 packet port10 -> port12 (verify no drop)")
        send_packet(self, self.dev_port10, pkt)
        verify_packet(self, exp_pkt, self.dev_port12)
        verify_no_other_packets(self, timeout=1)
        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.acl_counter_v4_ip, packets=True)
        self.assertEqual(packets['packets'], 1)
        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.acl_counter_v4_ip_svi, packets=True)
        self.assertEqual(packets['packets'], 1)
        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.acl_counter_v4_ip_sub, packets=True)
        self.assertEqual(packets['packets'], 1)

    def cleanupEgressAclRifTest(self):
        # Clean up ACL configuration
        sai_thrift_set_switch_attribute(
            self.client, ingress_acl=int(SAI_NULL_OBJECT_ID))

        action_counter_t = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=0),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, self.acl_entry_v4_ip,
            action_counter=action_counter_t)

        sai_thrift_set_acl_counter_attribute(
            self.client, self.acl_counter_v4_ip, packets=None)
        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.acl_counter_v4_ip, packets=True)
        self.assertEqual(packets['packets'], 0)

        sai_thrift_remove_acl_counter(self.client, self.acl_counter_v4_ip)
        sai_thrift_remove_acl_entry(self.client, self.acl_entry_v4_ip)

        sai_thrift_set_acl_entry_attribute(
            self.client, self.acl_entry_v4_ip_svi,
            action_counter=action_counter_t)

        sai_thrift_set_acl_counter_attribute(
            self.client, self.acl_counter_v4_ip_svi, packets=None)
        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.acl_counter_v4_ip_svi, packets=True)
        self.assertEqual(packets['packets'], 0)

        sai_thrift_remove_acl_counter(self.client, self.acl_counter_v4_ip_svi)
        sai_thrift_remove_acl_entry(self.client, self.acl_entry_v4_ip_svi)

        sai_thrift_set_acl_entry_attribute(
            self.client, self.acl_entry_v4_ip_sub,
            action_counter=action_counter_t)

        sai_thrift_set_acl_counter_attribute(
            self.client, self.acl_counter_v4_ip_sub, packets=None)
        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.acl_counter_v4_ip_sub, packets=True)
        self.assertEqual(packets['packets'], 0)

        sai_thrift_remove_acl_counter(self.client, self.acl_counter_v4_ip_sub)
        sai_thrift_remove_acl_entry(self.client, self.acl_entry_v4_ip_sub)

    def tearDown(self):
        # Clean up configuration
        sai_thrift_remove_fdb_entry(self.client, self.fdb_entry)
        sai_thrift_remove_route_entry(self.client, self.route11)
        sai_thrift_remove_next_hop(self.client, self.nhop11)
        sai_thrift_remove_neighbor_entry(self.client, self.neighbor_entry11)
        sai_thrift_remove_route_entry(self.client, self.route12)
        sai_thrift_remove_next_hop(self.client, self.nhop12)
        sai_thrift_remove_neighbor_entry(self.client, self.neighbor_entry12)
        sai_thrift_remove_route_entry(self.client, self.route13)
        sai_thrift_remove_next_hop(self.client, self.nhop13)
        sai_thrift_remove_neighbor_entry(self.client, self.neighbor_entry13)
        sai_thrift_remove_router_interface(self.client, self.vlan10_rif)
        sai_thrift_remove_route_entry(self.client, self.route14)
        sai_thrift_remove_next_hop(self.client, self.nhop14)
        sai_thrift_remove_neighbor_entry(self.client, self.neighbor_entry14)
        sai_thrift_remove_router_interface(self.client, self.sub100_rif)
        sai_thrift_remove_virtual_router(self.client, self.vr_id)
        super(AclRifTest, self).tearDown()


@group('acl2')
class AclPriorityTest(SaiHelper):
    """
    Verify ACL priorities
    """
    def setUp(self):
        super(AclPriorityTest, self).setUp()
        self.vr_id = sai_thrift_create_virtual_router(self.client,
                                                      admin_v4_state=True,
                                                      admin_v6_state=True)
        # RIF port11
        dst_ip = "11.1.1.1"
        dst_mask_ip = "11.1.1.1/24"
        self.neighbor_dmac11 = "00:11:11:11:11:11"
        self.neighbor_entry11 = sai_thrift_neighbor_entry_t(
            self.switch_id,
            self.port11_rif,
            sai_ipaddress(dst_ip))
        sai_thrift_create_neighbor_entry(self.client,
                                         self.neighbor_entry11,
                                         dst_mac_address=self.neighbor_dmac11)

        self.nhop11 = sai_thrift_create_next_hop(
            self.client,
            type=SAI_NEXT_HOP_TYPE_IP,
            router_interface_id=self.port11_rif,
            ip=sai_ipaddress(dst_ip))

        self.route11 = sai_thrift_route_entry_t(
            switch_id=self.switch_id,
            destination=sai_ipprefix(dst_mask_ip),
            vr_id=self.vr_id)
        status = sai_thrift_create_route_entry(self.client,
                                               self.route11,
                                               next_hop_id=self.nhop11)

        # RIF port12
        dst_ip = "12.1.1.1"
        dst_mask_ip = "12.1.1.1/24"
        self.neighbor_dmac12 = "00:12:12:12:12:12"
        self.neighbor_entry12 = sai_thrift_neighbor_entry_t(
            self.switch_id,
            self.port12_rif,
            sai_ipaddress(dst_ip))
        sai_thrift_create_neighbor_entry(
            self.client,
            self.neighbor_entry12,
            dst_mac_address=self.neighbor_dmac12)

        self.nhop12 = sai_thrift_create_next_hop(
            self.client,
            type=SAI_NEXT_HOP_TYPE_IP,
            router_interface_id=self.port12_rif,
            ip=sai_ipaddress(dst_ip))

        self.route12 = sai_thrift_route_entry_t(
            switch_id=self.switch_id,
            destination=sai_ipprefix(dst_mask_ip),
            vr_id=self.vr_id)
        status = sai_thrift_create_route_entry(self.client,
                                               self.route12,
                                               next_hop_id=self.nhop12)

        # check L3 traffic flows
        pkt = simple_ip_packet(eth_dst=ROUTER_MAC,
                               eth_src="00:00:00:00:00:22",
                               ip_src="11.1.1.1",
                               ip_dst="12.1.1.1",
                               ip_ttl=64)

        exp_pkt = simple_ip_packet(eth_dst=self.neighbor_dmac12,
                                   eth_src=ROUTER_MAC,
                                   ip_src="11.1.1.1",
                                   ip_dst="12.1.1.1",
                                   ip_ttl=63)

        print("Sending L3 Test packet port11 -> port12")
        send_packet(self, self.dev_port11, pkt)
        verify_packet(self, exp_pkt, self.dev_port12)

        # setup ACL table
        table_bpoints = [SAI_ACL_BIND_POINT_TYPE_SWITCH]
        table_bpoint_type_list = sai_thrift_s32_list_t(
            count=len(table_bpoints),
            int32list=table_bpoints)

        # create ACL table
        self.acl_table = sai_thrift_create_acl_table(
            self.client,
            acl_stage=SAI_ACL_STAGE_INGRESS,
            acl_bind_point_type_list=table_bpoint_type_list,
            field_src_ip=True,
            field_dst_ip=True)

        # Bind acl table to switch
        sai_thrift_set_switch_attribute(
            self.client, ingress_acl=self.acl_table)

    def runTest(self):
        print("AclPriorityTest")
        print('-------------------------------------------------------------')

        attrs = sai_thrift_get_switch_attribute(
            self.client,
            acl_entry_minimum_priority=True)
        acl_min_prio = attrs['acl_entry_minimum_priority']
        print('acl_entry_minimum_priority = ', acl_min_prio)
        # Check min priority is 0
        self.assertTrue(acl_min_prio == 0)

        attrs = sai_thrift_get_switch_attribute(
            self.client,
            acl_entry_maximum_priority=True)
        acl_max_prio = attrs['acl_entry_maximum_priority']
        print('acl_entry_maximum_priority = ', acl_max_prio)
        # Check max priority is 0xFFFFFF
        self.assertTrue(acl_max_prio == 16777215)

        # setup IPv4 ACL entry
        src_v4 = '11.1.1.1'
        src_ip_mask = '255.255.255.255'
        src_ip_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(ip4=src_v4),
            mask=sai_thrift_acl_field_data_mask_t(ip4=src_ip_mask))

        dst_v4 = '12.1.1.1'
        dst_ip_mask = '255.255.255.255'
        dst_ip_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(ip4=dst_v4),
            mask=sai_thrift_acl_field_data_mask_t(ip4=dst_ip_mask))

        packet_action_t = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                s32=SAI_PACKET_ACTION_DROP))

        # create IPv4 ACL entry with highest priority
        self.acl_entry1 = sai_thrift_create_acl_entry(
            self.client,
            table_id=self.acl_table,
            field_src_ip=src_ip_t,
            field_dst_ip=dst_ip_t,
            priority=acl_max_prio,
            action_packet_action=packet_action_t)

        attr = sai_thrift_get_acl_entry_attribute(
            self.client,
            self.acl_entry1,
            priority=True)
        self.assertTrue(attr['priority'] == acl_max_prio)

        # create IPv4 ACL entry with mid priority
        self.acl_entry2 = sai_thrift_create_acl_entry(
            self.client,
            table_id=self.acl_table,
            field_src_ip=src_ip_t,
            field_dst_ip=dst_ip_t,
            priority=0xFFFF,
            action_packet_action=packet_action_t)

        attr = sai_thrift_get_acl_entry_attribute(
            self.client,
            self.acl_entry2,
            priority=True)
        self.assertTrue(attr['priority'] == 0xFFFF)

        # create IPv4 ACL entry with lowest priority
        self.acl_entry3 = sai_thrift_create_acl_entry(
            self.client,
            table_id=self.acl_table,
            field_src_ip=src_ip_t,
            field_dst_ip=dst_ip_t,
            priority=acl_min_prio,
            action_packet_action=packet_action_t)

        attr = sai_thrift_get_acl_entry_attribute(
            self.client,
            self.acl_entry3,
            priority=True)
        self.assertTrue(attr['priority'] == acl_min_prio)

        # create ACL counters and attach to ACL entries
        self.acl_counter1 = sai_thrift_create_acl_counter(
            self.client, table_id=self.acl_table)

        self.acl_counter2 = sai_thrift_create_acl_counter(
            self.client, table_id=self.acl_table)

        self.acl_counter3 = sai_thrift_create_acl_counter(
            self.client, table_id=self.acl_table)

        action_counter_t = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=self.acl_counter1),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, self.acl_entry1,
            action_counter=action_counter_t)

        action_counter_t = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=self.acl_counter2),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, self.acl_entry2,
            action_counter=action_counter_t)

        action_counter_t = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=self.acl_counter3),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, self.acl_entry3,
            action_counter=action_counter_t)

        # Perform traffic tests to check ACL priority
        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.acl_counter1, packets=True)
        self.assertEqual(packets['packets'], 0)
        pkt = simple_ip_packet(
            eth_dst=ROUTER_MAC,
            eth_src="00:00:00:00:00:22",
            ip_src="11.1.1.1",
            ip_dst="12.1.1.1",
            ip_ttl=64)

        # packet should be dropped by highest prio ACL
        print("Sending port10 -> port11 (verify drop, acl high prio)")
        send_packet(self, self.dev_port11, pkt)
        verify_no_other_packets(self, timeout=1)
        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.acl_counter1, packets=True)
        self.assertEqual(packets['packets'], 1)

        # Remove ACL entry1/counter
        action_counter_t = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=0),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, self.acl_entry1,
            action_counter=action_counter_t)
        sai_thrift_set_acl_counter_attribute(
            self.client, self.acl_counter1, packets=None)
        sai_thrift_remove_acl_counter(self.client, self.acl_counter1)
        sai_thrift_remove_acl_entry(self.client, self.acl_entry1)

        # packet should be dropped by mid prio ACL
        print("Sending port11 -> port12 (verify drop, acl mid prio)")
        send_packet(self, self.dev_port11, pkt)
        verify_no_other_packets(self, timeout=1)
        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.acl_counter2, packets=True)
        self.assertEqual(packets['packets'], 1)

        # Remove ACL entry2/counter
        action_counter_t = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=0),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, self.acl_entry2,
            action_counter=action_counter_t)
        sai_thrift_set_acl_counter_attribute(
            self.client, self.acl_counter2, packets=None)
        sai_thrift_remove_acl_counter(self.client, self.acl_counter2)
        sai_thrift_remove_acl_entry(self.client, self.acl_entry2)

        # packet should be dropped by lowest prio ACL
        print("Sending port11 -> port12 (verify drop, acl low prio)")
        send_packet(self, self.dev_port11, pkt)
        verify_no_other_packets(self, timeout=1)
        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.acl_counter3, packets=True)
        self.assertEqual(packets['packets'], 1)

        # Remove ACL entry3/counter
        action_counter_t = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=0),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, self.acl_entry3,
            action_counter=action_counter_t)
        sai_thrift_set_acl_counter_attribute(
            self.client, self.acl_counter3, packets=None)
        sai_thrift_remove_acl_counter(self.client, self.acl_counter3)
        sai_thrift_remove_acl_entry(self.client, self.acl_entry3)

    def tearDown(self):
        # Unbind ACL table
        sai_thrift_set_switch_attribute(
            self.client, ingress_acl=int(SAI_NULL_OBJECT_ID))

        # Clean up configuration
        sai_thrift_remove_route_entry(self.client, self.route11)
        sai_thrift_remove_next_hop(self.client, self.nhop11)
        sai_thrift_remove_neighbor_entry(self.client, self.neighbor_entry11)
        sai_thrift_remove_route_entry(self.client, self.route12)
        sai_thrift_remove_next_hop(self.client, self.nhop12)
        sai_thrift_remove_neighbor_entry(self.client, self.neighbor_entry12)
        sai_thrift_remove_virtual_router(self.client, self.vr_id)
        super(AclPriorityTest, self).tearDown()


@group('acl2')
class L2MirrorTest(SaiHelper):
    """
    Verify ACL mirror for ports and lags test cases
    """
    def setUp(self):
        super(L2MirrorTest, self).setUp()
        self.acl_grp_members = []
        self.acl_grps = []
        self.acl_rules = []
        self.acl_tables = []
        self.vlan_members = []
        self.vlan_ports = []
        self.bridge_ports = []
        self.fdbs = []
        self.lags = []
        self.lag_members = []
        self.action_counters = []
        self.counters = []

        # Add port 24, 25, 26 to Vlan100
        vlan_id = 100
        self.vlan_oid = sai_thrift_create_vlan(self.client, vlan_id)

        port24_bp = sai_thrift_create_bridge_port(
            self.client,
            bridge_id=self.default_1q_bridge,
            port_id=self.port24,
            type=SAI_BRIDGE_PORT_TYPE_PORT,
            admin_state=True)

        self.bridge_ports.append(port24_bp)

        vlan_member1 = sai_thrift_create_vlan_member(
            self.client,
            vlan_id=self.vlan_oid,
            bridge_port_id=port24_bp,
            vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_UNTAGGED)
        self.vlan_members.append(vlan_member1)
        self.vlan_ports.append(self.port24)

        port25_bp = sai_thrift_create_bridge_port(
            self.client,
            bridge_id=self.default_1q_bridge,
            port_id=self.port25,
            type=SAI_BRIDGE_PORT_TYPE_PORT,
            admin_state=True)

        self.bridge_ports.append(port25_bp)

        vlan_member2 = sai_thrift_create_vlan_member(
            self.client,
            vlan_id=self.vlan_oid,
            bridge_port_id=port25_bp,
            vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_UNTAGGED)
        self.vlan_members.append(vlan_member2)
        self.vlan_ports.append(self.port25)

        port26_bp = sai_thrift_create_bridge_port(
            self.client,
            bridge_id=self.default_1q_bridge,
            port_id=self.port26,
            type=SAI_BRIDGE_PORT_TYPE_PORT,
            admin_state=True)

        self.bridge_ports.append(port26_bp)

        vlan_member3 = sai_thrift_create_vlan_member(
            self.client,
            vlan_id=self.vlan_oid,
            bridge_port_id=port26_bp,
            vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_UNTAGGED)
        self.vlan_members.append(vlan_member3)
        self.vlan_ports.append(self.port26)

        # Create Lag (port 27, 28) and add it to Vlan100
        self.lag_id = sai_thrift_create_lag(self.client)
        self.lags.append(self.lag_id)
        lag1_bp = sai_thrift_create_bridge_port(
            self.client,
            bridge_id=self.default_1q_bridge,
            port_id=self.lag_id,
            type=SAI_BRIDGE_PORT_TYPE_PORT,
            admin_state=True)
        self.bridge_ports.append(lag1_bp)
        lag_member_id1 = sai_thrift_create_lag_member(
            self.client, lag_id=self.lag_id, port_id=self.port27)
        self.lag_members.append(lag_member_id1)

        lag_member_id2 = sai_thrift_create_lag_member(
            self.client, lag_id=self.lag_id, port_id=self.port28)
        self.lag_members.append(lag_member_id2)

        vlan_member4 = sai_thrift_create_vlan_member(
            self.client,
            vlan_id=self.vlan_oid,
            bridge_port_id=lag1_bp,
            vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_UNTAGGED)

        self.vlan_members.append(vlan_member4)
        self.vlan_ports.append(self.port27)
        self.vlan_ports.append(self.port28)

        # setup ungtagged ports
        sai_thrift_set_port_attribute(
            self.client, self.port24, port_vlan_id=vlan_id)
        sai_thrift_set_port_attribute(
            self.client, self.port25, port_vlan_id=vlan_id)
        sai_thrift_set_port_attribute(
            self.client, self.port26, port_vlan_id=vlan_id)
        sai_thrift_set_lag_attribute(
            self.client, self.lag_id, port_vlan_id=vlan_id)

        # Bind fdb_entry for self.mac to port24 (i.e. egress)
        self.mac = '00:11:11:11:11:11'
        mac_action = SAI_PACKET_ACTION_FORWARD
        fdb_entry = sai_thrift_fdb_entry_t(
            switch_id=self.switch_id,
            mac_address=self.mac,
            bv_id=self.vlan_oid)
        sai_thrift_create_fdb_entry(
            self.client,
            fdb_entry,
            type=SAI_FDB_ENTRY_TYPE_STATIC,
            bridge_port_id=port24_bp,
            packet_action=mac_action)
        self.fdbs.append(fdb_entry)

        eth_pkt1 = simple_eth_packet(pktlen=100,
                                     eth_dst=self.mac,
                                     eth_src='00:06:07:08:09:0a')

        print('#### Basic tests NO ACL Applied ####')
        # send the test packet(s)
        print("Sending Test packet port 25 -> port 24")
        send_packet(self, self.dev_port25, eth_pkt1)
        verify_packets(self, eth_pkt1, [self.dev_port24])
        print("Sending Test packet port26 -> port 24")
        send_packet(self, self.dev_port26, eth_pkt1)
        verify_packets(self, eth_pkt1, [self.dev_port24])
        print("Sending Test packet lag port27 -> port 24")
        send_packet(self, self.dev_port27, eth_pkt1)
        verify_packets(self, eth_pkt1, [self.dev_port24])
        print("Sending Test packet lag port28 -> port 24")
        send_packet(self, self.dev_port28, eth_pkt1)
        verify_packets(self, eth_pkt1, [self.dev_port24])

        # L3 layer
        self.vr_id = sai_thrift_create_virtual_router(self.client,
                                                      admin_v4_state=True,
                                                      admin_v6_state=True)
        # L3 configuration
        # Neighbor egress

        # egress RIF port11
        dst_ip = "172.16.1.1"
        dst_mask_ip = "172.16.1.1/24"
        self.neighbor_dmac = "00:11:22:33:44:55"
        self.neighbor_entry1 = sai_thrift_neighbor_entry_t(
            self.switch_id,
            self.port11_rif,
            sai_ipaddress(dst_ip))
        sai_thrift_create_neighbor_entry(self.client,
                                         self.neighbor_entry1,
                                         dst_mac_address=self.neighbor_dmac)

        self.nhop = sai_thrift_create_next_hop(
            self.client,
            type=SAI_NEXT_HOP_TYPE_IP,
            router_interface_id=self.port11_rif,
            ip=sai_ipaddress(dst_ip))

        # egress RIF port12
        dst_ip_egr = "192.168.0.1"
        dst_mask_ip_egr = "192.168.0.1/24"
        self.neighbor_dmac_egr = "00:55:44:33:22:11"
        self.neighbor_entry2 = sai_thrift_neighbor_entry_t(
            self.switch_id,
            self.port12_rif,
            sai_ipaddress(dst_ip_egr))
        sai_thrift_create_neighbor_entry(
            self.client,
            self.neighbor_entry2,
            dst_mac_address=self.neighbor_dmac_egr)

        self.nhop2 = sai_thrift_create_next_hop(
            self.client,
            type=SAI_NEXT_HOP_TYPE_IP,
            router_interface_id=self.port12_rif,
            ip=sai_ipaddress(dst_ip_egr))

        # Route configuration
        self.route = sai_thrift_route_entry_t(
            switch_id=self.switch_id,
            destination=sai_ipprefix(dst_mask_ip),
            vr_id=self.vr_id)
        status = sai_thrift_create_route_entry(self.client,
                                               self.route,
                                               next_hop_id=self.nhop)

        self.route2 = sai_thrift_route_entry_t(
            switch_id=self.switch_id,
            destination=sai_ipprefix(dst_mask_ip_egr),
            vr_id=self.vr_id)
        status = sai_thrift_create_route_entry(self.client,
                                               self.route2,
                                               next_hop_id=self.nhop2)

        # IP for ERSPAN ingress mirroring
        src_ipv4 = sai_thrift_ip_addr_t(ip4="17.18.19.0")
        dst_ipv4 = sai_thrift_ip_addr_t(ip4="33.19.20.0")
        addr_fam = SAI_IP_ADDR_FAMILY_IPV4
        self.src_ip_addr = sai_thrift_ip_address_t(addr_family=addr_fam,
                                                   addr=src_ipv4)
        self.dst_ip_addr = sai_thrift_ip_address_t(addr_family=addr_fam,
                                                   addr=dst_ipv4)

        pkt = simple_tcp_packet(eth_dst=ROUTER_MAC,
                                eth_src="00:00:00:00:00:22",
                                ip_src="192.168.0.1",
                                ip_dst="172.16.1.1",
                                ip_id=101,
                                ip_ttl=64)

        exp_pkt = simple_tcp_packet(eth_dst=self.neighbor_dmac,
                                    eth_src=ROUTER_MAC,
                                    ip_src="192.168.0.1",
                                    ip_dst="172.16.1.1",
                                    ip_id=101,
                                    ip_ttl=63)

        print("Sending L3 Test packet Port 10 -> Port 11")
        send_packet(self, self.dev_port10, pkt)
        verify_packet(self, exp_pkt, self.dev_port11)
        print("Sending L3 Test packet Port 12 -> Port 11")
        send_packet(self, self.dev_port12, pkt)
        verify_packet(self, exp_pkt, self.dev_port11)

    def runTest(self):
        print("Running L2MirrorTest")
        print('-------------------------------------------------------------')
        self.configMirrorAclTableGroup()
        sai_thrift_set_switch_attribute(
            self.client, ingress_acl=self.acl_group)
        self.runMirrorAclTableGroupTest()
        sai_thrift_set_switch_attribute(
            self.client, ingress_acl=int(SAI_NULL_OBJECT_ID))
        self.cleanupMirorAclTableGroup()

    def tearDown(self):
        # Clean up network configuration
        for fdb in list(self.fdbs):
            sai_thrift_remove_fdb_entry(self.client, fdb)
            self.fdbs.remove(fdb)

        sai_thrift_set_port_attribute(
            self.client, self.port24, port_vlan_id=int(SAI_NULL_OBJECT_ID))
        sai_thrift_set_port_attribute(
            self.client, self.port25, port_vlan_id=int(SAI_NULL_OBJECT_ID))
        sai_thrift_set_port_attribute(
            self.client, self.port26, port_vlan_id=int(SAI_NULL_OBJECT_ID))
        sai_thrift_set_lag_attribute(
            self.client, self.lag_id, port_vlan_id=int(SAI_NULL_OBJECT_ID))

        for vlan_member in list(self.vlan_members):
            sai_thrift_remove_vlan_member(self.client, vlan_member)
            self.vlan_members.remove(vlan_member)
        sai_thrift_remove_vlan(self.client, self.vlan_oid)
        for lag_member in list(self.lag_members):
            sai_thrift_remove_lag_member(self.client, lag_member)
            self.lag_members.remove(lag_member)
        for port in list(self.bridge_ports):
            sai_thrift_remove_bridge_port(self.client, port)
            self.bridge_ports.remove(port)
        for lag in list(self.lags):
            sai_thrift_remove_lag(self.client, lag)
            self.lags.remove(lag)
        for vlan_port in list(self.vlan_ports):
            self.vlan_ports.remove(vlan_port)

        sai_thrift_remove_route_entry(self.client, self.route2)
        sai_thrift_remove_next_hop(self.client, self.nhop2)
        sai_thrift_remove_neighbor_entry(self.client, self.neighbor_entry2)
        sai_thrift_remove_neighbor_entry(self.client, self.neighbor_entry1)
        sai_thrift_remove_route_entry(self.client, self.route)
        sai_thrift_remove_next_hop(self.client, self.nhop)
        sai_thrift_remove_virtual_router(self.client, self.vr_id)

        super(L2MirrorTest, self).tearDown()

    def configMirrorAclTableGroup(self):
        '''
        configure both port/lag as in-port
        field with switch b-point to Ingress
        IP Mirror ACL table group.
        '''
        print("configMirrorAclTableGroup")

        # setup ACL table group
        group_stage = SAI_ACL_STAGE_INGRESS
        group_bpoints = [SAI_ACL_BIND_POINT_TYPE_SWITCH]
        group_bpoint_type_list = sai_thrift_s32_list_t(
            count=len(group_bpoints), int32list=group_bpoints)
        group_type = SAI_ACL_TABLE_GROUP_TYPE_PARALLEL

        # create ACL table group
        self.acl_group = sai_thrift_create_acl_table_group(
            self.client,
            acl_stage=group_stage,
            acl_bind_point_type_list=group_bpoint_type_list,
            type=group_type)

        # setup ACL table
        action_type = [SAI_ACL_ACTION_TYPE_MIRROR_INGRESS]
        action_type_list = sai_thrift_s32_list_t(
            count=len(action_type), int32list=action_type)

        ranges = [SAI_ACL_RANGE_TYPE_L4_SRC_PORT_RANGE,
                  SAI_ACL_RANGE_TYPE_L4_DST_PORT_RANGE]
        ranges_list = sai_thrift_s32_list_t(count=len(ranges),
                                            int32list=ranges)

        table_bpoints = [SAI_ACL_BIND_POINT_TYPE_SWITCH]
        table_bpoint_type_list = sai_thrift_s32_list_t(
            count=len(table_bpoints),
            int32list=table_bpoints)

        # create ACL table
        self.mirror_acl_table = sai_thrift_create_acl_table(
            self.client,
            acl_stage=SAI_ACL_STAGE_INGRESS,
            acl_bind_point_type_list=table_bpoint_type_list,
            field_src_mac=True,
            field_dst_mac=True,
            field_ether_type=True,
            field_src_ip=True,
            field_dst_ip=True,
            field_src_ipv6=True,
            field_dst_ipv6=True,
            field_dscp=True,
            field_ecn=True,
            field_ipv6_next_header=True,
            field_l4_src_port=True,
            field_l4_dst_port=True,
            field_tcp_flags=True,
            field_acl_range_type=ranges_list,
            field_icmp_type=True,
            field_icmp_code=True,
            field_icmpv6_type=True,
            field_icmpv6_code=True,
            field_in_port=True,
            acl_action_type_list=action_type_list)

        # create ACL table group member
        self.mirror_acl_member = sai_thrift_create_acl_table_group_member(
            self.client,
            acl_table_group_id=self.acl_group,
            acl_table_id=self.mirror_acl_table)

        # create mirror session
        self.mirror_session = sai_thrift_create_mirror_session(
            self.client,
            monitor_port=self.port22,
            type=SAI_MIRROR_SESSION_TYPE_LOCAL)
        mirror_session_list = sai_thrift_object_list_t(
            count=1, idlist=[self.mirror_session])
        mirror_action = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                objlist=mirror_session_list))

        # setup ACL entry
        src_mac_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(mac='00:06:07:88:88:88'),
            mask=sai_thrift_acl_field_data_mask_t(mac='ff:ff:ff:ff:ff:ff'))

        dst_mac_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(mac=self.mac),
            mask=sai_thrift_acl_field_data_mask_t(mac='ff:ff:ff:ff:ff:ff'))

        ether_type_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(u16=0x800),
            mask=sai_thrift_acl_field_data_mask_t(u16=0x7FFF))

        src_v4 = '10.0.0.55'
        src_ip_mask = '255.255.255.255'
        src_ip_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(ip4=src_v4),
            mask=sai_thrift_acl_field_data_mask_t(ip4=src_ip_mask))

        dst_v4 = '172.16.2.2'
        dst_ip_mask = '255.255.255.255'
        dst_ip_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(ip4=dst_v4),
            mask=sai_thrift_acl_field_data_mask_t(ip4=dst_ip_mask))

        dscp_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(u8=15),
            mask=sai_thrift_acl_field_data_mask_t(u8=127))

        # tcp_flags = 'SA'
        tcp_flags_t = sai_thrift_acl_field_data_t(
            enable=True,
            mask=sai_thrift_acl_field_data_mask_t(u8=127),
            data=sai_thrift_acl_field_data_data_t(u8=0x12))

        # sport is 4444
        u32range = sai_thrift_u32_range_t(min=4000, max=5000)
        acl_range1 = sai_thrift_create_acl_range(
            self.client,
            type=SAI_ACL_RANGE_TYPE_L4_SRC_PORT_RANGE,
            limit=u32range)

        # dport is 8888
        u32range = sai_thrift_u32_range_t(min=8000, max=9000)
        acl_range2 = sai_thrift_create_acl_range(
            self.client,
            type=SAI_ACL_RANGE_TYPE_L4_DST_PORT_RANGE,
            limit=u32range)
        range_list = [acl_range1, acl_range2]

        range_list_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(
                objlist=sai_thrift_object_list_t(
                    count=len(range_list),
                    idlist=range_list)))

        in_lag_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(oid=self.lag_id))

        # create v4 ACL entry prio 10
        self.mirror_v4_acl_entry = sai_thrift_create_acl_entry(
            self.client,
            table_id=self.mirror_acl_table,
            priority=10,
            field_src_mac=src_mac_t,
            field_dst_mac=dst_mac_t,
            field_ether_type=ether_type_t,
            field_src_ip=src_ip_t,
            field_dst_ip=dst_ip_t,
            field_dscp=dscp_t,
            field_tcp_flags=tcp_flags_t,
            field_acl_range_type=range_list_t,
            field_in_port=in_lag_t,
            action_mirror_ingress=mirror_action)

        # ACL counter
        self.mirror_v4_acl_counter = sai_thrift_create_acl_counter(
            self.client, table_id=self.mirror_acl_table)
        # attach ACL counter to ACL entry
        action_counter_t = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=self.mirror_v4_acl_counter),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, self.mirror_v4_acl_entry,
            action_counter=action_counter_t)

        src_mac_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(mac='00:06:07:99:99:99'),
            mask=sai_thrift_acl_field_data_mask_t(mac='ff:ff:ff:ff:ff:ff'))

        icmp_type_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(u8=9),
            mask=sai_thrift_acl_field_data_mask_t(u8=127))

        icmp_code_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(u8=16),
            mask=sai_thrift_acl_field_data_mask_t(u8=127))

        # create v4 ICMP ACL entry prio 20, this ACL applies on all ports
        self.mirror_v4_icmp_acl_entry = sai_thrift_create_acl_entry(
            self.client,
            table_id=self.mirror_acl_table,
            priority=20,
            field_src_mac=src_mac_t,
            field_dst_mac=dst_mac_t,
            field_ether_type=ether_type_t,
            field_src_ip=src_ip_t,
            field_dst_ip=dst_ip_t,
            field_icmp_type=icmp_type_t,
            field_icmp_code=icmp_code_t,
            action_mirror_ingress=mirror_action)

        # ACL counter
        self.mirror_v4_icmp_acl_counter = sai_thrift_create_acl_counter(
            self.client, table_id=self.mirror_acl_table)
        # attach ACL counter to ACL entry
        action_counter_t = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=self.mirror_v4_icmp_acl_counter),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, self.mirror_v4_icmp_acl_entry,
            action_counter=action_counter_t)

        # setup v6 ACL entry
        src_mac_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(mac='00:06:07:AA:AA:AA'),
            mask=sai_thrift_acl_field_data_mask_t(mac='ff:ff:ff:ff:ff:ff'))

        dst_mac_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(mac=self.mac),
            mask=sai_thrift_acl_field_data_mask_t(mac='ff:ff:ff:ff:ff:ff'))

        eth_type = 0x86DD
        if eth_type > 0x7FFF:
            eth_type -= 0x10000
        ether_type_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(u16=eth_type),
            mask=sai_thrift_acl_field_data_mask_t(u16=0x7FFF))

        src_v6 = '5555::8844'
        src_ip_mask = 'FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF'
        src_ip_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(ip6=src_v6),
            mask=sai_thrift_acl_field_data_mask_t(ip6=src_ip_mask))

        dst_v6 = '6666::7777'
        dst_ip_mask = 'FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF'
        dst_ip_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(ip6=dst_v6),
            mask=sai_thrift_acl_field_data_mask_t(ip6=dst_ip_mask))

        dscp_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(u8=20),
            mask=sai_thrift_acl_field_data_mask_t(u8=127))

        ecn_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(u8=1),
            mask=sai_thrift_acl_field_data_mask_t(u8=127))

        ipv6_next_header = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(u8=17),
            mask=sai_thrift_acl_field_data_mask_t(u8=0x0F))

        l4_src_port_mask = 32759
        l4_src_port_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(u16=4444),
            mask=sai_thrift_acl_field_data_mask_t(u16=l4_src_port_mask))

        icmp_type_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(u8=9),
            mask=sai_thrift_acl_field_data_mask_t(u8=127))

        icmp_code_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(u8=16),
            mask=sai_thrift_acl_field_data_mask_t(u8=127))

        l4_dst_port_mask = 32759
        l4_dst_port_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(u16=8888),
            mask=sai_thrift_acl_field_data_mask_t(u16=l4_dst_port_mask))

        in_port_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(oid=self.port26))

        # create v6 ACL entry prio 30
        self.mirror_v6_acl_entry = sai_thrift_create_acl_entry(
            self.client,
            table_id=self.mirror_acl_table,
            priority=30,
            field_src_mac=src_mac_t,
            field_dst_mac=dst_mac_t,
            field_ether_type=ether_type_t,
            field_src_ipv6=src_ip_t,
            field_dst_ipv6=dst_ip_t,
            field_dscp=dscp_t,
            field_ecn=ecn_t,
            field_ipv6_next_header=ipv6_next_header,
            field_l4_src_port=l4_src_port_t,
            field_l4_dst_port=l4_dst_port_t,
            field_in_port=in_port_t,
            action_mirror_ingress=mirror_action)

        #  ACL counter
        self.mirror_v6_acl_counter = sai_thrift_create_acl_counter(
            self.client, table_id=self.mirror_acl_table)
        # attach ACL counter to ACL entry
        action_counter_t = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=self.mirror_v6_acl_counter),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, self.mirror_v6_acl_entry,
            action_counter=action_counter_t)

        icmpv6_type_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(u8=5),
            mask=sai_thrift_acl_field_data_mask_t(u8=127))

        icmpv6_code_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(u8=1),
            mask=sai_thrift_acl_field_data_mask_t(u8=127))

        # create v6 ICMP ACL entry prio 40
        self.mirror_v6_icmp_acl_entry = sai_thrift_create_acl_entry(
            self.client,
            table_id=self.mirror_acl_table,
            priority=40,
            field_src_mac=src_mac_t,
            field_dst_mac=dst_mac_t,
            field_ether_type=ether_type_t,
            field_src_ipv6=src_ip_t,
            field_dst_ipv6=dst_ip_t,
            field_icmpv6_type=icmpv6_type_t,
            field_icmpv6_code=icmpv6_code_t,
            field_in_port=in_port_t,
            action_mirror_ingress=mirror_action)

        # ACL counter
        self.mirror_v6_icmp_acl_counter = sai_thrift_create_acl_counter(
            self.client, table_id=self.mirror_acl_table)
        # attach ACL counter to ACL entry
        action_counter_t = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=self.mirror_v6_icmp_acl_counter),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, self.mirror_v6_icmp_acl_entry,
            action_counter=action_counter_t)

        # configure ERSPAN mirror session
        encap_type = SAI_ERSPAN_ENCAPSULATION_TYPE_MIRROR_L3_GRE_TUNNEL
        self.erspan_id = sai_thrift_create_mirror_session(
            self.client,
            monitor_port=self.port22,
            type=SAI_MIRROR_SESSION_TYPE_ENHANCED_REMOTE,
            erspan_encapsulation_type=encap_type,
            iphdr_version=0x4,
            tos=0,
            src_ip_address=self.src_ip_addr,
            dst_ip_address=self.dst_ip_addr,
            src_mac_address="00:00:00:00:11:22",
            dst_mac_address="00:00:00:00:11:33",
            gre_protocol_type=0x22eb,
            ttl=64)

        mirror_session_list = sai_thrift_object_list_t(
            count=1, idlist=[self.erspan_id])
        mirror_action = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                objlist=mirror_session_list))

        # setup ACL entry
        src_v4 = '192.168.0.1'
        src_ip_mask = '255.255.255.255'
        src_ip_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(ip4=src_v4),
            mask=sai_thrift_acl_field_data_mask_t(ip4=src_ip_mask))

        dst_v4 = '172.16.1.1'
        dst_ip_mask = '255.255.255.255'
        dst_ip_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(ip4=dst_v4),
            mask=sai_thrift_acl_field_data_mask_t(ip4=dst_ip_mask))

        in_port_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(oid=self.port10))

        # create v4 ACL entry prio 50
        self.mirror_erspan_acl_entry = sai_thrift_create_acl_entry(
            self.client,
            table_id=self.mirror_acl_table,
            priority=50,
            field_src_ip=src_ip_t,
            field_dst_ip=dst_ip_t,
            field_in_port=in_port_t,
            action_mirror_ingress=mirror_action)

        # ACL counter
        self.mirror_erspan_acl_counter = sai_thrift_create_acl_counter(
            self.client, table_id=self.mirror_acl_table)
        # attach ACL counter to ACL entry
        action_counter_t = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=self.mirror_erspan_acl_counter),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, self.mirror_erspan_acl_entry,
            action_counter=action_counter_t)

    def runMirrorAclTableGroupTest(self):
        '''
        test traffic for IP mirror acl table group
        configV4AclTableGroup
        '''
        print("runMirrorAclTableGroupTest")

        # test v4 TCP packet
        tcp_pkt1 = simple_tcp_packet(
            eth_src='00:06:07:88:88:88',
            eth_dst=self.mac,
            ip_src='10.0.0.55',
            ip_dst='172.16.2.2',
            ip_dscp=15,
            tcp_sport=4444,
            tcp_dport=8888,
            tcp_flags='SA',
            pktlen=100)

        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.mirror_v4_acl_counter, packets=True)
        self.assertEqual(packets['packets'], 0)

        # verify switch-pkt egress out of egress port
        # verify if the mirror packet [out of port 22] is incoming pkt
        print(" Tx v4 packet from lag port 27 --> forw to port 24, "
              " mirror in-pkt to port 22 ")
        send_packet(self, self.dev_port27, tcp_pkt1)
        verify_each_packet_on_each_port(self, [tcp_pkt1, tcp_pkt1],
                                        [self.dev_port24, self.dev_port22])

        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.mirror_v4_acl_counter, packets=True)
        self.assertEqual(packets['packets'], 1)

        # verify pkt from different in-port is not mirrored
        print(" Tx v4 packet from port 25 --> forw to port 24, "
              " no mirror to port 22")
        send_packet(self, self.dev_port25, tcp_pkt1)
        verify_packet(self, tcp_pkt1, self.dev_port24)
        verify_no_other_packets(self, timeout=2)

        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.mirror_v4_acl_counter, packets=True)
        self.assertEqual(packets['packets'], 1)

        # Test v4 UDP packet
        icmp_pkt1 = simple_icmp_packet(
            eth_src='00:06:07:99:99:99',
            eth_dst=self.mac,
            ip_src='10.0.0.55',
            ip_dst='172.16.2.2',
            icmp_type=9,
            icmp_code=16,
            pktlen=80)

        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.mirror_v4_icmp_acl_counter, packets=True)
        self.assertEqual(packets['packets'], 0)

        # verify switch-pkt egress out of egress port
        # verify if the mirror packet [out of port 22] is incoming pkt
        print(" Tx v4 icmp packet from lag port 27 --> forw to port 24, "
              " mirror in-pkt to port 22 ")
        send_packet(self, self.dev_port27, icmp_pkt1)
        verify_each_packet_on_each_port(self, [icmp_pkt1, icmp_pkt1],
                                        [self.dev_port24, self.dev_port22])

        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.mirror_v4_icmp_acl_counter, packets=True)
        self.assertEqual(packets['packets'], 1)

        # verify pkt from different in-port is also mirrored
        print(" Tx v4 icmp packet from lag port 25 --> forw to port 24, "
              " mirror in-pkt to port 22 ")
        send_packet(self, self.dev_port25, icmp_pkt1)
        verify_each_packet_on_each_port(self, [icmp_pkt1, icmp_pkt1],
                                        [self.dev_port24, self.dev_port22])

        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.mirror_v4_icmp_acl_counter, packets=True)
        self.assertEqual(packets['packets'], 2)

        # Test v6 UDP packet
        udp_pkt1 = simple_udpv6_packet(
            eth_src='00:06:07:AA:AA:AA',
            eth_dst=self.mac,
            ipv6_src='5555::8844',
            ipv6_dst='6666::7777',
            ipv6_dscp=20,
            ipv6_ecn=1,
            ipv6_hlim=64,
            udp_sport=4444,
            udp_dport=8888,
            pktlen=1000)

        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.mirror_v6_acl_counter, packets=True)
        self.assertEqual(packets['packets'], 0)

        # verify switch-pkt egress out of egress port
        # verify if the mirror packet [out of port 22] is incoming pkt
        print(" Tx v6 packet from port 26 --> forw to port 24, "
              " mirror in-pkt to port 22 ")
        send_packet(self, self.dev_port26, udp_pkt1)
        verify_each_packet_on_each_port(self, [udp_pkt1, udp_pkt1],
                                        [self.dev_port24, self.dev_port22])

        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.mirror_v6_acl_counter, packets=True)
        self.assertEqual(packets['packets'], 1)

        # verify pkt from different in-port is not mirrored
        print(" Tx v6 packet from port 25 --> forw to port 24, "
              " no mirror to port 22")
        send_packet(self, self.dev_port25, udp_pkt1)
        verify_packet(self, udp_pkt1, self.dev_port24)
        verify_no_other_packets(self, timeout=2)

        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.mirror_v6_acl_counter, packets=True)
        self.assertEqual(packets['packets'], 1)

        # Test v6 ICMP packet
        icmpv6_pkt1 = simple_icmpv6_packet(
            eth_src='00:06:07:AA:AA:AA',
            eth_dst=self.mac,
            ipv6_src='5555::8844',
            ipv6_dst='6666::7777',
            icmp_type=5,
            icmp_code=1,
            pktlen=80)

        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.mirror_v6_icmp_acl_counter, packets=True)
        self.assertEqual(packets['packets'], 0)

        # verify switch-pkt egress out of egress port
        # verify if the mirror packet [out of port 22] is incoming pkt
        print(" Tx v6 icmp packet from port 26 --> forw to port 24, "
              " mirror in-pkt to port 22 ")
        send_packet(self, self.dev_port26, icmpv6_pkt1)
        verify_each_packet_on_each_port(self, [icmpv6_pkt1, icmpv6_pkt1],
                                        [self.dev_port24, self.dev_port22])

        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.mirror_v6_icmp_acl_counter, packets=True)
        self.assertEqual(packets['packets'], 1)

        # verify pkt from different in-port is not mirrored
        print(" Tx v6 icmp packet from port 25 --> forw to port 24, "
              " no mirror to port 22")
        send_packet(self, self.dev_port25, icmpv6_pkt1)
        verify_packet(self, icmpv6_pkt1, self.dev_port24)
        verify_no_other_packets(self, timeout=2)

        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.mirror_v6_icmp_acl_counter, packets=True)
        self.assertEqual(packets['packets'], 1)

        pkt = simple_tcp_packet(eth_dst=ROUTER_MAC,
                                eth_src="00:00:00:00:00:22",
                                ip_src="192.168.0.1",
                                ip_dst="172.16.1.1",
                                ip_id=101,
                                ip_ttl=64)

        exp_pkt = simple_tcp_packet(eth_dst=self.neighbor_dmac,
                                    eth_src=ROUTER_MAC,
                                    ip_src="192.168.0.1",
                                    ip_dst="172.16.1.1",
                                    ip_id=101,
                                    ip_ttl=63)
        exp_inner_pkt = simple_tcp_packet(eth_dst=ROUTER_MAC,
                                          eth_src="00:00:00:00:00:22",
                                          ip_src="192.168.0.1",
                                          ip_dst="172.16.1.1",
                                          ip_id=101,
                                          ip_ttl=64)
        exp_mirrored_pkt = ipv4_erspan_pkt(eth_src="00:00:00:00:11:22",
                                           eth_dst="00:00:00:00:11:33",
                                           ip_src="17.18.19.0",
                                           ip_dst="33.19.20.0",
                                           ip_id=0,
                                           ip_ttl=64,
                                           ip_flags=0x2,
                                           version=2,
                                           mirror_id=self.erspan_id,
                                           inner_frame=exp_inner_pkt)
        # IEEE 1588
        exp_mirrored_pkt["ERSPAN_III"].gra = 2

        exp_mask_mirrored_pkt = Mask(exp_mirrored_pkt)
        exp_mask_mirrored_pkt.set_do_not_care_scapy(ptf.packet.IP, "tos")
        exp_mask_mirrored_pkt.set_do_not_care_scapy(ptf.packet.IP, "ihl")
        exp_mask_mirrored_pkt.set_do_not_care_scapy(ptf.packet.IP, "len")
        exp_mask_mirrored_pkt.set_do_not_care_scapy(ptf.packet.IP, "frag")
        exp_mask_mirrored_pkt.set_do_not_care_scapy(ptf.packet.IP, "ttl")
        exp_mask_mirrored_pkt.set_do_not_care_scapy(ptf.packet.IP, "flags")
        exp_mask_mirrored_pkt.set_do_not_care_scapy(ptf.packet.IP, "chksum")
        exp_mask_mirrored_pkt.set_do_not_care_scapy(ptf.packet.GRE, "proto")

        exp_mask_mirrored_pkt.set_do_not_care_scapy(ptf.packet.ERSPAN_III,
                                                    "session_id")
        exp_mask_mirrored_pkt.set_do_not_care_scapy(ptf.packet.ERSPAN_III,
                                                    "timestamp")
        exp_mask_mirrored_pkt.set_do_not_care_scapy(ptf.packet.ERSPAN_III,
                                                    "sgt_other")
        exp_mask_mirrored_pkt.set_do_not_care_scapy(ptf.packet.ERSPAN_III,
                                                    "vlan")

        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.mirror_erspan_acl_counter, packets=True)
        self.assertEqual(packets['packets'], 0)

        # verify switch-pkt egress out of egress port
        # verify if the mirror packet [out of port 22] is incoming pkt
        print(" Tx L3 packet from port 10 --> forw to port 11, "
              " ERSPAN mirror in-pkt to port 22 ")
        send_packet(self, self.dev_port10, pkt)
        verify_packet(self, exp_pkt, self.dev_port11)
        verify_packet(self, exp_mask_mirrored_pkt, self.dev_port22)

        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.mirror_erspan_acl_counter, packets=True)
        self.assertEqual(packets['packets'], 1)

        # verify pkt from different in-port is not mirrored
        print(" Tx L3 packet from port 12 --> forw to port 11, "
              " no mirror to port 22")
        send_packet(self, self.dev_port12, pkt)
        verify_packet(self, exp_pkt, self.dev_port11)
        verify_no_other_packets(self, timeout=2)

        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.mirror_erspan_acl_counter, packets=True)
        self.assertEqual(packets['packets'], 1)

    def cleanupMirorAclTableGroup(self):
        '''
        cleanup IP mirror acl counters, entries,
        table, group
        '''
        print("cleanupMirorAclTableGroup")

        action_counter_t = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=0),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, self.mirror_v4_acl_entry,
            action_counter=action_counter_t)

        sai_thrift_set_acl_counter_attribute(
            self.client, self.mirror_v4_acl_counter, packets=None)
        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.mirror_v4_acl_counter, packets=True)
        self.assertEqual(packets['packets'], 0)

        sai_thrift_remove_acl_counter(self.client, self.mirror_v4_acl_counter)

        sai_thrift_remove_acl_entry(self.client, self.mirror_v4_acl_entry)

        sai_thrift_set_acl_entry_attribute(
            self.client, self.mirror_v4_icmp_acl_entry,
            action_counter=action_counter_t)

        sai_thrift_set_acl_counter_attribute(
            self.client, self.mirror_v4_icmp_acl_counter, packets=None)
        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.mirror_v4_icmp_acl_counter, packets=True)
        self.assertEqual(packets['packets'], 0)

        sai_thrift_remove_acl_counter(
            self.client, self.mirror_v4_icmp_acl_counter)

        sai_thrift_remove_acl_entry(self.client, self.mirror_v4_icmp_acl_entry)

        sai_thrift_set_acl_entry_attribute(
            self.client, self.mirror_v6_acl_entry,
            action_counter=action_counter_t)

        sai_thrift_set_acl_counter_attribute(
            self.client, self.mirror_v6_acl_counter, packets=None)
        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.mirror_v6_acl_counter, packets=True)
        self.assertEqual(packets['packets'], 0)

        sai_thrift_remove_acl_counter(self.client, self.mirror_v6_acl_counter)

        sai_thrift_remove_acl_entry(self.client, self.mirror_v6_acl_entry)

        sai_thrift_set_acl_entry_attribute(
            self.client, self.mirror_v6_icmp_acl_entry,
            action_counter=action_counter_t)

        sai_thrift_set_acl_counter_attribute(
            self.client, self.mirror_v6_icmp_acl_counter, packets=None)
        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.mirror_v6_icmp_acl_counter, packets=True)
        self.assertEqual(packets['packets'], 0)

        sai_thrift_remove_acl_counter(
            self.client, self.mirror_v6_icmp_acl_counter)

        sai_thrift_remove_acl_entry(self.client, self.mirror_v6_icmp_acl_entry)

        sai_thrift_set_acl_entry_attribute(
            self.client, self.mirror_erspan_acl_entry,
            action_counter=action_counter_t)

        sai_thrift_set_acl_counter_attribute(
            self.client, self.mirror_erspan_acl_counter, packets=None)
        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.mirror_erspan_acl_counter, packets=True)
        self.assertEqual(packets['packets'], 0)

        sai_thrift_remove_acl_counter(self.client,
                                      self.mirror_erspan_acl_counter)

        sai_thrift_remove_acl_entry(self.client, self.mirror_erspan_acl_entry)

        sai_thrift_remove_acl_table_group_member(
            self.client, self.mirror_acl_member)
        sai_thrift_remove_acl_table(self.client, self.mirror_acl_table)
        sai_thrift_remove_acl_table_group(self.client, self.acl_group)

        sai_thrift_remove_mirror_session(self.client, self.erspan_id)
        sai_thrift_remove_mirror_session(self.client, self.mirror_session)

    def configMirrorERSPAN(self):
        '''
        configure both port/lag as in-port
        field with switch b-point to Ingress
        IP Mirror ERSPAN ACL table group.
        '''
        print("configMirrorERSPAN")

    def runMirrorERSPANtest(self):
        '''
        test traffic for IP mirror acl table group
        configV4AclTableGroup
        '''
        print("runMirrorERSPANtest")

    def cleanupMirrorERSPAN(self):
        '''
        cleanup IP mirror acl counters, entries,
        table, group
        '''
        print("cleanupMirrorERSPAN")


@group('acl2')
class L2RedirectPortAndLagTest(SaiHelper):
    """
    Verify ACL redirection for ports and lags test cases
    """
    def setUp(self):
        super(L2RedirectPortAndLagTest, self).setUp()
        self.acl_grp_members = []
        self.acl_grps = []
        self.acl_rules = []
        self.acl_tables = []
        self.vlan_members = []
        self.vlan_ports = []
        self.bridge_ports = []
        self.fdbs = []
        self.lags = []
        self.lag_members = []
        self.action_counters = []
        self.counters = []

        self.mac = '00:11:11:11:11:11'
        mac_action = SAI_PACKET_ACTION_FORWARD

        # Add port 24, 25, 26 to Vlan100
        vlan_id = 100
        self.vlan_oid = sai_thrift_create_vlan(self.client, vlan_id)

        port24_bp = sai_thrift_create_bridge_port(
            self.client,
            bridge_id=self.default_1q_bridge,
            port_id=self.port24,
            type=SAI_BRIDGE_PORT_TYPE_PORT,
            admin_state=True)

        self.bridge_ports.append(port24_bp)

        vlan_member1 = sai_thrift_create_vlan_member(
            self.client,
            vlan_id=self.vlan_oid,
            bridge_port_id=port24_bp,
            vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_UNTAGGED)
        self.vlan_members.append(vlan_member1)
        self.vlan_ports.append(self.port24)

        port25_bp = sai_thrift_create_bridge_port(
            self.client,
            bridge_id=self.default_1q_bridge,
            port_id=self.port25,
            type=SAI_BRIDGE_PORT_TYPE_PORT,
            admin_state=True)

        self.bridge_ports.append(port25_bp)

        vlan_member2 = sai_thrift_create_vlan_member(
            self.client,
            vlan_id=self.vlan_oid,
            bridge_port_id=port25_bp,
            vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_UNTAGGED)
        self.vlan_members.append(vlan_member2)
        self.vlan_ports.append(self.port25)

        port26_bp = sai_thrift_create_bridge_port(
            self.client,
            bridge_id=self.default_1q_bridge,
            port_id=self.port26,
            type=SAI_BRIDGE_PORT_TYPE_PORT,
            admin_state=True)

        self.bridge_ports.append(port26_bp)

        vlan_member3 = sai_thrift_create_vlan_member(
            self.client,
            vlan_id=self.vlan_oid,
            bridge_port_id=port26_bp,
            vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_UNTAGGED)
        self.vlan_members.append(vlan_member3)
        self.vlan_ports.append(self.port26)

        sai_thrift_set_port_attribute(
            self.client, self.port24, port_vlan_id=vlan_id)
        sai_thrift_set_port_attribute(
            self.client, self.port25, port_vlan_id=vlan_id)
        sai_thrift_set_port_attribute(
            self.client, self.port26, port_vlan_id=vlan_id)

        # Create Lag (port 27, 28) and add it to Vlan100
        self.lag_id = sai_thrift_create_lag(self.client)
        self.lags.append(self.lag_id)
        lag1_bp = sai_thrift_create_bridge_port(
            self.client,
            bridge_id=self.default_1q_bridge,
            port_id=self.lag_id,
            type=SAI_BRIDGE_PORT_TYPE_PORT,
            admin_state=True)
        self.bridge_ports.append(lag1_bp)
        lag_member_id1 = sai_thrift_create_lag_member(
            self.client, lag_id=self.lag_id, port_id=self.port27)
        self.lag_members.append(lag_member_id1)

        lag_member_id2 = sai_thrift_create_lag_member(
            self.client, lag_id=self.lag_id, port_id=self.port28)
        self.lag_members.append(lag_member_id2)

        vlan_member4 = sai_thrift_create_vlan_member(
            self.client,
            vlan_id=self.vlan_oid,
            bridge_port_id=lag1_bp,
            vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_UNTAGGED)

        self.vlan_members.append(vlan_member4)
        self.vlan_ports.append(self.port27)
        self.vlan_ports.append(self.port28)

        fdb_entry = sai_thrift_fdb_entry_t(
            switch_id=self.switch_id,
            mac_address=self.mac,
            bv_id=self.vlan_oid)
        sai_thrift_create_fdb_entry(
            self.client,
            fdb_entry,
            type=SAI_FDB_ENTRY_TYPE_STATIC,
            bridge_port_id=port24_bp,
            packet_action=mac_action)
        self.fdbs.append(fdb_entry)

        # VRF configuration
        self.vr_id = sai_thrift_create_virtual_router(self.client,
                                                      admin_v4_state=True,
                                                      admin_v6_state=True)
        # egress RIF port11
        dst_ip = "11.1.1.1"
        dst_mask_ip = "11.1.1.1/24"
        self.neighbor_dmac11 = "00:11:11:11:11:11"
        self.neighbor_entry11 = sai_thrift_neighbor_entry_t(
            self.switch_id,
            self.port11_rif,
            sai_ipaddress(dst_ip))
        sai_thrift_create_neighbor_entry(self.client,
                                         self.neighbor_entry11,
                                         dst_mac_address=self.neighbor_dmac11)

        self.nhop11 = sai_thrift_create_next_hop(
            self.client,
            type=SAI_NEXT_HOP_TYPE_IP,
            router_interface_id=self.port11_rif,
            ip=sai_ipaddress(dst_ip))

        # Route configuration
        self.route11 = sai_thrift_route_entry_t(
            switch_id=self.switch_id,
            destination=sai_ipprefix(dst_mask_ip),
            vr_id=self.vr_id)
        status = sai_thrift_create_route_entry(self.client,
                                               self.route11,
                                               next_hop_id=self.nhop11)

        # egress RIF port12
        dst_ip = "12.1.1.1"
        dst_mask_ip = "12.1.1.1/24"
        self.neighbor_dmac12 = "00:12:12:12:12:12"
        self.neighbor_entry12 = sai_thrift_neighbor_entry_t(
            self.switch_id,
            self.port12_rif,
            sai_ipaddress(dst_ip))
        sai_thrift_create_neighbor_entry(
            self.client,
            self.neighbor_entry12,
            dst_mac_address=self.neighbor_dmac12)

        self.nhop12 = sai_thrift_create_next_hop(
            self.client,
            type=SAI_NEXT_HOP_TYPE_IP,
            router_interface_id=self.port12_rif,
            ip=sai_ipaddress(dst_ip))

        # Route configuration
        self.route12 = sai_thrift_route_entry_t(
            switch_id=self.switch_id,
            destination=sai_ipprefix(dst_mask_ip),
            vr_id=self.vr_id)
        status = sai_thrift_create_route_entry(self.client,
                                               self.route12,
                                               next_hop_id=self.nhop12)

        # egress RIF port13
        dst_ip = "13.1.1.1"
        dst_mask_ip = "13.1.1.1/24"
        self.neighbor_dmac13 = "00:13:13:13:13:13"
        self.neighbor_entry13 = sai_thrift_neighbor_entry_t(
            self.switch_id,
            self.port13_rif,
            sai_ipaddress(dst_ip))
        sai_thrift_create_neighbor_entry(
            self.client,
            self.neighbor_entry13,
            dst_mac_address=self.neighbor_dmac13)

        self.nhop13 = sai_thrift_create_next_hop(
            self.client,
            type=SAI_NEXT_HOP_TYPE_IP,
            router_interface_id=self.port13_rif,
            ip=sai_ipaddress(dst_ip))

        # Route configuration
        self.route13 = sai_thrift_route_entry_t(
            switch_id=self.switch_id,
            destination=sai_ipprefix(dst_mask_ip),
            vr_id=self.vr_id)
        status = sai_thrift_create_route_entry(self.client,
                                               self.route13,
                                               next_hop_id=self.nhop13)

        # nhop group
        self.nhop_group = sai_thrift_create_next_hop_group(
            self.client, type=SAI_NEXT_HOP_GROUP_TYPE_ECMP)
        self.nhop_group_mmbr1 = sai_thrift_create_next_hop_group_member(
            self.client,
            next_hop_group_id=self.nhop_group,
            next_hop_id=self.nhop11)
        self.nhop_group_mmbr2 = sai_thrift_create_next_hop_group_member(
            self.client,
            next_hop_group_id=self.nhop_group,
            next_hop_id=self.nhop13)

    def runTest(self):
        print("Testing L2RedirectPortAndLagTest")
        print('-------------------------------------------------------------')

        eth_pkt1 = simple_eth_packet(pktlen=100,
                                     eth_dst=self.mac,
                                     eth_src='00:06:07:08:09:0a',
                                     eth_type=0x8137)
        eth_pkt2 = simple_eth_packet(pktlen=100,
                                     eth_dst=self.mac,
                                     eth_src='00:06:07:08:09:0a',
                                     eth_type=0x8136)
        eth_pkt3 = simple_eth_packet(pktlen=100,
                                     eth_dst=self.mac,
                                     eth_src='00:06:07:08:09:0a',
                                     eth_type=0x8135)
        eth_pkt4 = simple_eth_packet(pktlen=100,
                                     eth_dst=self.mac,
                                     eth_src='00:06:07:08:09:0a',
                                     eth_type=0x8134)
        neg_test_pkt = simple_eth_packet(pktlen=100,
                                         eth_dst=self.mac,
                                         eth_src='00:06:07:08:09:0a',
                                         eth_type=0x1111)

        print('#### NO ACL Applied ####')
        # send the test packet(s)
        print("Sending Test packet EthType:0x%lx port 25 -> port 24" % (
            eth_pkt1[Ether].type))
        send_packet(self, self.dev_port25, eth_pkt1)
        verify_packets(self, eth_pkt1, [self.dev_port24])

        print("Sending Test packet EthType:0x%lx port 25 -> port 24" % (
            eth_pkt2[Ether].type))
        send_packet(self, self.dev_port25, eth_pkt2)
        verify_packets(self, eth_pkt2, [self.dev_port24])

        print("Sending Test packet EthType:0x%lx port 25 -> port 24" % (
            eth_pkt3[Ether].type))
        send_packet(self, self.dev_port25, eth_pkt3)
        verify_packets(self, eth_pkt3, [self.dev_port24])

        print("Sending Test packet EthType:0x%lx port 25 -> port 24" % (
            eth_pkt4[Ether].type))
        send_packet(self, self.dev_port25, eth_pkt4)
        verify_packets(self, eth_pkt4, [self.dev_port24])

        print("Sending Test(negative test) packet EthType:0x%lx port 25 -> "
              "port 24" % (neg_test_pkt[Ether].type))
        send_packet(self, self.dev_port25, neg_test_pkt)
        verify_packets(self, neg_test_pkt, [self.dev_port24])

        # setup ACL to redirect based on Ether type
        entry_priority = 1
        acl_action = SAI_ACL_ENTRY_ATTR_ACTION_REDIRECT

        # setup ACL table group
        group_bind_point_list = [SAI_ACL_BIND_POINT_TYPE_SWITCH]
        group_type = SAI_ACL_TABLE_GROUP_TYPE_PARALLEL
        group_stage_ingress = SAI_ACL_STAGE_INGRESS
        group_member_priority = 100

        # setup ACL table
        table_stage_ingress = SAI_ACL_STAGE_INGRESS
        table_bind_point_list = [SAI_ACL_BIND_POINT_TYPE_SWITCH]

        group_bind_point_type_list = sai_thrift_s32_list_t(
            count=len(group_bind_point_list),
            int32list=group_bind_point_list)

        table_bind_point_type_list = sai_thrift_s32_list_t(
            count=len(table_bind_point_list),
            int32list=table_bind_point_list)

        action_type = [SAI_ACL_ACTION_TYPE_REDIRECT]
        action_type_list = sai_thrift_s32_list_t(
            count=len(action_type), int32list=action_type)

        # create ACL table group
        acl_table_group_ingress = sai_thrift_create_acl_table_group(
            self.client,
            acl_stage=group_stage_ingress,
            acl_bind_point_type_list=group_bind_point_type_list,
            type=group_type)
        self.acl_grps.append(acl_table_group_ingress)

        # Bind acl table group to switch
        sai_thrift_set_switch_attribute(
            self.client, ingress_acl=acl_table_group_ingress)

        # create ACL tables
        print("Create ACL tables")
        acl_table_id_ingress = sai_thrift_create_acl_table(
            self.client,
            acl_stage=table_stage_ingress,
            field_src_mac=True,
            field_dst_mac=True,
            field_ether_type=True,
            field_in_port=True,
            acl_action_type_list=action_type_list,
            acl_bind_point_type_list=table_bind_point_type_list)

        self.acl_tables.append(acl_table_id_ingress)
        self.assertTrue((acl_table_id_ingress != 0),
                        "ACL table create failed")
        print("IPV4 ACL Table created 0x%lx" % (acl_table_id_ingress))

        # create ACL table group members
        acl_group_member_id_ingress = \
            sai_thrift_create_acl_table_group_member(
                self.client,
                acl_table_group_id=acl_table_group_ingress,
                acl_table_id=acl_table_id_ingress,
                priority=group_member_priority)

        self.assertTrue(acl_group_member_id_ingress != 0,
                        "ACL group member add failed for ACL table 0x%lx, "
                        "acl group 0x%lx" % (
                            acl_table_id_ingress, acl_table_group_ingress))
        self.acl_grp_members.append(acl_group_member_id_ingress)

        eth_type = 0x8137 - 0x10000

        ether_type = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(u16=eth_type),
            mask=sai_thrift_acl_field_data_mask_t(u16=32767))

        redirect_action = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                s32=acl_action,
                oid=self.port26))

        src_mac_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(mac='00:06:07:08:09:0a'),
            mask=sai_thrift_acl_field_data_mask_t(mac='ff:ff:ff:ff:ff:ff'))

        dst_mac_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(mac=self.mac),
            mask=sai_thrift_acl_field_data_mask_t(mac='ff:ff:ff:ff:ff:ff'))

        in_port_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(oid=self.port25))

        # create ACL entries
        print("Create ACL entries")
        acl_ip_entry_id_ingress1 = sai_thrift_create_acl_entry(
            self.client,
            table_id=acl_table_id_ingress,
            priority=entry_priority,
            field_src_mac=src_mac_t,
            field_dst_mac=dst_mac_t,
            field_ether_type=ether_type,
            field_in_port=in_port_t,
            action_redirect=redirect_action)

        # create ACL counter
        acl_counter_ingress1 = sai_thrift_create_acl_counter(
            self.client, table_id=acl_table_id_ingress)

        # attach ACL counter to ACL entry
        action_counter_ingress1 = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=acl_counter_ingress1),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, acl_ip_entry_id_ingress1,
            action_counter=action_counter_ingress1)

        self.counters.append(acl_counter_ingress1)
        self.action_counters.append(action_counter_ingress1)

        self.acl_rules.append(acl_ip_entry_id_ingress1)
        self.assertTrue((acl_ip_entry_id_ingress1 != 0), 'ACL entry Match: '
                        'EthType-0x%lx Action: Redirect-0x%lx, create '
                        'failed for ACL table 0x%lx' % (
                            eth_type, self.port26, acl_table_id_ingress))
        print("ACL entry Match: EthType-0x%lx Action: Redirect-0x%lx "
              "created 0x%lx" % (eth_pkt1[Ether].type, self.port26,
                                 acl_ip_entry_id_ingress1))

        entry_priority += 1
        eth_type = 0x8136 - 0x10000

        ether_type = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(u16=eth_type),
            mask=sai_thrift_acl_field_data_mask_t(u16=32767))

        redirect_action = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                s32=acl_action,
                oid=self.lag_id))

        acl_ip_entry_id_ingress2 = sai_thrift_create_acl_entry(
            self.client,
            table_id=acl_table_id_ingress,
            priority=entry_priority,
            field_src_mac=src_mac_t,
            field_dst_mac=dst_mac_t,
            field_ether_type=ether_type,
            field_in_port=in_port_t,
            action_redirect=redirect_action)

        # create ACL counter
        acl_counter_ingress2 = sai_thrift_create_acl_counter(
            self.client, table_id=acl_table_id_ingress)

        # attach ACL counter to ACL entry
        action_counter_ingress2 = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=acl_counter_ingress2),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, acl_ip_entry_id_ingress2,
            action_counter=action_counter_ingress2)

        self.counters.append(acl_counter_ingress2)
        self.action_counters.append(action_counter_ingress2)

        self.acl_rules.append(acl_ip_entry_id_ingress2)
        self.assertTrue((acl_ip_entry_id_ingress2 != 0), 'ACL entry Match: '
                        'EthType-0x%lx Action: Redirect-0x%lx, create '
                        'failed for ACL table 0x%lx' % (
                            eth_type, self.lag_id, acl_table_id_ingress))
        print("ACL entry Match: EthType-0x%lx Action: Redirect-0x%lx "
              "created 0x%lx" % (eth_pkt2[Ether].type, self.lag_id,
                                 acl_ip_entry_id_ingress2))

        # create ACL table group members
        acl_group_member_id_ingress = \
            sai_thrift_create_acl_table_group_member(
                self.client,
                acl_table_group_id=acl_table_group_ingress,
                acl_table_id=acl_table_id_ingress,
                priority=200)

        self.assertTrue(acl_group_member_id_ingress != 0,
                        "ACL group member add failed for ACL table 0x%lx, "
                        "ACL group 0x%lx" % (
                            acl_table_id_ingress, acl_table_group_ingress))
        self.acl_grp_members.append(acl_group_member_id_ingress)

        entry_priority += 1
        eth_type = 0x8135 - 0x10000

        ether_type = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(u16=eth_type),
            mask=sai_thrift_acl_field_data_mask_t(u16=32767))

        redirect_action = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                s32=acl_action,
                oid=self.port26))

        print("Create ACL entries")
        acl_ip_entry_id_ingress3 = sai_thrift_create_acl_entry(
            self.client,
            table_id=acl_table_id_ingress,
            priority=entry_priority,
            field_src_mac=src_mac_t,
            field_dst_mac=dst_mac_t,
            field_ether_type=ether_type,
            field_in_port=in_port_t,
            action_redirect=redirect_action)

        # create ACL counter
        acl_counter_ingress3 = sai_thrift_create_acl_counter(
            self.client, table_id=acl_table_id_ingress)

        # attach ACL counter to ACL entry
        action_counter_ingress3 = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=acl_counter_ingress3),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, acl_ip_entry_id_ingress3,
            action_counter=action_counter_ingress3)

        self.counters.append(acl_counter_ingress3)
        self.action_counters.append(action_counter_ingress3)

        self.acl_rules.append(acl_ip_entry_id_ingress3)
        self.assertTrue((acl_ip_entry_id_ingress3 != 0), 'ACL entry Match: '
                        'EthType-0x%lx Action: Redirect-0x%lx, create '
                        'failed for acl table 0x%lx' % (
                            eth_type, self.port26, acl_table_id_ingress))
        print("ACL entry Match: EthType-0x%lx Action: Redirect-0x%lx "
              "created 0x%lx" % (eth_pkt3[Ether].type, self.port26,
                                 acl_ip_entry_id_ingress3))

        entry_priority += 1
        eth_type = 0x8134 - 0x10000

        ether_type = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(u16=eth_type),
            mask=sai_thrift_acl_field_data_mask_t(u16=32767))

        redirect_action = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                s32=acl_action,
                oid=self.lag_id))

        print("Create ACL entries")
        acl_ip_entry_id_ingress4 = sai_thrift_create_acl_entry(
            self.client,
            table_id=acl_table_id_ingress,
            priority=entry_priority,
            field_src_mac=src_mac_t,
            field_dst_mac=dst_mac_t,
            field_ether_type=ether_type,
            field_in_port=in_port_t,
            action_redirect=redirect_action)

        # create ACL counter
        acl_counter_ingress4 = sai_thrift_create_acl_counter(
            self.client, table_id=acl_table_id_ingress)

        # attach ACL counter to ACL entry
        action_counter_ingress4 = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=acl_counter_ingress4),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, acl_ip_entry_id_ingress4,
            action_counter=action_counter_ingress4)

        self.counters.append(acl_counter_ingress4)
        self.action_counters.append(action_counter_ingress4)

        self.acl_rules.append(acl_ip_entry_id_ingress4)
        self.assertTrue((acl_ip_entry_id_ingress4 != 0), 'ACL entry Match: '
                        'EthType-0x%lx Action: Redirect-0x%lx, create '
                        'failed for ACL table 0x%lx' % (
                            eth_type, self.lag_id, acl_table_id_ingress))
        print("ACL entry Match: EthType-0x%lx Action: Redirect-0x%lx "
              "created 0x%lx" % (eth_pkt4[Ether].type, self.lag_id,
                                 acl_ip_entry_id_ingress4))

        print("Sending Test packet EthType:0x%lx port 25 -> [ACL REDIRECT] "
              "-> port 26" % (eth_pkt1[Ether].type))
        # ensure packet is redirected!
        send_packet(self, self.dev_port25, eth_pkt1)
        verify_packets(self, eth_pkt1, [self.dev_port26])

        packets1 = sai_thrift_get_acl_counter_attribute(
            self.client, acl_counter_ingress1, packets=True)
        self.assertEqual(packets1['packets'], 1)
        packets2 = sai_thrift_get_acl_counter_attribute(
            self.client, acl_counter_ingress2, packets=True)
        self.assertEqual(packets2['packets'], 0)
        packets3 = sai_thrift_get_acl_counter_attribute(
            self.client, acl_counter_ingress3, packets=True)
        self.assertEqual(packets3['packets'], 0)
        packets4 = sai_thrift_get_acl_counter_attribute(
            self.client, acl_counter_ingress4, packets=True)
        self.assertEqual(packets4['packets'], 0)

        # ensure packet is redirected!
        print("Sending Test packet EthType:0x%lx port 25 -> [ACL REDIRECT] "
              "-> Lag1 (Port 26/Port 27)" % (eth_pkt2[Ether].type))
        send_packet(self, self.dev_port25, eth_pkt2)
        verify_packets_any(self, eth_pkt2, [self.dev_port27,
                                            self.dev_port28])

        packets1 = sai_thrift_get_acl_counter_attribute(
            self.client, acl_counter_ingress1, packets=True)
        self.assertEqual(packets1['packets'], 1)
        packets2 = sai_thrift_get_acl_counter_attribute(
            self.client, acl_counter_ingress2, packets=True)
        self.assertEqual(packets2['packets'], 1)
        packets3 = sai_thrift_get_acl_counter_attribute(
            self.client, acl_counter_ingress3, packets=True)
        self.assertEqual(packets3['packets'], 0)
        packets4 = sai_thrift_get_acl_counter_attribute(
            self.client, acl_counter_ingress4, packets=True)
        self.assertEqual(packets4['packets'], 0)

        # ensure packet is redirected!
        print("Sending Test packet EthType:0x%lx port 25 -> [ACL REDIRECT] "
              "-> port 26" % (eth_pkt3[Ether].type))
        send_packet(self, self.dev_port25, eth_pkt3)
        verify_packets(self, eth_pkt3, [self.dev_port26])

        packets1 = sai_thrift_get_acl_counter_attribute(
            self.client, acl_counter_ingress1, packets=True)
        self.assertEqual(packets1['packets'], 1)
        packets2 = sai_thrift_get_acl_counter_attribute(
            self.client, acl_counter_ingress2, packets=True)
        self.assertEqual(packets2['packets'], 1)
        packets3 = sai_thrift_get_acl_counter_attribute(
            self.client, acl_counter_ingress3, packets=True)
        self.assertEqual(packets3['packets'], 1)
        packets4 = sai_thrift_get_acl_counter_attribute(
            self.client, acl_counter_ingress4, packets=True)
        self.assertEqual(packets4['packets'], 0)

        # ensure packet is redirected!
        print("Sending Test packet EthType:0x%lx port 25 -> [ACL REDIRECT] "
              "-> Lag1 (Port 27/Port 28)" % (eth_pkt4[Ether].type))
        send_packet(self, self.dev_port25, eth_pkt4)
        verify_packets_any(self, eth_pkt4, [self.dev_port27,
                                            self.dev_port28])

        packets1 = sai_thrift_get_acl_counter_attribute(
            self.client, acl_counter_ingress1, packets=True)
        self.assertEqual(packets1['packets'], 1)
        packets2 = sai_thrift_get_acl_counter_attribute(
            self.client, acl_counter_ingress2, packets=True)
        self.assertEqual(packets2['packets'], 1)
        packets3 = sai_thrift_get_acl_counter_attribute(
            self.client, acl_counter_ingress3, packets=True)
        self.assertEqual(packets3['packets'], 1)
        packets4 = sai_thrift_get_acl_counter_attribute(
            self.client, acl_counter_ingress4, packets=True)
        self.assertEqual(packets4['packets'], 1)

        # ensure packet is not redirected!
        print("Sending Test(negative test) packet EthType:0x%lx port 25 -> "
              "port 24" % (neg_test_pkt[Ether].type))
        send_packet(self, self.dev_port25, neg_test_pkt)
        verify_packets(self, neg_test_pkt, [self.dev_port24])

        packets1 = sai_thrift_get_acl_counter_attribute(
            self.client, acl_counter_ingress1, packets=True)
        self.assertEqual(packets1['packets'], 1)
        packets2 = sai_thrift_get_acl_counter_attribute(
            self.client, acl_counter_ingress2, packets=True)
        self.assertEqual(packets2['packets'], 1)
        packets3 = sai_thrift_get_acl_counter_attribute(
            self.client, acl_counter_ingress3, packets=True)
        self.assertEqual(packets3['packets'], 1)
        packets4 = sai_thrift_get_acl_counter_attribute(
            self.client, acl_counter_ingress4, packets=True)
        self.assertEqual(packets4['packets'], 1)

        # Test Redirect Nexthop
        pkt = simple_tcp_packet(eth_dst=ROUTER_MAC,
                                eth_src="00:00:00:00:00:22",
                                ip_src="192.168.0.1",
                                ip_dst="11.1.1.1",
                                ip_id=101,
                                ip_ttl=64)

        exp_pkt = simple_tcp_packet(eth_dst=self.neighbor_dmac11,
                                    eth_src=ROUTER_MAC,
                                    ip_src="192.168.0.1",
                                    ip_dst="11.1.1.1",
                                    ip_id=101,
                                    ip_ttl=63)

        print("Sending L3 Test packet Port 10 -> Port 11")
        send_packet(self, self.dev_port10, pkt)
        verify_packet(self, exp_pkt, self.dev_port11)
        print("Sending L3 Test packet Port 13 -> Port 11")
        send_packet(self, self.dev_port13, pkt)
        verify_packet(self, exp_pkt, self.dev_port11)

        # setup ACL entry
        src_v4 = '192.168.0.1'
        src_ip_mask = '255.255.255.255'
        src_ip_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(ip4=src_v4),
            mask=sai_thrift_acl_field_data_mask_t(ip4=src_ip_mask))

        dst_v4 = '11.1.1.1'
        dst_ip_mask = '255.255.255.255'
        dst_ip_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(ip4=dst_v4),
            mask=sai_thrift_acl_field_data_mask_t(ip4=dst_ip_mask))

        in_port_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(oid=self.port10))

        # redirect to nhop12 (port12) instead of nhop11 (port11)
        redirect_action = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                s32=acl_action,
                oid=self.nhop12))

        print("Create L3 ACL entries")
        entry_priority += 1
        acl_ip_entry_id_ingress5 = sai_thrift_create_acl_entry(
            self.client,
            table_id=acl_table_id_ingress,
            priority=entry_priority,
            field_src_ip=src_ip_t,
            field_dst_ip=dst_ip_t,
            field_in_port=in_port_t,
            action_redirect=redirect_action)

        # create ACL counter
        acl_counter_ingress5 = sai_thrift_create_acl_counter(
            self.client, table_id=acl_table_id_ingress)

        # attach ACL counter to ACL entry
        action_counter_ingress5 = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=acl_counter_ingress5),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, acl_ip_entry_id_ingress5,
            action_counter=action_counter_ingress5)

        self.counters.append(acl_counter_ingress5)
        self.action_counters.append(action_counter_ingress5)

        self.acl_rules.append(acl_ip_entry_id_ingress5)
        self.assertTrue((acl_ip_entry_id_ingress5 != 0), 'ACL entry Match: '
                        'Action: Redirect Nhop-0x%lx, create '
                        'failed for ACL table 0x%lx' % (
                            self.nhop12,
                            acl_table_id_ingress))
        print("ACL entry Match: Action: Redirect Nhop-0x%lx "
              "created 0x%lx" % (self.nhop12,
                                 acl_ip_entry_id_ingress5))

        redirect_pkt = exp_pkt.copy()
        redirect_pkt[Ether].dst = self.neighbor_dmac12
        print("Sending L3 Test packet Port 10 -> Port 11"
              "  Redirect to Port 12 instead")
        send_packet(self, self.dev_port10, pkt)
        verify_packet(self, redirect_pkt, self.dev_port12)

        # ensure packet from different port is not redirected
        print("Sending L3 Test packet Port 13 -> Port 11"
              "  does NOT Redirect to Port 12")
        send_packet(self, self.dev_port13, pkt)
        verify_packet(self, exp_pkt, self.dev_port11)
        verify_no_other_packets(self, timeout=2)

        # ECMP test
        dst_v4 = '12.1.1.1'
        dst_ip_mask = '255.255.255.255'
        dst_ip_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(ip4=dst_v4),
            mask=sai_thrift_acl_field_data_mask_t(ip4=dst_ip_mask))

        in_port_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(oid=self.port10))

        # redirect to nhop12 (port12) instead of nhop11 (port11)
        redirect_action = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                s32=acl_action,
                oid=self.nhop_group))

        print("Create L3 ACL entries")
        entry_priority += 1
        acl_ip_entry_id_ingress6 = sai_thrift_create_acl_entry(
            self.client,
            table_id=acl_table_id_ingress,
            priority=entry_priority,
            field_src_ip=src_ip_t,
            field_dst_ip=dst_ip_t,
            field_in_port=in_port_t,
            action_redirect=redirect_action)

        # create ACL counter
        acl_counter_ingress6 = sai_thrift_create_acl_counter(
            self.client, table_id=acl_table_id_ingress)

        # attach ACL counter to ACL entry
        action_counter_ingress6 = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=acl_counter_ingress6),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, acl_ip_entry_id_ingress6,
            action_counter=action_counter_ingress6)

        self.counters.append(acl_counter_ingress6)
        self.action_counters.append(action_counter_ingress6)

        self.acl_rules.append(acl_ip_entry_id_ingress6)
        self.assertTrue((acl_ip_entry_id_ingress6 != 0), 'ACL entry Match: '
                        'Action: Redirect Nhop-0x%lx, create '
                        'failed for ACL table 0x%lx' % (
                            self.nhop12,
                            acl_table_id_ingress))
        print("ACL entry Match: Action: Redirect Nhop-0x%lx "
              "created 0x%lx" % (self.nhop12,
                                 acl_ip_entry_id_ingress6))

        pkt = simple_tcp_packet(eth_dst=ROUTER_MAC,
                                eth_src="00:00:00:00:00:22",
                                ip_src="192.168.0.1",
                                ip_dst="12.1.1.1",
                                ip_id=101,
                                ip_ttl=64)

        exp_pkt = simple_tcp_packet(eth_dst=self.neighbor_dmac12,
                                    eth_src=ROUTER_MAC,
                                    ip_src="192.168.0.1",
                                    ip_dst="12.1.1.1",
                                    ip_id=101,
                                    ip_ttl=63)

        redir_pkt = Mask(simple_tcp_packet(eth_dst=self.neighbor_dmac11,
                                           eth_src=ROUTER_MAC,
                                           ip_src="192.168.0.1",
                                           ip_dst="12.1.1.1",
                                           ip_id=101,
                                           ip_ttl=63))
        redir_pkt.set_do_not_care_scapy(Ether, 'dst')
        redir_pkt.set_do_not_care_scapy(Ether, 'src')

        print("Sending L3 Test packet Port 10 -> Port 12"
              "  Redirect to Port 11 OR Port 13 (ECMP)")
        send_packet(self, self.dev_port10, pkt)
        verify_packet_any_port(self, redir_pkt,
                               [self.dev_port11, self.dev_port13])
        verify_no_other_packets(self, timeout=2)

        # ensure packet from different port is not redirected
        print("Sending L3 Test packet Port 14 -> Port 12"
              "  does NOT Redirect to any other port")
        send_packet(self, self.dev_port14, pkt)
        verify_packet(self, exp_pkt, self.dev_port12)
        verify_no_other_packets(self, timeout=2)

    def tearDown(self):
        # Clean up ACL configuration
        sai_thrift_set_switch_attribute(
            self.client, ingress_acl=int(SAI_NULL_OBJECT_ID))

        for acl_grp_member in list(self.acl_grp_members):
            sai_thrift_remove_acl_table_group_member(self.client,
                                                     acl_grp_member)
            self.acl_grp_members.remove(acl_grp_member)

        for acl_grp in list(self.acl_grps):
            sai_thrift_remove_acl_table_group(self.client, acl_grp)
            self.acl_grps.remove(acl_grp)

        for i, acl_action_counter in enumerate(self.action_counters):
            acl_action_counter = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=0),
                enable=True)
            sai_thrift_set_acl_entry_attribute(
                self.client, self.acl_rules[i],
                action_counter=acl_action_counter)

        for acl_counter in self.counters:
            sai_thrift_set_acl_counter_attribute(
                self.client, acl_counter, packets=None)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter, packets=True)
            self.assertEqual(packets['packets'], 0)
            sai_thrift_remove_acl_counter(self.client, acl_counter)

        for acl_rule in list(self.acl_rules):
            sai_thrift_remove_acl_entry(self.client, acl_rule)
            self.acl_rules.remove(acl_rule)

        for acl_table in list(self.acl_tables):
            sai_thrift_remove_acl_table(self.client, acl_table)
            self.acl_tables.remove(acl_table)

        for fdb in list(self.fdbs):
            sai_thrift_remove_fdb_entry(self.client, fdb)
            self.fdbs.remove(fdb)

        # Clean up network configuration
        sai_thrift_set_port_attribute(
            self.client, self.port24, port_vlan_id=int(SAI_NULL_OBJECT_ID))
        sai_thrift_set_port_attribute(
            self.client, self.port25, port_vlan_id=int(SAI_NULL_OBJECT_ID))
        sai_thrift_set_port_attribute(
            self.client, self.port26, port_vlan_id=int(SAI_NULL_OBJECT_ID))

        for vlan_member in list(self.vlan_members):
            sai_thrift_remove_vlan_member(self.client, vlan_member)
            self.vlan_members.remove(vlan_member)
        sai_thrift_remove_vlan(self.client, self.vlan_oid)
        for lag_member in list(self.lag_members):
            sai_thrift_remove_lag_member(self.client, lag_member)
            self.lag_members.remove(lag_member)
        for port in list(self.bridge_ports):
            sai_thrift_remove_bridge_port(self.client, port)
            self.bridge_ports.remove(port)
        for lag in list(self.lags):
            sai_thrift_remove_lag(self.client, lag)
            self.lags.remove(lag)
        for vlan_port in list(self.vlan_ports):
            self.vlan_ports.remove(vlan_port)

        time.sleep(2)
        sai_thrift_remove_next_hop_group_member(self.client,
                                                self.nhop_group_mmbr1)
        sai_thrift_remove_next_hop_group_member(self.client,
                                                self.nhop_group_mmbr2)
        sai_thrift_remove_next_hop_group(self.client, self.nhop_group)
        sai_thrift_remove_route_entry(self.client, self.route11)
        sai_thrift_remove_next_hop(self.client, self.nhop11)
        sai_thrift_remove_neighbor_entry(self.client, self.neighbor_entry11)
        sai_thrift_remove_route_entry(self.client, self.route12)
        sai_thrift_remove_next_hop(self.client, self.nhop12)
        sai_thrift_remove_neighbor_entry(self.client, self.neighbor_entry12)
        sai_thrift_remove_route_entry(self.client, self.route13)
        sai_thrift_remove_next_hop(self.client, self.nhop13)
        sai_thrift_remove_neighbor_entry(self.client, self.neighbor_entry13)
        sai_thrift_remove_virtual_router(self.client, self.vr_id)
        super(L2RedirectPortAndLagTest, self).tearDown()


@group('acl2')
class AclPbrTest(SaiHelper):
    """
    Verify ACL redirection for ports and lags test cases
    """
    def setUp(self):
        super(AclPbrTest, self).setUp()
        self.acl_entries = []
        self.acl_counters = []

        # L2 configuration
        self.port1_mac = '00:01:01:01:01:01'
        mac_action = SAI_PACKET_ACTION_FORWARD

        self.fdb_entry = sai_thrift_fdb_entry_t(
            switch_id=self.switch_id,
            mac_address=self.port1_mac,
            bv_id=self.vlan10)

        sai_thrift_create_fdb_entry(
            self.client,
            self.fdb_entry,
            type=SAI_FDB_ENTRY_TYPE_STATIC,
            bridge_port_id=self.lag1_bp,
            packet_action=mac_action)

        # L3 configuration
        self.vr_id = sai_thrift_create_virtual_router(self.client,
                                                      admin_v4_state=True,
                                                      admin_v6_state=True)
        # egress RIF port11
        dst_ip = "11.1.1.1"
        dst_mask_ip = "11.1.1.1/24"
        self.neighbor_dmac11 = "00:11:11:11:11:11"
        self.neighbor_entry11 = sai_thrift_neighbor_entry_t(
            self.switch_id,
            self.port11_rif,
            sai_ipaddress(dst_ip))
        sai_thrift_create_neighbor_entry(self.client,
                                         self.neighbor_entry11,
                                         dst_mac_address=self.neighbor_dmac11)

        self.nhop11 = sai_thrift_create_next_hop(
            self.client,
            type=SAI_NEXT_HOP_TYPE_IP,
            router_interface_id=self.port11_rif,
            ip=sai_ipaddress(dst_ip))

        # Route configuration
        self.route11 = sai_thrift_route_entry_t(
            switch_id=self.switch_id,
            destination=sai_ipprefix(dst_mask_ip),
            vr_id=self.vr_id)
        status = sai_thrift_create_route_entry(self.client,
                                               self.route11,
                                               next_hop_id=self.nhop11)

        # egress RIF port12
        dst_ip = "12.1.1.1"
        dst_mask_ip = "12.1.1.1/24"
        self.neighbor_dmac12 = "00:12:12:12:12:12"
        self.neighbor_entry12 = sai_thrift_neighbor_entry_t(
            self.switch_id,
            self.port12_rif,
            sai_ipaddress(dst_ip))
        sai_thrift_create_neighbor_entry(
            self.client,
            self.neighbor_entry12,
            dst_mac_address=self.neighbor_dmac12)

        self.nhop12 = sai_thrift_create_next_hop(
            self.client,
            type=SAI_NEXT_HOP_TYPE_IP,
            router_interface_id=self.port12_rif,
            ip=sai_ipaddress(dst_ip))

        # Route configuration
        self.route12 = sai_thrift_route_entry_t(
            switch_id=self.switch_id,
            destination=sai_ipprefix(dst_mask_ip),
            vr_id=self.vr_id)
        status = sai_thrift_create_route_entry(self.client,
                                               self.route12,
                                               next_hop_id=self.nhop12)

        # egress RIF port13
        dst_ipv6 = "6666::7777"
        dst_mask_ipv6 = "6666::7777/128"
        self.neighbor_dmac13 = "00:13:13:13:13:13"
        self.neighbor_entry13 = sai_thrift_neighbor_entry_t(
            self.switch_id,
            self.port13_rif,
            sai_ipaddress(dst_ipv6))
        sai_thrift_create_neighbor_entry(
            self.client,
            self.neighbor_entry13,
            dst_mac_address=self.neighbor_dmac13)

        self.nhop13 = sai_thrift_create_next_hop(
            self.client,
            type=SAI_NEXT_HOP_TYPE_IP,
            router_interface_id=self.port13_rif,
            ip=sai_ipaddress(dst_ipv6))

        # Route configuration
        self.route13 = sai_thrift_route_entry_t(
            switch_id=self.switch_id,
            destination=sai_ipprefix(dst_mask_ipv6),
            vr_id=self.vr_id)
        status = sai_thrift_create_route_entry(self.client,
                                               self.route13,
                                               next_hop_id=self.nhop13)

        # check L2 traffic
        eth_pkt = simple_eth_packet(pktlen=100,
                                    eth_dst=self.port1_mac,
                                    eth_src='00:06:07:08:09:0a')

        self.lag1_ports = [self.dev_port4, self.dev_port5, self.dev_port6]

        print("Sending L2 Test packet port0 -> lag1")
        send_packet(self, self.dev_port0, eth_pkt)
        verify_packet_any_port(self, eth_pkt, self.lag1_ports)

        # check L3 traffic
        pkt = simple_udp_packet(eth_dst=ROUTER_MAC,
                                eth_src="00:00:00:00:00:22",
                                ip_src="192.168.0.1",
                                ip_dst="11.1.1.1",
                                ip_ttl=64)

        exp_pkt = simple_udp_packet(eth_dst=self.neighbor_dmac11,
                                    eth_src=ROUTER_MAC,
                                    ip_src="192.168.0.1",
                                    ip_dst="11.1.1.1",
                                    ip_ttl=63)

        print("Sending L3 Test packet Port 10 -> Port 11")
        send_packet(self, self.dev_port10, pkt)
        verify_packet(self, exp_pkt, self.dev_port11)

    def runTest(self):
        print("Testing AclPbrTest")
        print('-------------------------------------------------------------')
        self.configAclPbrTest()
        self.runAclPbrTest()
        self.cleanupAclPbrTest()

    def configAclPbrTest(self):

        # setup ACL table group
        group_stage = SAI_ACL_STAGE_INGRESS
        group_bpoints = [SAI_ACL_BIND_POINT_TYPE_SWITCH]
        group_bpoint_type_list = sai_thrift_s32_list_t(
            count=len(group_bpoints), int32list=group_bpoints)
        group_type = SAI_ACL_TABLE_GROUP_TYPE_PARALLEL

        # create ACL table group
        self.acl_table_group = sai_thrift_create_acl_table_group(
            self.client,
            acl_stage=group_stage,
            acl_bind_point_type_list=group_bpoint_type_list,
            type=group_type)

        # setup ACL table
        ranges = [SAI_ACL_RANGE_TYPE_L4_SRC_PORT_RANGE,
                  SAI_ACL_RANGE_TYPE_L4_DST_PORT_RANGE]
        ranges_list = sai_thrift_s32_list_t(count=len(ranges),
                                            int32list=ranges)

        table_bpoints = [SAI_ACL_BIND_POINT_TYPE_SWITCH]
        table_bpoint_type_list = sai_thrift_s32_list_t(
            count=len(table_bpoints),
            int32list=table_bpoints)

        # create ACL table
        self.acl_table = sai_thrift_create_acl_table(
            self.client,
            acl_stage=SAI_ACL_STAGE_INGRESS,
            acl_bind_point_type_list=table_bpoint_type_list,
            field_src_ip=True,
            field_dst_ip=True,
            field_src_ipv6=True,
            field_dst_ipv6=True,
            field_dscp=True,
            field_ecn=True,
            field_ipv6_next_header=True,
            field_l4_src_port=True,
            field_l4_dst_port=True,
            field_tcp_flags=True,
            field_acl_range_type=ranges_list,
            field_icmp_type=True,
            field_icmp_code=True,
            field_icmpv6_type=True,
            field_icmpv6_code=True,
            field_in_port=True)

        # create ACL table group member
        self.acl_table_group_member = sai_thrift_create_acl_table_group_member(
            self.client,
            acl_table_group_id=self.acl_table_group,
            acl_table_id=self.acl_table)

        # Bind acl table group to switch
        sai_thrift_set_switch_attribute(
            self.client, ingress_acl=self.acl_table_group)

        # setup L2 ACL entry
        ether_type_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(u16=0x0800),
            mask=sai_thrift_acl_field_data_mask_t(u16=32767))

        src_mac_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(mac='00:06:07:08:09:0a'),
            mask=sai_thrift_acl_field_data_mask_t(mac='ff:ff:ff:ff:ff:ff'))

        dst_mac_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(mac=self.port1_mac),
            mask=sai_thrift_acl_field_data_mask_t(mac='ff:ff:ff:ff:ff:ff'))

        in_port_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(oid=self.port0))

        # action is redirect to port 1 (tagged)
        redirect_action = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                s32=SAI_ACL_ENTRY_ATTR_ACTION_REDIRECT,
                oid=self.port1))

        # create L2 ACL entry
        acl_entry_priority = 1
        self.acl_entry_l2 = sai_thrift_create_acl_entry(
            self.client,
            table_id=self.acl_table,
            priority=acl_entry_priority,
            field_src_mac=src_mac_t,
            field_dst_mac=dst_mac_t,
            field_ether_type=ether_type_t,
            field_in_port=in_port_t,
            action_redirect=redirect_action)

        # create ACL counter
        self.acl_counter_l2 = sai_thrift_create_acl_counter(
            self.client, table_id=self.acl_table)

        # attach ACL counter to ACL entry
        action_counter_t = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=self.acl_counter_l2),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, self.acl_entry_l2,
            action_counter=action_counter_t)

        # setup v4 TCP ACL entry
        src_v4 = '192.168.0.1'
        src_ip_mask = '255.255.255.255'
        src_ip_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(ip4=src_v4),
            mask=sai_thrift_acl_field_data_mask_t(ip4=src_ip_mask))

        dst_v4 = '11.1.1.1'
        dst_ip_mask = '255.255.255.255'
        dst_ip_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(ip4=dst_v4),
            mask=sai_thrift_acl_field_data_mask_t(ip4=dst_ip_mask))

        dscp_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(u8=15),
            mask=sai_thrift_acl_field_data_mask_t(u8=127))

        # tcp_flags = 'SA'
        tcp_flags_t = sai_thrift_acl_field_data_t(
            enable=True,
            mask=sai_thrift_acl_field_data_mask_t(u8=127),
            data=sai_thrift_acl_field_data_data_t(u8=0x12))

        # sport is 4444
        u32range = sai_thrift_u32_range_t(min=4000, max=5000)
        acl_range1 = sai_thrift_create_acl_range(
            self.client,
            type=SAI_ACL_RANGE_TYPE_L4_SRC_PORT_RANGE,
            limit=u32range)

        # dport is 8888
        u32range = sai_thrift_u32_range_t(min=8000, max=9000)
        acl_range2 = sai_thrift_create_acl_range(
            self.client,
            type=SAI_ACL_RANGE_TYPE_L4_DST_PORT_RANGE,
            limit=u32range)
        range_list = [acl_range1, acl_range2]

        range_list_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(
                objlist=sai_thrift_object_list_t(
                    count=len(range_list),
                    idlist=range_list)))

        # L3 in-port is Port10
        in_port_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(oid=self.port10))

        # action is redirect to Port12
        redirect_action = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                s32=SAI_ACL_ENTRY_ATTR_ACTION_REDIRECT,
                oid=self.port12))

        # create v4 TCP ACL entry
        self.acl_entry_v4_tcp = sai_thrift_create_acl_entry(
            self.client,
            table_id=self.acl_table,
            field_src_ip=src_ip_t,
            field_dst_ip=dst_ip_t,
            field_dscp=dscp_t,
            field_tcp_flags=tcp_flags_t,
            field_acl_range_type=range_list_t,
            field_in_port=in_port_t,
            action_redirect=redirect_action)

        # create ACL counter
        self.acl_counter_v4_tcp = sai_thrift_create_acl_counter(
            self.client, table_id=self.acl_table)

        # attach ACL counter to ACL entry
        action_counter_t = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=self.acl_counter_v4_tcp),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, self.acl_entry_v4_tcp,
            action_counter=action_counter_t)

        # setup v4 ICMP ACL entry
        icmp_type_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(u8=9),
            mask=sai_thrift_acl_field_data_mask_t(u8=127))

        icmp_code_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(u8=16),
            mask=sai_thrift_acl_field_data_mask_t(u8=127))

        ip_protocol_t = sai_thrift_acl_field_data_t(
            enable=True,
            data=sai_thrift_acl_field_data_data_t(u8=1),
            mask=sai_thrift_acl_field_data_mask_t(u8=127))

        # create v4 ICMP ACL entry
        self.acl_entry_v4_icmp = sai_thrift_create_acl_entry(
            self.client,
            table_id=self.acl_table,
            priority=20,
            field_src_ip=src_ip_t,
            field_dst_ip=dst_ip_t,
            field_ip_protocol=ip_protocol_t,
            field_icmp_type=icmp_type_t,
            field_icmp_code=icmp_code_t,
            field_in_port=in_port_t,
            action_redirect=redirect_action)

        # create ACL counter
        self.acl_counter_v4_icmp = sai_thrift_create_acl_counter(
            self.client, table_id=self.acl_table)

        # attach ACL counter to ACL entry
        action_counter_t = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=self.acl_counter_v4_icmp),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, self.acl_entry_v4_icmp,
            action_counter=action_counter_t)

        # setup v6 UDP ACL entry
        src_v6 = '5555::8844'
        src_ip_mask = 'FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF'
        src_ip_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(ip6=src_v6),
            mask=sai_thrift_acl_field_data_mask_t(ip6=src_ip_mask))

        dst_v6 = '6666::7777'
        dst_ip_mask = 'FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF'
        dst_ip_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(ip6=dst_v6),
            mask=sai_thrift_acl_field_data_mask_t(ip6=dst_ip_mask))

        dscp_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(u8=20),
            mask=sai_thrift_acl_field_data_mask_t(u8=127))

        ecn_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(u8=1),
            mask=sai_thrift_acl_field_data_mask_t(u8=127))

        ipv6_next_header = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(u8=17),
            mask=sai_thrift_acl_field_data_mask_t(u8=0x0F))

        l4_src_port_mask = 32759
        l4_src_port_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(u16=4444),
            mask=sai_thrift_acl_field_data_mask_t(u16=l4_src_port_mask))

        l4_dst_port_mask = 32759
        l4_dst_port_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(u16=8888),
            mask=sai_thrift_acl_field_data_mask_t(u16=l4_dst_port_mask))

        redirect_action = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                s32=SAI_ACL_ENTRY_ATTR_ACTION_REDIRECT,
                oid=self.lag3))

        # create v6 UDP ACL entry
        self.acl_entry_v6_udp = sai_thrift_create_acl_entry(
            self.client,
            table_id=self.acl_table,
            priority=30,
            field_src_ipv6=src_ip_t,
            field_dst_ipv6=dst_ip_t,
            field_dscp=dscp_t,
            field_ecn=ecn_t,
            field_ipv6_next_header=ipv6_next_header,
            field_l4_src_port=l4_src_port_t,
            field_l4_dst_port=l4_dst_port_t,
            field_in_port=in_port_t,
            action_redirect=redirect_action)

        # create ACL counter
        self.acl_counter_v6_udp = sai_thrift_create_acl_counter(
            self.client, table_id=self.acl_table)

        # attach ACL counter to ACL entry
        action_counter_t = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=self.acl_counter_v6_udp),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, self.acl_entry_v6_udp,
            action_counter=action_counter_t)

        # setup v6 ICMP ACL entry
        icmpv6_type_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(u8=5),
            mask=sai_thrift_acl_field_data_mask_t(u8=127))

        icmpv6_code_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(u8=1),
            mask=sai_thrift_acl_field_data_mask_t(u8=127))

        ipv6_next_header_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(u8=58),
            mask=sai_thrift_acl_field_data_mask_t(u8=127))

        # create v6 ICMP ACL entry
        self.acl_entry_v6_icmp = sai_thrift_create_acl_entry(
            self.client,
            table_id=self.acl_table,
            priority=40,
            field_src_ipv6=src_ip_t,
            field_dst_ipv6=dst_ip_t,
            field_ipv6_next_header=ipv6_next_header_t,
            field_icmpv6_type=icmpv6_type_t,
            field_icmpv6_code=icmpv6_code_t,
            field_in_port=in_port_t,
            action_redirect=redirect_action)

        # create ACL counter
        self.acl_counter_v6_icmp = sai_thrift_create_acl_counter(
            self.client, table_id=self.acl_table)

        # attach ACL counter to ACL entry
        action_counter_t = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=self.acl_counter_v6_icmp),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, self.acl_entry_v6_icmp,
            action_counter=action_counter_t)

    def runAclPbrTest(self):
        print("Sending L2 packet port0 -> lag1 (redirect to port1)")
        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.acl_counter_l2, packets=True)
        self.assertEqual(packets['packets'], 0)
        eth_pkt = simple_udp_packet(
            pktlen=100,
            eth_dst=self.port1_mac,
            eth_src='00:06:07:08:09:0a')
        exp_pkt = simple_udp_packet(
            pktlen=104,
            eth_dst=self.port1_mac,
            eth_src='00:06:07:08:09:0a',
            dl_vlan_enable=True,
            vlan_vid=10)
        send_packet(self, self.dev_port0, eth_pkt)
        verify_packet(self, exp_pkt, self.dev_port1)
        verify_no_other_packets(self, timeout=1)
        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.acl_counter_l2, packets=True)
        self.assertEqual(packets['packets'], 1)

        print("Sending v4 TCP packet port10 -> port11 (redirect to port12)")
        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.acl_counter_v4_tcp, packets=True)
        self.assertEqual(packets['packets'], 0)
        pkt = simple_tcp_packet(
            eth_dst=ROUTER_MAC,
            eth_src="00:00:00:00:00:22",
            ip_src="192.168.0.1",
            ip_dst="11.1.1.1",
            ip_dscp=15,
            tcp_sport=4444,
            tcp_dport=8888,
            tcp_flags='SA',
            ip_ttl=64)

        send_packet(self, self.dev_port10, pkt)
        verify_packet(self, pkt, self.dev_port12)
        verify_no_other_packets(self, timeout=1)
        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.acl_counter_v4_tcp, packets=True)
        self.assertEqual(packets['packets'], 1)

        # ensure packet from different port is not redirected
        exp_pkt = simple_tcp_packet(
            eth_dst=self.neighbor_dmac11,
            eth_src=ROUTER_MAC,
            ip_src="192.168.0.1",
            ip_dst="11.1.1.1",
            ip_dscp=15,
            tcp_sport=4444,
            tcp_dport=8888,
            tcp_flags='SA',
            ip_ttl=63)

        print("Sending v4 TCP packet Port 13 -> Port 11"
              "  does NOT redirect to Port 12")
        send_packet(self, self.dev_port13, pkt)
        verify_packet(self, exp_pkt, self.dev_port11)
        verify_no_other_packets(self, timeout=1)
        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.acl_counter_v4_tcp, packets=True)
        self.assertEqual(packets['packets'], 1)

        print("Sending v4 ICMP packet port10 -> port11 "
              "(redirect to port12)")
        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.acl_counter_v4_icmp, packets=True)
        self.assertEqual(packets['packets'], 0)
        icmp_pkt = simple_icmp_packet(
            eth_dst=ROUTER_MAC,
            ip_src="192.168.0.1",
            ip_dst="11.1.1.1",
            icmp_type=9,
            icmp_code=16)
        send_packet(self, self.dev_port10, icmp_pkt)
        verify_packet(self, icmp_pkt, self.dev_port12)
        verify_no_other_packets(self, timeout=1)
        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.acl_counter_v4_icmp, packets=True)
        self.assertEqual(packets['packets'], 1)

        print("Sending v6 UDP packet port10 -> port11 "
              "(redirect to lag3)")
        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.acl_counter_v6_udp, packets=True)
        self.assertEqual(packets['packets'], 0)
        icmp_pkt = simple_udpv6_packet(
            eth_dst=ROUTER_MAC,
            ipv6_src='5555::8844',
            ipv6_dst='6666::7777',
            ipv6_dscp=20,
            ipv6_ecn=1,
            ipv6_hlim=64,
            udp_sport=4444,
            udp_dport=8888)
        send_packet(self, self.dev_port10, icmp_pkt)
        self.lag3_ports = [self.dev_port14, self.dev_port15, self.dev_port16]
        verify_packet_any_port(self, icmp_pkt, self.lag3_ports)
        verify_no_other_packets(self, timeout=1)
        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.acl_counter_v6_udp, packets=True)
        self.assertEqual(packets['packets'], 1)

        print("Sending v6 ICMP packet port10 -> port11 "
              "(redirect to lag3)")
        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.acl_counter_v6_icmp, packets=True)
        self.assertEqual(packets['packets'], 0)
        icmp_pkt = simple_icmpv6_packet(
            eth_dst=ROUTER_MAC,
            ipv6_src='5555::8844',
            ipv6_dst='6666::7777',
            icmp_type=5,
            icmp_code=1)
        send_packet(self, self.dev_port10, icmp_pkt)
        verify_packet_any_port(self, icmp_pkt, self.lag3_ports)
        verify_no_other_packets(self, timeout=1)
        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.acl_counter_v6_icmp, packets=True)
        self.assertEqual(packets['packets'], 1)

    def cleanupAclPbrTest(self):
        # Clean up ACL configuration
        sai_thrift_set_switch_attribute(
            self.client, ingress_acl=int(SAI_NULL_OBJECT_ID))

        action_counter_t = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=0),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, self.acl_entry_l2,
            action_counter=action_counter_t)

        sai_thrift_set_acl_counter_attribute(
            self.client, self.acl_counter_l2, packets=None)
        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.acl_counter_l2, packets=True)
        self.assertEqual(packets['packets'], 0)

        sai_thrift_remove_acl_counter(self.client, self.acl_counter_l2)
        sai_thrift_remove_acl_entry(self.client, self.acl_entry_l2)

        action_counter_t = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=0),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, self.acl_entry_v4_tcp,
            action_counter=action_counter_t)

        sai_thrift_set_acl_counter_attribute(
            self.client, self.acl_counter_v4_tcp, packets=None)
        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.acl_counter_v4_tcp, packets=True)
        self.assertEqual(packets['packets'], 0)

        sai_thrift_remove_acl_counter(self.client, self.acl_counter_v4_tcp)
        sai_thrift_remove_acl_entry(self.client, self.acl_entry_v4_tcp)

        action_counter_t = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=0),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, self.acl_entry_v4_icmp,
            action_counter=action_counter_t)

        sai_thrift_set_acl_counter_attribute(
            self.client, self.acl_counter_v4_icmp, packets=None)
        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.acl_counter_v4_icmp, packets=True)
        self.assertEqual(packets['packets'], 0)

        sai_thrift_remove_acl_counter(self.client, self.acl_counter_v4_icmp)
        sai_thrift_remove_acl_entry(self.client, self.acl_entry_v4_icmp)

        action_counter_t = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=0),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, self.acl_entry_v6_udp,
            action_counter=action_counter_t)

        sai_thrift_set_acl_counter_attribute(
            self.client, self.acl_counter_v6_udp, packets=None)
        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.acl_counter_v6_udp, packets=True)
        self.assertEqual(packets['packets'], 0)

        sai_thrift_remove_acl_counter(self.client, self.acl_counter_v6_udp)
        sai_thrift_remove_acl_entry(self.client, self.acl_entry_v6_udp)

        action_counter_t = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=0),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, self.acl_entry_v6_icmp,
            action_counter=action_counter_t)

        sai_thrift_set_acl_counter_attribute(
            self.client, self.acl_counter_v6_icmp, packets=None)
        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.acl_counter_v6_icmp, packets=True)
        self.assertEqual(packets['packets'], 0)

        sai_thrift_remove_acl_counter(self.client, self.acl_counter_v6_icmp)
        sai_thrift_remove_acl_entry(self.client, self.acl_entry_v6_icmp)

        sai_thrift_remove_acl_table_group_member(
            self.client, self.acl_table_group_member)
        sai_thrift_remove_acl_table(self.client, self.acl_table)
        sai_thrift_remove_acl_table_group(self.client, self.acl_table_group)

    def tearDown(self):
        sai_thrift_remove_fdb_entry(self.client, self.fdb_entry)

        # Clean up network configuration
        sai_thrift_set_port_attribute(
            self.client, self.port24, port_vlan_id=int(SAI_NULL_OBJECT_ID))
        sai_thrift_set_port_attribute(
            self.client, self.port25, port_vlan_id=int(SAI_NULL_OBJECT_ID))
        sai_thrift_set_port_attribute(
            self.client, self.port26, port_vlan_id=int(SAI_NULL_OBJECT_ID))

        time.sleep(2)
        sai_thrift_remove_route_entry(self.client, self.route11)
        sai_thrift_remove_next_hop(self.client, self.nhop11)
        sai_thrift_remove_neighbor_entry(self.client, self.neighbor_entry11)
        sai_thrift_remove_route_entry(self.client, self.route12)
        sai_thrift_remove_next_hop(self.client, self.nhop12)
        sai_thrift_remove_neighbor_entry(self.client, self.neighbor_entry12)
        sai_thrift_remove_route_entry(self.client, self.route13)
        sai_thrift_remove_next_hop(self.client, self.nhop13)
        sai_thrift_remove_neighbor_entry(self.client, self.neighbor_entry13)
        sai_thrift_remove_virtual_router(self.client, self.vr_id)
        super(AclPbrTest, self).tearDown()


# pylint: disable=too-many-public-methods
class IngressAclTransitDenyTest(SaiHelper):
    '''
    This verifies below user acl actions
        transit --> copy cancel + forw
        deny --> copy cancel + drop]

    Tests actions in Mac, V4, V6 Ingress ACls
    Hif type incl both trap, copy
    '''

    def setUp(self):
        super(IngressAclTransitDenyTest, self).setUp()

    def runTest(self):
        hif_type = "action_trap"
        self.hif = sai_thrift_create_hostif(self.client,
                                            name=hif_type,
                                            obj_id=self.port2,
                                            type=SAI_HOSTIF_TYPE_NETDEV)
        self.assertTrue(self.hif != 0)
        self.hif_trap = open_packet_socket(hif_type)

        hif_type2 = "action-copy"
        self.hif2 = sai_thrift_create_hostif(self.client,
                                             name=hif_type2,
                                             obj_id=self.lag2,
                                             type=SAI_HOSTIF_TYPE_NETDEV)
        self.assertTrue(self.hif2 != 0)
        self.hif_copy = open_packet_socket(hif_type2)

        self.cpu_queue_state = sai_thrift_get_queue_stats(
            self.client, self.cpu_queue0)["SAI_QUEUE_STAT_PACKETS"]

        #  rif is req so that system acl l3 trap/copy entries sre hit
        #  unicast enable flag is set only when rif is config
        self.vlan20_rif = sai_thrift_create_router_interface(
                self.client,
                type=SAI_ROUTER_INTERFACE_TYPE_VLAN,
                virtual_router_id=self.default_vrf,
                vlan_id=self.vlan20)
        self.assertTrue(self.vlan20_rif != 0)

        # ACL table group
        group_stage = SAI_ACL_STAGE_INGRESS
        bpoints = [SAI_ACL_BIND_POINT_TYPE_SWITCH]
        self.bpoint_type_list = sai_thrift_s32_list_t(
            count=len(bpoints), int32list=bpoints)
        group_type = SAI_ACL_TABLE_GROUP_TYPE_PARALLEL

        self.acl_group = sai_thrift_create_acl_table_group(
            self.client,
            acl_stage=group_stage,
            acl_bind_point_type_list=self.bpoint_type_list,
            type=group_type)
        self.table_stage = SAI_ACL_STAGE_INGRESS

        sai_thrift_set_switch_attribute(
            self.client, ingress_acl=self.acl_group)

        try:
            self.MacAclActionTransitTest()
            self.MacAclActionDenyTest()
            self.MacAclActionTransitMalformPktTest()
            self.V4AclActionDenyTest()
            self.V4AclActionTransitTest()
            self.V6AclActionDenyTest()
            self.V6AclActionTransitTest()
            self.V4AclActionTransitL3MalformTest()

        finally:
            sai_thrift_set_switch_attribute(self.client, ingress_acl=0)
            sai_thrift_remove_acl_table_group(self.client, self.acl_group)
            sai_thrift_remove_router_interface(self.client, self.vlan20_rif)
            sai_thrift_remove_hostif(self.client, self.hif)
            sai_thrift_remove_hostif(self.client, self.hif2)
            pass

    def tearDown(self):
        super(IngressAclTransitDenyTest, self).tearDown()

    def MacAclActionDenyTest(self):
        '''
        This verifies mac acl action deny --> copy cancel + drop
        i.e if a user acl with this action can override
        the default system acl trap entry with action trap
        '''
        print("MacAclActionDenyTest  ")

        src_mac = "00:AA:BB:EE:BB:AA"
        # Bcast ARP Request
        arp_pkt = simple_arp_packet(arp_op=1,
                                    eth_src=src_mac,
                                    pktlen=100)
        tag_arp_pkt = simple_arp_packet(arp_op=1,
                                        vlan_vid=20,
                                        eth_src=src_mac,
                                        pktlen=104)

        try:
            print(" Config hif arp req entry with action trap  ")
            arp_req_trap = sai_thrift_create_hostif_trap(
                self.client,
                packet_action=SAI_PACKET_ACTION_TRAP,
                trap_type=SAI_HOSTIF_TRAP_TYPE_ARP_REQUEST)
            self.assertTrue(arp_req_trap != 0)

            print("  Tx bcast ARP request from port2 --> trap  ")
            send_packet(self, self.dev_port2, arp_pkt)
            verify_no_other_packets(self)
            self.assertTrue(socket_verify_packet(arp_pkt, self.hif_trap))

            print("  Verifying CPU port queue stats")
            time.sleep(5)
            post_stats = sai_thrift_get_queue_stats(
                self.client, self.cpu_queue0)
            self.assertEqual(
                post_stats["SAI_QUEUE_STAT_PACKETS"],
                self.cpu_queue_state + 1)
            self.cpu_queue_state = post_stats["SAI_QUEUE_STAT_PACKETS"]

            print(" Config Mac Acl Table --> Acl Group bpoint switch  ")
            #  ACL table
            self.mac_acl_table = sai_thrift_create_acl_table(
                self.client,
                acl_stage=self.table_stage,
                acl_bind_point_type_list=self.bpoint_type_list,
                field_src_mac=True,
                field_in_port=True)

            #  ACL table entry
            mac_src_mask = 'ff:ff:ff:ff:ff:ff'
            src_mac_t = sai_thrift_acl_field_data_t(
                data=sai_thrift_acl_field_data_data_t(mac=src_mac),
                mask=sai_thrift_acl_field_data_mask_t(mac=mac_src_mask))

            packet_action = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    s32=SAI_PACKET_ACTION_DENY))

            print(" Config Mac Acl with src mac, port2 --> action deny  ")
            in_port_t = sai_thrift_acl_field_data_t(
                data=sai_thrift_acl_field_data_data_t(oid=self.port2))
            self.mac_acl_entry = sai_thrift_create_acl_entry(
                self.client,
                table_id=self.mac_acl_table,
                priority=10,
                field_src_mac=src_mac_t,
                field_in_port=in_port_t,
                action_packet_action=packet_action)

            #  ACL counter
            self.mac_acl_counter = sai_thrift_create_acl_counter(
                self.client, table_id=self.mac_acl_table)
            # attach ACL counter to ACL entry
            action_counter_t = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=self.mac_acl_counter),
                enable=True)
            sai_thrift_set_acl_entry_attribute(
                self.client, self.mac_acl_entry,
                action_counter=action_counter_t)

            #  ACL table group member
            self.mac_acl_member = sai_thrift_create_acl_table_group_member(
                self.client,
                acl_table_group_id=self.acl_group,
                acl_table_id=self.mac_acl_table)

            time.sleep(2)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, self.mac_acl_counter, packets=True)
            self.assertEqual(packets['packets'], 0)

            print("  Tx bcast ARP request from port2 --> deny  ")
            send_packet(self, self.dev_port2, arp_pkt)
            verify_no_other_packets(self)
            self.assertFalse(socket_verify_packet(arp_pkt, self.hif_trap))

            print("  Verifying CPU port queue stats")
            time.sleep(5)
            post_stats = sai_thrift_get_queue_stats(
                self.client, self.cpu_queue0)
            self.assertEqual(
                post_stats["SAI_QUEUE_STAT_PACKETS"],
                self.cpu_queue_state)

            packets = sai_thrift_get_acl_counter_attribute(
                self.client, self.mac_acl_counter, packets=True)
            self.assertEqual(packets['packets'], 1)

            print(" Remove hif arp req entry with action trap ")
            sai_thrift_remove_hostif_trap(self.client, arp_req_trap)

        finally:
            action_counter_t = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=0),
                enable=True)
            sai_thrift_set_acl_entry_attribute(
                self.client, self.mac_acl_entry,
                action_counter=action_counter_t)
            sai_thrift_set_acl_counter_attribute(
                self.client, self.mac_acl_counter, packets=None)

            packets = sai_thrift_get_acl_counter_attribute(
                self.client, self.mac_acl_counter, packets=True)
            self.assertEqual(packets['packets'], 0)
            sai_thrift_remove_acl_counter(self.client, self.mac_acl_counter)

            sai_thrift_remove_acl_table_group_member(
                self.client, self.mac_acl_member)
            sai_thrift_remove_acl_entry(self.client, self.mac_acl_entry)
            sai_thrift_remove_acl_table(self.client, self.mac_acl_table)

    def MacAclActionTransitTest(self):
        '''
        This verifies mac acl action transit --> copy cancel + forw
        i.e if a user acl with this action can override
        the default system acl trap entry with action copy
        '''
        print("MacAclActionTransitTest  ")

        src_mac = "00:AA:BB:EE:BB:AA"
        # Bcast ARP Request
        arp_pkt = simple_arp_packet(arp_op=1,
                                    eth_src=src_mac,
                                    pktlen=100)
        tag_arp_pkt = simple_arp_packet(arp_op=1,
                                        vlan_vid=20,
                                        eth_src=src_mac,
                                        pktlen=104)

        try:
            print(" Config hif arp req entry with action copy  ")
            arp_req_copy = sai_thrift_create_hostif_trap(
                self.client,
                packet_action=SAI_PACKET_ACTION_COPY,
                trap_type=SAI_HOSTIF_TRAP_TYPE_ARP_REQUEST)
            self.assertTrue(arp_req_copy != 0)

            print("  Tx ARP request from lag2 --> copy cpu, forw to vlan ")
            send_packet(self, self.dev_port7, tag_arp_pkt)
            verify_each_packet_on_each_port(
                    self,
                    [arp_pkt, tag_arp_pkt],
                    [self.dev_port2, self.dev_port3])
            self.assertTrue(socket_verify_packet(arp_pkt, self.hif_copy))

            print("  Verifying CPU port queue stats")
            time.sleep(5)
            post_stats = sai_thrift_get_queue_stats(
                self.client, self.cpu_queue0)
            self.assertEqual(
                post_stats["SAI_QUEUE_STAT_PACKETS"],
                self.cpu_queue_state + 1)
            self.cpu_queue_state = post_stats["SAI_QUEUE_STAT_PACKETS"]

            print("  Config Mac Acl Table --> Acl Group bpoint switch  ")
            #  ACL table
            self.mac_acl_table = sai_thrift_create_acl_table(
                self.client,
                acl_stage=self.table_stage,
                acl_bind_point_type_list=self.bpoint_type_list,
                field_src_mac=True,
                field_in_port=True)

            #  ACL table entry
            mac_src_mask = 'ff:ff:ff:ff:ff:ff'
            src_mac_t = sai_thrift_acl_field_data_t(
                data=sai_thrift_acl_field_data_data_t(mac=src_mac),
                mask=sai_thrift_acl_field_data_mask_t(mac=mac_src_mask))

            packet_action = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    s32=SAI_PACKET_ACTION_TRANSIT))

            print("  Config Mac Acl with src mac, lag2 --> action transit  ")
            in_lag_t = sai_thrift_acl_field_data_t(
                data=sai_thrift_acl_field_data_data_t(oid=self.lag2))
            self.mac_acl_entry = sai_thrift_create_acl_entry(
                self.client,
                table_id=self.mac_acl_table,
                priority=10,
                field_src_mac=src_mac_t,
                field_in_port=in_lag_t,
                action_packet_action=packet_action)

            #  ACL counter
            self.mac_acl_counter = sai_thrift_create_acl_counter(
                self.client, table_id=self.mac_acl_table)
            # attach ACL counter to ACL entry
            action_counter_t = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=self.mac_acl_counter),
                enable=True)
            sai_thrift_set_acl_entry_attribute(
                self.client, self.mac_acl_entry,
                action_counter=action_counter_t)

            #  ACL table group member
            self.mac_acl_member = sai_thrift_create_acl_table_group_member(
                self.client,
                acl_table_group_id=self.acl_group,
                acl_table_id=self.mac_acl_table)

            time.sleep(2)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, self.mac_acl_counter, packets=True)
            self.assertEqual(packets['packets'], 0)

            print("  Tx ARP request from lag2 --> copy cancel, forw to vlan ")
            send_packet(self, self.dev_port7, tag_arp_pkt)
            verify_each_packet_on_each_port(
                    self,
                    [arp_pkt, tag_arp_pkt],
                    [self.dev_port2, self.dev_port3])
            self.assertFalse(socket_verify_packet(arp_pkt, self.hif_copy))

            print("  Verifying CPU port queue stats")
            time.sleep(5)
            post_stats = sai_thrift_get_queue_stats(
                self.client, self.cpu_queue0)
            self.assertEqual(
                post_stats["SAI_QUEUE_STAT_PACKETS"],
                self.cpu_queue_state)

            packets = sai_thrift_get_acl_counter_attribute(
                self.client, self.mac_acl_counter, packets=True)
            self.assertEqual(packets['packets'], 1)

            print(" Remove hif arp req entry with action copy  ")
            sai_thrift_remove_hostif_trap(self.client, arp_req_copy)

        finally:
            action_counter_t = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=0),
                enable=True)
            sai_thrift_set_acl_entry_attribute(
                self.client, self.mac_acl_entry,
                action_counter=action_counter_t)
            sai_thrift_set_acl_counter_attribute(
                self.client, self.mac_acl_counter, packets=None)

            packets = sai_thrift_get_acl_counter_attribute(
                self.client, self.mac_acl_counter, packets=True)
            self.assertEqual(packets['packets'], 0)
            sai_thrift_remove_acl_counter(self.client, self.mac_acl_counter)

            sai_thrift_remove_acl_table_group_member(
                self.client, self.mac_acl_member)
            sai_thrift_remove_acl_entry(self.client, self.mac_acl_entry)
            sai_thrift_remove_acl_table(self.client, self.mac_acl_table)

    def MacAclActionTransitMalformPktTest(self):
        '''
        This verifies mac acl action transit --> copy cancel + forw
        for the malform pkt - eth malform pkt
        i.e if a user acl with transit action overrides
        the default system acl trap entry [with action trap],
        pkt must not go to cpu, & also the pkt must be dropped
        because of eth malform pkt - mac all zeros
        '''
        print("MacAclActionTransitMalformPktTest  ")

        src_mac = "00:AA:BB:EE:BB:AA"
        # Bcast ARP Request
        arp_pkt = simple_arp_packet(arp_op=1,
                                    eth_src=src_mac,
                                    eth_dst="00:00:00:00:00:00",    # malf
                                    pktlen=100)
        tag_arp_pkt = simple_arp_packet(arp_op=1,
                                        vlan_vid=20,
                                        eth_src=src_mac,
                                        pktlen=104)

        try:
            print(" Config hif arp req entry with action trap  ")
            arp_req_trap = sai_thrift_create_hostif_trap(
                self.client,
                packet_action=SAI_PACKET_ACTION_TRAP,
                trap_type=SAI_HOSTIF_TRAP_TYPE_ARP_REQUEST)
            self.assertTrue(arp_req_trap != 0)

            print(" Config Mac Acl Table --> Acl Group bpoint switch  ")
            #  ACL table
            self.mac_acl_table = sai_thrift_create_acl_table(
                self.client,
                acl_stage=self.table_stage,
                acl_bind_point_type_list=self.bpoint_type_list,
                field_src_mac=True,
                field_in_port=True)

            #  ACL table entry
            mac_src_mask = 'ff:ff:ff:ff:ff:ff'
            src_mac_t = sai_thrift_acl_field_data_t(
                data=sai_thrift_acl_field_data_data_t(mac=src_mac),
                mask=sai_thrift_acl_field_data_mask_t(mac=mac_src_mask))

            packet_action = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    s32=SAI_PACKET_ACTION_TRANSIT))

            print(" Config Mac Acl with src mac, port2 --> action transit  ")
            in_port_t = sai_thrift_acl_field_data_t(
                data=sai_thrift_acl_field_data_data_t(oid=self.port2))
            self.mac_acl_entry = sai_thrift_create_acl_entry(
                self.client,
                table_id=self.mac_acl_table,
                priority=10,
                field_src_mac=src_mac_t,
                field_in_port=in_port_t,
                action_packet_action=packet_action)

            #  ACL counter
            self.mac_acl_counter = sai_thrift_create_acl_counter(
                self.client, table_id=self.mac_acl_table)
            # attach ACL counter to ACL entry
            action_counter_t = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=self.mac_acl_counter),
                enable=True)
            sai_thrift_set_acl_entry_attribute(
                self.client, self.mac_acl_entry,
                action_counter=action_counter_t)

            #  ACL table group member
            self.mac_acl_member = sai_thrift_create_acl_table_group_member(
                self.client,
                acl_table_group_id=self.acl_group,
                acl_table_id=self.mac_acl_table)

            time.sleep(2)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, self.mac_acl_counter, packets=True)
            self.assertEqual(packets['packets'], 0)

            print("  Tx ARP request from port2 --> drop, eth malform pkt  ")
            send_packet(self, self.dev_port2, arp_pkt)
            verify_no_other_packets(self)
            self.assertFalse(socket_verify_packet(arp_pkt, self.hif_trap))

            print("  Verifying CPU port queue stats")
            time.sleep(5)
            post_stats = sai_thrift_get_queue_stats(
                self.client, self.cpu_queue0)
            self.assertEqual(
                post_stats["SAI_QUEUE_STAT_PACKETS"],
                self.cpu_queue_state)

            packets = sai_thrift_get_acl_counter_attribute(
                self.client, self.mac_acl_counter, packets=True)
            self.assertEqual(packets['packets'], 1)

            print(" Remove hif arp req entry with action trap ")
            sai_thrift_remove_hostif_trap(self.client, arp_req_trap)

        finally:
            action_counter_t = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=0),
                enable=True)
            sai_thrift_set_acl_entry_attribute(
                self.client, self.mac_acl_entry,
                action_counter=action_counter_t)
            sai_thrift_set_acl_counter_attribute(
                self.client, self.mac_acl_counter, packets=None)

            packets = sai_thrift_get_acl_counter_attribute(
                self.client, self.mac_acl_counter, packets=True)
            self.assertEqual(packets['packets'], 0)
            sai_thrift_remove_acl_counter(self.client, self.mac_acl_counter)

            sai_thrift_remove_acl_table_group_member(
                self.client, self.mac_acl_member)
            sai_thrift_remove_acl_entry(self.client, self.mac_acl_entry)
            sai_thrift_remove_acl_table(self.client, self.mac_acl_table)

    def V4AclActionDenyTest(self):
        '''
        This verifies v4 user acl action deny --> copy cancel + drop
        i.e if a v4 user acl with this action can override
        the default system acl trap entry with action trap
        '''
        print("V4AclActionDenyTest  ")

        vrrp_mcast_ip = "224.0.0.18"
        vrrp_proto = 112

        # VRRP pkts
        tag_vrrp_pkt = simple_ip_packet(dl_vlan_enable=True,
                                        vlan_vid=20,
                                        ip_dst=vrrp_mcast_ip,
                                        ip_proto=vrrp_proto,
                                        pktlen=104)
        vrrp_pkt = simple_ip_packet(ip_dst=vrrp_mcast_ip,
                                    ip_proto=vrrp_proto)

        try:
            print(" Config v4 vrrp control pkt entry with action trap  ")
            vrrp_trap = sai_thrift_create_hostif_trap(
                self.client,
                packet_action=SAI_PACKET_ACTION_TRAP,
                trap_type=SAI_HOSTIF_TRAP_TYPE_VRRP)
            self.assertTrue(vrrp_trap != 0)

            print("  Tx v4 vrrp control pkt from port2 --> trap  ")
            send_packet(self, self.dev_port2, vrrp_pkt)
            verify_no_other_packets(self)
            self.assertTrue(socket_verify_packet(vrrp_pkt, self.hif_trap))

            print("  Verifying CPU port queue stats")
            time.sleep(5)
            post_stats = sai_thrift_get_queue_stats(
                self.client, self.cpu_queue0)
            self.assertEqual(
                post_stats["SAI_QUEUE_STAT_PACKETS"],
                self.cpu_queue_state + 1)
            self.cpu_queue_state = post_stats["SAI_QUEUE_STAT_PACKETS"]

            print(" Config V4 Acl Table --> Acl Group bpoint switch  ")
            #  ACL table
            self.v4_acl_table = sai_thrift_create_acl_table(
                self.client,
                acl_stage=self.table_stage,
                acl_bind_point_type_list=self.bpoint_type_list,
                field_dst_ip=True,
                field_in_port=True)

            #  ACL table entry
            ip_mask = '255.255.255.255'
            ip_t = sai_thrift_acl_field_data_t(
                data=sai_thrift_acl_field_data_data_t(ip4=vrrp_mcast_ip),
                mask=sai_thrift_acl_field_data_mask_t(ip4=ip_mask))

            packet_action = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    s32=SAI_PACKET_ACTION_DENY))

            print(" Config V4 Acl with dst ip, port2 --> action deny  ")
            in_port_t = sai_thrift_acl_field_data_t(
                data=sai_thrift_acl_field_data_data_t(oid=self.port2))
            self.v4_acl_entry = sai_thrift_create_acl_entry(
                self.client,
                table_id=self.v4_acl_table,
                priority=10,
                field_dst_ip=ip_t,
                field_in_port=in_port_t,
                action_packet_action=packet_action)

            #  ACL counter
            self.v4_acl_counter = sai_thrift_create_acl_counter(
                self.client, table_id=self.v4_acl_table)
            # attach ACL counter to ACL entry
            action_counter_t = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=self.v4_acl_counter),
                enable=True)
            sai_thrift_set_acl_entry_attribute(
                self.client, self.v4_acl_entry,
                action_counter=action_counter_t)

            #  ACL table group member
            self.v4_acl_member = sai_thrift_create_acl_table_group_member(
                self.client,
                acl_table_group_id=self.acl_group,
                acl_table_id=self.v4_acl_table)

            time.sleep(2)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, self.v4_acl_counter, packets=True)
            self.assertEqual(packets['packets'], 0)

            print("  Tx v4 vrrp control pkt from port2 --> deny  ")
            send_packet(self, self.dev_port2, vrrp_pkt)
            verify_no_other_packets(self)
            self.assertFalse(socket_verify_packet(vrrp_pkt, self.hif_trap))

            print("  Verifying CPU port queue stats")
            time.sleep(5)
            post_stats = sai_thrift_get_queue_stats(
                self.client, self.cpu_queue0)
            self.assertEqual(
                post_stats["SAI_QUEUE_STAT_PACKETS"],
                self.cpu_queue_state)

            packets = sai_thrift_get_acl_counter_attribute(
                self.client, self.v4_acl_counter, packets=True)
            self.assertEqual(packets['packets'], 1)

            print(" Remove v4 vrrp control pkt entry with action trap  ")
            sai_thrift_remove_hostif_trap(self.client, vrrp_trap)

        finally:
            action_counter_t = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=0),
                enable=True)
            sai_thrift_set_acl_entry_attribute(
                self.client, self.v4_acl_entry,
                action_counter=action_counter_t)
            sai_thrift_set_acl_counter_attribute(
                self.client, self.v4_acl_counter, packets=None)

            packets = sai_thrift_get_acl_counter_attribute(
                self.client, self.v4_acl_counter, packets=True)
            self.assertEqual(packets['packets'], 0)
            sai_thrift_remove_acl_counter(self.client, self.v4_acl_counter)

            sai_thrift_remove_acl_table_group_member(
                self.client, self.v4_acl_member)
            sai_thrift_remove_acl_entry(self.client, self.v4_acl_entry)
            sai_thrift_remove_acl_table(self.client, self.v4_acl_table)

    def V4AclActionTransitTest(self):
        '''
        This verifies v4 user acl action transit --> copy cancel + forw
        i.e if a v4 user acl with this action can override
        the default system acl trap entry with action copy
        '''
        print("V4AclActionTransitTest  ")

        vrrp_mcast_ip = "224.0.0.18"
        vrrp_proto = 112

        # VRRP pkts
        tag_vrrp_pkt = simple_ip_packet(dl_vlan_enable=True,
                                        vlan_vid=20,
                                        ip_dst=vrrp_mcast_ip,
                                        ip_proto=vrrp_proto,
                                        pktlen=104)
        vrrp_pkt = simple_ip_packet(ip_dst=vrrp_mcast_ip,
                                    ip_proto=vrrp_proto)

        try:
            print(" Config v4 vrrp control pkt entry with action copy ")
            vrrp_copy = sai_thrift_create_hostif_trap(
                self.client,
                packet_action=SAI_PACKET_ACTION_COPY,
                trap_type=SAI_HOSTIF_TRAP_TYPE_VRRP)
            self.assertTrue(vrrp_copy != 0)

            print("  Tx v4 vrrp ctrl pkt lag2 --> copy cpu, forw to vlan ")
            send_packet(self, self.dev_port7, tag_vrrp_pkt)
            verify_each_packet_on_each_port(
                    self,
                    [vrrp_pkt, tag_vrrp_pkt],
                    [self.dev_port2, self.dev_port3])
            self.assertTrue(socket_verify_packet(vrrp_pkt, self.hif_copy))

            print("  Verifying CPU port queue stats")
            time.sleep(5)
            post_stats = sai_thrift_get_queue_stats(
                self.client, self.cpu_queue0)
            self.assertEqual(
                post_stats["SAI_QUEUE_STAT_PACKETS"],
                self.cpu_queue_state + 1)
            self.cpu_queue_state = post_stats["SAI_QUEUE_STAT_PACKETS"]

            print(" Config V4 Acl Table --> Acl Group bpoint switch  ")
            #  ACL table
            self.v4_acl_table = sai_thrift_create_acl_table(
                self.client,
                acl_stage=self.table_stage,
                acl_bind_point_type_list=self.bpoint_type_list,
                field_dst_ip=True,
                field_in_port=True)

            #  ACL table entry
            ip_mask = '255.255.255.255'
            ip_t = sai_thrift_acl_field_data_t(
                data=sai_thrift_acl_field_data_data_t(ip4=vrrp_mcast_ip),
                mask=sai_thrift_acl_field_data_mask_t(ip4=ip_mask))

            packet_action = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    s32=SAI_PACKET_ACTION_TRANSIT))

            print(" Config V4 Acl with dst ip, lag2 --> action transit  ")
            in_lag_t = sai_thrift_acl_field_data_t(
                data=sai_thrift_acl_field_data_data_t(oid=self.lag2))
            self.v4_acl_entry = sai_thrift_create_acl_entry(
                self.client,
                table_id=self.v4_acl_table,
                priority=10,
                field_dst_ip=ip_t,
                field_in_port=in_lag_t,
                action_packet_action=packet_action)

            #  ACL counter
            self.v4_acl_counter = sai_thrift_create_acl_counter(
                self.client, table_id=self.v4_acl_table)
            # attach ACL counter to ACL entry
            action_counter_t = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=self.v4_acl_counter),
                enable=True)
            sai_thrift_set_acl_entry_attribute(
                self.client, self.v4_acl_entry,
                action_counter=action_counter_t)

            #  ACL table group member
            self.v4_acl_member = sai_thrift_create_acl_table_group_member(
                self.client,
                acl_table_group_id=self.acl_group,
                acl_table_id=self.v4_acl_table)

            time.sleep(2)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, self.v4_acl_counter, packets=True)
            self.assertEqual(packets['packets'], 0)

            print("  Tx v4 vrrp ctrl pkt lag2 --> copy cancel,forw to vlan  ")
            send_packet(self, self.dev_port7, tag_vrrp_pkt)
            verify_each_packet_on_each_port(
                    self,
                    [vrrp_pkt, tag_vrrp_pkt],
                    [self.dev_port2, self.dev_port3])
            self.assertFalse(socket_verify_packet(vrrp_pkt, self.hif_copy))

            print("  Verifying CPU port queue stats")
            time.sleep(5)
            post_stats = sai_thrift_get_queue_stats(
                self.client, self.cpu_queue0)
            self.assertEqual(
                post_stats["SAI_QUEUE_STAT_PACKETS"],
                self.cpu_queue_state)

            packets = sai_thrift_get_acl_counter_attribute(
                self.client, self.v4_acl_counter, packets=True)
            self.assertEqual(packets['packets'], 1)

            print(" Remove v4 vrrp control pkt entry with action copy  ")
            sai_thrift_remove_hostif_trap(self.client, vrrp_copy)

        finally:
            action_counter_t = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=0),
                enable=True)
            sai_thrift_set_acl_entry_attribute(
                self.client, self.v4_acl_entry,
                action_counter=action_counter_t)
            sai_thrift_set_acl_counter_attribute(
                self.client, self.v4_acl_counter, packets=None)

            packets = sai_thrift_get_acl_counter_attribute(
                self.client, self.v4_acl_counter, packets=True)
            self.assertEqual(packets['packets'], 0)
            sai_thrift_remove_acl_counter(self.client, self.v4_acl_counter)

            sai_thrift_remove_acl_table_group_member(
                self.client, self.v4_acl_member)
            sai_thrift_remove_acl_entry(self.client, self.v4_acl_entry)
            sai_thrift_remove_acl_table(self.client, self.v4_acl_table)

    def V6AclActionDenyTest(self):
        '''
        This verifies v6 user acl action deny --> copy cancel + drop
        i.e if a v6 user acl with this action can override
        the default system acl trap entry with action trap
        '''
        print("V6AclActionDenyTest  ")

        vrrp_mcast_ip = "FF02::12"
        vrrp_proto = 112

        # VRRP pkts
        tag_vrrp_pkt = simple_ipv6ip_packet(dl_vlan_enable=True,
                                            vlan_vid=20,
                                            ipv6_dst=vrrp_mcast_ip,
                                            pktlen=304)
        tag_vrrp_pkt["IPv6"].nh = vrrp_proto
        vrrp_pkt = simple_ipv6ip_packet(ipv6_dst=vrrp_mcast_ip)
        vrrp_pkt["IPv6"].nh = vrrp_proto

        try:
            print(" Config v6 vrrp control pkt entry with action trap  ")
            vrrp_trap = sai_thrift_create_hostif_trap(
                self.client,
                packet_action=SAI_PACKET_ACTION_TRAP,
                trap_type=SAI_HOSTIF_TRAP_TYPE_VRRPV6)
            self.assertTrue(vrrp_trap != 0)

            print("  Tx v6 vrrp control pkt from port2 --> trap  ")
            send_packet(self, self.dev_port2, vrrp_pkt)
            verify_no_other_packets(self)
            self.assertTrue(socket_verify_packet(vrrp_pkt, self.hif_trap))

            print("  Verifying CPU port queue stats")
            time.sleep(5)
            post_stats = sai_thrift_get_queue_stats(
                self.client, self.cpu_queue0)
            self.assertEqual(
                post_stats["SAI_QUEUE_STAT_PACKETS"],
                self.cpu_queue_state + 1)
            self.cpu_queue_state = post_stats["SAI_QUEUE_STAT_PACKETS"]

            print(" Config V6 Acl Table --> Acl Group bpoint switch  ")
            #  ACL table
            self.v6_acl_table = sai_thrift_create_acl_table(
                self.client,
                acl_stage=self.table_stage,
                acl_bind_point_type_list=self.bpoint_type_list,
                field_dst_ipv6=True,
                field_in_port=True)

            #  ACL table entry
            ip_mask = 'FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF'
            ip_t = sai_thrift_acl_field_data_t(
                data=sai_thrift_acl_field_data_data_t(ip6=vrrp_mcast_ip),
                mask=sai_thrift_acl_field_data_mask_t(ip6=ip_mask))

            packet_action = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    s32=SAI_PACKET_ACTION_DENY))

            print(" Config V6 Acl with dst ip, port2 --> action deny  ")
            in_port_t = sai_thrift_acl_field_data_t(
                data=sai_thrift_acl_field_data_data_t(oid=self.port2))
            self.v6_acl_entry = sai_thrift_create_acl_entry(
                self.client,
                table_id=self.v6_acl_table,
                priority=10,
                field_dst_ipv6=ip_t,
                field_in_port=in_port_t,
                action_packet_action=packet_action)

            #  ACL counter
            self.v6_acl_counter = sai_thrift_create_acl_counter(
                self.client, table_id=self.v6_acl_table)
            # attach ACL counter to ACL entry
            action_counter_t = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=self.v6_acl_counter),
                enable=True)
            sai_thrift_set_acl_entry_attribute(
                self.client, self.v6_acl_entry,
                action_counter=action_counter_t)

            #  ACL table group member
            self.v6_acl_member = sai_thrift_create_acl_table_group_member(
                self.client,
                acl_table_group_id=self.acl_group,
                acl_table_id=self.v6_acl_table)

            time.sleep(2)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, self.v6_acl_counter, packets=True)
            self.assertEqual(packets['packets'], 0)

            print("  Tx v6 vrrp control pkt from port2 --> deny  ")
            send_packet(self, self.dev_port2, vrrp_pkt)
            verify_no_other_packets(self)
            self.assertFalse(socket_verify_packet(vrrp_pkt, self.hif_trap))

            print("  Verifying CPU port queue stats")
            time.sleep(5)
            post_stats = sai_thrift_get_queue_stats(
                self.client, self.cpu_queue0)
            self.assertEqual(
                post_stats["SAI_QUEUE_STAT_PACKETS"],
                self.cpu_queue_state)

            packets = sai_thrift_get_acl_counter_attribute(
                self.client, self.v6_acl_counter, packets=True)
            self.assertEqual(packets['packets'], 1)

            print(" Remove v6 vrrp control pkt entry with action trap  ")
            sai_thrift_remove_hostif_trap(self.client, vrrp_trap)

        finally:
            action_counter_t = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=0),
                enable=True)
            sai_thrift_set_acl_entry_attribute(
                self.client, self.v6_acl_entry,
                action_counter=action_counter_t)
            sai_thrift_set_acl_counter_attribute(
                self.client, self.v6_acl_counter, packets=None)

            packets = sai_thrift_get_acl_counter_attribute(
                self.client, self.v6_acl_counter, packets=True)
            self.assertEqual(packets['packets'], 0)
            sai_thrift_remove_acl_counter(self.client, self.v6_acl_counter)

            sai_thrift_remove_acl_table_group_member(
                self.client, self.v6_acl_member)
            sai_thrift_remove_acl_entry(self.client, self.v6_acl_entry)
            sai_thrift_remove_acl_table(self.client, self.v6_acl_table)

    def V6AclActionTransitTest(self):
        '''
        This verifies v6 user acl action transit --> copy cancel + forw
        i.e if a v6 user acl with this action can override
        the default system acl trap entry with action copy
        '''
        print("V6AclActionTransitTest  ")

        vrrp_mcast_ip = "FF02::12"
        vrrp_proto = 112

        # VRRP pkts
        tag_vrrp_pkt = simple_ipv6ip_packet(dl_vlan_enable=True,
                                            vlan_vid=20,
                                            ipv6_dst=vrrp_mcast_ip,
                                            pktlen=304)
        tag_vrrp_pkt["IPv6"].nh = vrrp_proto
        vrrp_pkt = simple_ipv6ip_packet(ipv6_dst=vrrp_mcast_ip)
        vrrp_pkt["IPv6"].nh = vrrp_proto

        try:
            print(" Config v6 vrrp control pkt entry with action copy ")
            vrrp_copy = sai_thrift_create_hostif_trap(
                self.client,
                packet_action=SAI_PACKET_ACTION_COPY,
                trap_type=SAI_HOSTIF_TRAP_TYPE_VRRPV6)
            self.assertTrue(vrrp_copy != 0)

            print("  Tx v6 vrrp ctrl pkt lag2 --> copy cpu, forw to vlan ")
            send_packet(self, self.dev_port7, tag_vrrp_pkt)
            verify_each_packet_on_each_port(
                    self,
                    [vrrp_pkt, tag_vrrp_pkt],
                    [self.dev_port2, self.dev_port3])
            self.assertTrue(socket_verify_packet(vrrp_pkt, self.hif_copy))

            print("  Verifying CPU port queue stats")
            time.sleep(5)
            post_stats = sai_thrift_get_queue_stats(
                self.client, self.cpu_queue0)
            self.assertEqual(
                post_stats["SAI_QUEUE_STAT_PACKETS"],
                self.cpu_queue_state + 1)
            self.cpu_queue_state = post_stats["SAI_QUEUE_STAT_PACKETS"]

            print(" Config V6 Acl Table --> Acl Group bpoint switch  ")
            #  ACL table
            self.v6_acl_table = sai_thrift_create_acl_table(
                self.client,
                acl_stage=self.table_stage,
                acl_bind_point_type_list=self.bpoint_type_list,
                field_dst_ipv6=True,
                field_in_port=True)

            #  ACL table entry
            ip_mask = 'FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF'
            ip_t = sai_thrift_acl_field_data_t(
                data=sai_thrift_acl_field_data_data_t(ip6=vrrp_mcast_ip),
                mask=sai_thrift_acl_field_data_mask_t(ip6=ip_mask))

            packet_action = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    s32=SAI_PACKET_ACTION_TRANSIT))

            print(" Config V6 Acl with dst ip, lag2 --> action transit  ")
            in_lag_t = sai_thrift_acl_field_data_t(
                data=sai_thrift_acl_field_data_data_t(oid=self.lag2))
            self.v6_acl_entry = sai_thrift_create_acl_entry(
                self.client,
                table_id=self.v6_acl_table,
                priority=10,
                field_dst_ipv6=ip_t,
                field_in_port=in_lag_t,
                action_packet_action=packet_action)

            #  ACL counter
            self.v6_acl_counter = sai_thrift_create_acl_counter(
                self.client, table_id=self.v6_acl_table)
            # attach ACL counter to ACL entry
            action_counter_t = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=self.v6_acl_counter),
                enable=True)
            sai_thrift_set_acl_entry_attribute(
                self.client, self.v6_acl_entry,
                action_counter=action_counter_t)

            #  ACL table group member
            self.v6_acl_member = sai_thrift_create_acl_table_group_member(
                self.client,
                acl_table_group_id=self.acl_group,
                acl_table_id=self.v6_acl_table)

            time.sleep(2)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, self.v6_acl_counter, packets=True)
            self.assertEqual(packets['packets'], 0)

            print("  Tx v6 vrrp ctrl pkt lag2 --> copy cancel,forw to vlan  ")
            send_packet(self, self.dev_port7, tag_vrrp_pkt)
            verify_each_packet_on_each_port(
                    self,
                    [vrrp_pkt, tag_vrrp_pkt],
                    [self.dev_port2, self.dev_port3])
            self.assertFalse(socket_verify_packet(vrrp_pkt, self.hif_copy))

            print("  Verifying CPU port queue stats")
            time.sleep(5)
            post_stats = sai_thrift_get_queue_stats(
                self.client, self.cpu_queue0)
            self.assertEqual(
                post_stats["SAI_QUEUE_STAT_PACKETS"],
                self.cpu_queue_state)

            packets = sai_thrift_get_acl_counter_attribute(
                self.client, self.v6_acl_counter, packets=True)
            self.assertEqual(packets['packets'], 1)

            print(" Remove v6 vrrp control pkt entry with action copy  ")
            sai_thrift_remove_hostif_trap(self.client, vrrp_copy)

        finally:
            action_counter_t = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=0),
                enable=True)
            sai_thrift_set_acl_entry_attribute(
                self.client, self.v6_acl_entry,
                action_counter=action_counter_t)
            sai_thrift_set_acl_counter_attribute(
                self.client, self.v6_acl_counter, packets=None)

            packets = sai_thrift_get_acl_counter_attribute(
                self.client, self.v6_acl_counter, packets=True)
            self.assertEqual(packets['packets'], 0)
            sai_thrift_remove_acl_counter(self.client, self.v6_acl_counter)

            sai_thrift_remove_acl_table_group_member(
                self.client, self.v6_acl_member)
            sai_thrift_remove_acl_entry(self.client, self.v6_acl_entry)
            sai_thrift_remove_acl_table(self.client, self.v6_acl_table)

    def V4AclActionTransitL3MalformTest(self):
        '''
        This verifies v4 acl action transit --> copy cancel + forw
        for the malform pkt - eth malform pkt
        i.e if a user acl with transit action overrides
        the default system acl trap entry [with action trap],
        pkt must not go to cpu, & also the pkt must be dropped
        because of l3 malform pkt - src ip all zeros
        '''
        print("V4AclActionTransitL3MalformTest  ")

        vrrp_mcast_ip = "224.0.0.18"
        vrrp_proto = 112

        # VRRP pkts
        vrrp_pkt = simple_ip_packet(eth_dst=ROUTER_MAC,
                                    ip_src="0.0.0.0",   # malf
                                    ip_dst=vrrp_mcast_ip,
                                    ip_proto=vrrp_proto)

        try:
            print(" Config v4 vrrp control pkt entry with action trap  ")
            vrrp_trap = sai_thrift_create_hostif_trap(
                self.client,
                packet_action=SAI_PACKET_ACTION_TRAP,
                trap_type=SAI_HOSTIF_TRAP_TYPE_VRRP)
            self.assertTrue(vrrp_trap != 0)

            print(" Config V4 Acl Table --> Acl Group bpoint switch  ")
            #  ACL table
            self.v4_acl_table = sai_thrift_create_acl_table(
                self.client,
                acl_stage=self.table_stage,
                acl_bind_point_type_list=self.bpoint_type_list,
                field_dst_ip=True,
                field_in_port=True)

            #  ACL table entry
            ip_mask = '255.255.255.255'
            ip_t = sai_thrift_acl_field_data_t(
                data=sai_thrift_acl_field_data_data_t(ip4=vrrp_mcast_ip),
                mask=sai_thrift_acl_field_data_mask_t(ip4=ip_mask))

            packet_action = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    s32=SAI_PACKET_ACTION_TRANSIT))

            print(" Config V4 Acl with dst ip, port2 --> action transit  ")
            in_port_t = sai_thrift_acl_field_data_t(
                data=sai_thrift_acl_field_data_data_t(oid=self.port2))
            self.v4_acl_entry = sai_thrift_create_acl_entry(
                self.client,
                table_id=self.v4_acl_table,
                priority=10,
                field_dst_ip=ip_t,
                field_in_port=in_port_t,
                action_packet_action=packet_action)

            #  ACL counter
            self.v4_acl_counter = sai_thrift_create_acl_counter(
                self.client, table_id=self.v4_acl_table)
            # attach ACL counter to ACL entry
            action_counter_t = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=self.v4_acl_counter),
                enable=True)
            sai_thrift_set_acl_entry_attribute(
                self.client, self.v4_acl_entry,
                action_counter=action_counter_t)

            #  ACL table group member
            self.v4_acl_member = sai_thrift_create_acl_table_group_member(
                self.client,
                acl_table_group_id=self.acl_group,
                acl_table_id=self.v4_acl_table)

            time.sleep(2)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, self.v4_acl_counter, packets=True)
            self.assertEqual(packets['packets'], 0)

            print("  Tx v4 vrrp ctrl pkt port2 --> drop l3 malform pkt  ")
            send_packet(self, self.dev_port2, vrrp_pkt)
            verify_no_other_packets(self)
            self.assertFalse(socket_verify_packet(vrrp_pkt, self.hif_trap))

            print("  Verifying CPU port queue stats")
            time.sleep(5)
            post_stats = sai_thrift_get_queue_stats(
                self.client, self.cpu_queue0)
            self.assertEqual(
                post_stats["SAI_QUEUE_STAT_PACKETS"],
                self.cpu_queue_state)

            packets = sai_thrift_get_acl_counter_attribute(
                self.client, self.v4_acl_counter, packets=True)
            self.assertEqual(packets['packets'], 1)

            print(" Remove v4 vrrp control pkt entry with action trap  ")
            sai_thrift_remove_hostif_trap(self.client, vrrp_trap)

        finally:
            action_counter_t = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=0),
                enable=True)
            sai_thrift_set_acl_entry_attribute(
                self.client, self.v4_acl_entry,
                action_counter=action_counter_t)
            sai_thrift_set_acl_counter_attribute(
                self.client, self.v4_acl_counter, packets=None)

            packets = sai_thrift_get_acl_counter_attribute(
                self.client, self.v4_acl_counter, packets=True)
            self.assertEqual(packets['packets'], 0)
            sai_thrift_remove_acl_counter(self.client, self.v4_acl_counter)

            sai_thrift_remove_acl_table_group_member(
                self.client, self.v4_acl_member)
            sai_thrift_remove_acl_entry(self.client, self.v4_acl_entry)
            sai_thrift_remove_acl_table(self.client, self.v4_acl_table)


@group('acl2')
class IngressIpQosTcAclPrecedenceTest(SaiHelper):
    """
    Verify ACL Precedence over QosMap for TC
    """

    def setUp(self):
        super(IngressIpQosTcAclPrecedenceTest, self).setUp()

        #  configure port10 and port11 for dscp testing
        ip_addr = "172.16.10.1"
        ip_addr_subnet = "172.16.10.0"
        ip_addr_src = "192.168.100.100"
        dmac = "00:11:22:33:44:55"
        mac_src = '00:22:22:22:22:22'
        dst_v6 = '1234:5678:8ab4:5ef0:4422:1133:5500:55aa'
        dst_v6_subnet = '1234:5678:8ab4:5ef0:4422:1133:5500:0000/114'

        self.nhop = sai_thrift_create_next_hop(
            self.client,
            ip=sai_ipaddress(ip_addr),
            router_interface_id=self.port10_rif,
            type=SAI_NEXT_HOP_TYPE_IP)

        self.nbr_entry = sai_thrift_neighbor_entry_t(
            rif_id=self.port10_rif,
            ip_address=sai_ipaddress(ip_addr))
        sai_thrift_create_neighbor_entry(
            self.client,
            self.nbr_entry,
            dst_mac_address=dmac)

        self.route_entry = sai_thrift_route_entry_t(
            vr_id=self.default_vrf,
            destination=sai_ipprefix(ip_addr_subnet))
        sai_thrift_create_route_entry(
            self.client,
            self.route_entry,
            next_hop_id=self.port10_rif)

        #  allocate v6 neighbor, nhop, route
        self.v6_nbr_entry = sai_thrift_neighbor_entry_t(
            rif_id=self.port10_rif,
            ip_address=sai_ipaddress(dst_v6))
        sai_thrift_create_neighbor_entry(
            self.client,
            self.v6_nbr_entry,
            dst_mac_address=dmac)

        self.v6_nhop = sai_thrift_create_next_hop(
            self.client,
            ip=sai_ipaddress(dst_v6),
            router_interface_id=self.port10_rif,
            type=SAI_NEXT_HOP_TYPE_IP)

        self.v6_route_entry = sai_thrift_route_entry_t(
            vr_id=self.default_vrf,
            destination=sai_ipprefix(dst_v6_subnet))
        sai_thrift_create_route_entry(
            self.client,
            self.v6_route_entry,
            next_hop_id=self.v6_nhop)

        print("Configuring DSCP maps")
        #  setup dscp to tc mapping
        #  Port 11 qos map
        ingress_dscp_list = [1, 2]
        ingress_tc_list = [20, 21]
        self.p0_qos_dscp_to_tc_map = create_and_verify_qos_map(
            self.client, SAI_QOS_MAP_TYPE_DSCP_TO_TC, ingress_dscp_list,
            ingress_tc_list)
        #  Verify QosMap value list
        self.assertTrue(self.p0_qos_dscp_to_tc_map != 0,
                        "Failed to create dscp_to_tc map")

        #  setup tc to dscp mapping
        #  Port 10 qos map
        egress_tc_color_list = [
            [20, 0],
            [24, 0],
        ]
        egress_dscp_list = [
            9, 10,
        ]
        self.p1_qos_tc_color_to_dscp_map = create_and_verify_qos_map(
            self.client,
            SAI_QOS_MAP_TYPE_TC_AND_COLOR_TO_DSCP,
            egress_tc_color_list,
            egress_dscp_list)
        self.assertTrue(self.p1_qos_tc_color_to_dscp_map != 0,
                        "Failed to create tc_color_to_dscp map")
        self.assertEqual(self.status(), 0)

        sai_thrift_set_port_attribute(
            self.client,
            self.port11,
            qos_dscp_to_tc_map=self.p0_qos_dscp_to_tc_map)
        sai_thrift_set_port_attribute(
            self.client,
            self.port10,
            qos_tc_and_color_to_dscp_map=self.p1_qos_tc_color_to_dscp_map)

        table_stage_ingress = SAI_ACL_STAGE_INGRESS
        table_bind_point_list = [SAI_ACL_BIND_POINT_TYPE_SWITCH]

        table_bind_point_type_list = sai_thrift_s32_list_t(
            count=len(table_bind_point_list),
            int32list=table_bind_point_list)

        action_type = [SAI_ACL_ACTION_TYPE_SET_TC]
        qos_action_type_list = sai_thrift_s32_list_t(
            count=len(action_type), int32list=action_type)

        print("Alloc ACL Table")
        self.acl_table = sai_thrift_create_acl_table(
            self.client,
            acl_stage=table_stage_ingress,
            field_dst_ip=True,
            field_dst_ipv6=True,
            acl_bind_point_type_list=table_bind_point_type_list,
            acl_action_type_list=qos_action_type_list)

    def runTest(self):
        self.v4TcQosMapAndAclTest()
        self.v6TcQosMapAndAclTest()

    def tearDown(self):
        sai_thrift_set_switch_attribute(self.client, ingress_acl=0)
        sai_thrift_remove_next_hop(self.client, self.nhop)
        sai_thrift_remove_next_hop(self.client, self.v6_nhop)
        sai_thrift_remove_neighbor_entry(self.client, self.nbr_entry)
        sai_thrift_remove_neighbor_entry(self.client, self.v6_nbr_entry)
        sai_thrift_remove_route_entry(self.client, self.route_entry)
        sai_thrift_remove_route_entry(self.client, self.v6_route_entry)
        sai_thrift_remove_acl_table(self.client, self.acl_table)
        sai_thrift_set_port_attribute(self.client, self.port11,
                                      qos_dscp_to_tc_map=0)
        sai_thrift_set_port_attribute(self.client, self.port10,
                                      qos_tc_and_color_to_dscp_map=0)
        sai_thrift_remove_qos_map(self.client, self.p0_qos_dscp_to_tc_map)
        sai_thrift_remove_qos_map(
            self.client, self.p1_qos_tc_color_to_dscp_map)
        super(IngressIpQosTcAclPrecedenceTest, self).tearDown()

    def v4TcQosMapAndAclTest(self):
        print("v4TcQosMapAndAclTest()")
        #  Test the case when both ingress QOS map and QOS ACL are enabled
        try:
            ip_dst = "172.16.10.1"
            ip_addr = "172.16.10.1"
            ip_dst_mask = "255.255.255.0"
            mac_src = "00:22:22:22:22:22"
            ip_addr_src = "192.168.100.100"
            dmac = "00:11:22:33:44:55"
            print("Alloc ACL Field Data")
            dst_ip_t = sai_thrift_acl_field_data_t(
                data=sai_thrift_acl_field_data_data_t(ip4=ip_dst),
                mask=sai_thrift_acl_field_data_mask_t(ip4=ip_dst_mask))

            #  set tc 24
            print("Alloc ACL Action")
            action_tc_set = sai_thrift_acl_action_data_t(
                enable=True,
                parameter=sai_thrift_acl_action_parameter_t(u8=24))

            print("Alloc ACL Table")
            acl_entry_id = sai_thrift_create_acl_entry(
                self.client,
                table_id=self.acl_table,
                field_dst_ip=dst_ip_t,
                action_set_tc=action_tc_set)

            #  ACL counter
            acl_counter_ingress = sai_thrift_create_acl_counter(
                self.client, table_id=self.acl_table)
            #  attach ACL counter to ACL entry
            action_counter_ingress = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=acl_counter_ingress),
                enable=True)
            sai_thrift_set_acl_entry_attribute(
                self.client, acl_entry_id,
                action_counter=action_counter_ingress)

            self.pkt = simple_tcp_packet(
                eth_dst=ROUTER_MAC,
                eth_src=mac_src,
                ip_dst=ip_addr,
                ip_src=ip_addr_src,
                ip_id=105,
                ip_tos=1 << 2,
                ip_ttl=64)
            self.exp_pkt = simple_tcp_packet(
                eth_dst=dmac,
                eth_src=ROUTER_MAC,
                ip_dst=ip_addr,
                ip_src=ip_addr_src,
                ip_id=105,
                ip_tos=9 << 2,
                ip_ttl=63)
            self.exp_pkt_acl = simple_tcp_packet(
                eth_dst=dmac,
                eth_src=ROUTER_MAC,
                ip_dst=ip_addr,
                ip_src=ip_addr_src,
                ip_id=105,
                ip_tos=10 << 2,
                ip_ttl=63)

            #  Send packet without ACL Applied
            #  dscp 1 -> ingress qos map -> tc 20 -> dscp 9
            send_packet(self, self.dev_port11, self.pkt)
            verify_packet(self, self.exp_pkt, self.dev_port10)
            print("pass packet w/ mapped dscp value 1 -> 9")

            #  Send packet with ACL Applied
            #  dscp 1 -> ingress qos_map -> tc 20 -> dscp 9
            #  dscp 1 -> QoS ACL -> tc 24 - > dscp 10
            #  ACL entry should take precedence over qos-map
            sai_thrift_set_switch_attribute(
                self.client, ingress_acl=self.acl_table)
            send_packet(self, self.dev_port11, self.pkt)
            verify_packet(self, self.exp_pkt_acl, self.dev_port10)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter_ingress, packets=True)
            self.assertEqual(packets['packets'], 1)
            print("pass packet w/ mapped dscp value 1 -> 10")

        finally:
            #  delete v4 acl entry and counters
            sai_thrift_set_switch_attribute(self.client, ingress_acl=0)
            action_counter_ingress = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=0),
                enable=True)
            sai_thrift_set_acl_entry_attribute(
                self.client, acl_entry_id,
                action_counter=action_counter_ingress)
            sai_thrift_set_acl_counter_attribute(
                self.client, acl_counter_ingress, packets=None)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter_ingress, packets=True)
            self.assertEqual(packets['packets'], 0)
            sai_thrift_remove_acl_counter(self.client, acl_counter_ingress)
            sai_thrift_remove_acl_entry(self.client, acl_entry_id)

    def v6TcQosMapAndAclTest(self):
        print("v6TcQosMapAndAclTest()")
        #  Test the case when both ingress QOS map and QOS ACL are enabled
        try:
            dst_v6 = '1234:5678:8ab4:5ef0:4422:1133:5500:55aa'
            dst_v6_subnet = '1234:5678:8ab4:5ef0:4422:1133:5500:0000/114'
            mac_src = "00:22:22:22:22:22"
            dmac = "00:11:22:33:44:55"

            print("Alloc ACL Action")
            #  set tc to 24
            action_tc_set = sai_thrift_acl_action_data_t(
                enable=True,
                parameter=sai_thrift_acl_action_parameter_t(u8=24))
            print("Alloc ACL Field Data")
            dst_ip_t = sai_thrift_acl_field_data_t(
                data=sai_thrift_acl_field_data_data_t(ip6=dst_v6),
                mask=sai_thrift_acl_field_data_mask_t(ip6=dst_v6_subnet))

            self.v6_pkt = simple_tcpv6_packet(
                eth_dst=ROUTER_MAC,
                eth_src=mac_src,
                ipv6_dst=dst_v6,
                ipv6_src='2000::1',
                ipv6_hlim=64,
                ipv6_tc=1 << 2,
                pktlen=100)
            self.v6_exp_pkt = simple_tcpv6_packet(
                eth_dst=dmac,
                eth_src=ROUTER_MAC,
                ipv6_dst=dst_v6,
                ipv6_src='2000::1',
                ipv6_hlim=63,
                ipv6_tc=9 << 2,
                pktlen=100)
            self.v6_exp_pkt_acl = simple_tcpv6_packet(
                eth_dst=dmac,
                eth_src=ROUTER_MAC,
                ipv6_dst=dst_v6,
                ipv6_src='2000::1',
                ipv6_hlim=63,
                ipv6_tc=10 << 2,
                pktlen=100)

            #  Send packet without ACL Applied
            #  dscp 1 -> ingress qos map -> tc 20 -> dscp 9
            send_packet(self, self.dev_port11, self.v6_pkt)
            verify_packet(self, self.v6_exp_pkt, self.dev_port10)
            print("pass v6 packet w/ mapped dscp value 1 -> 9")

            #  Send packet with ACL Applied
            #  dscp 1 -> ingress qos_map -> tc 20 -> dscp 9
            #  dscp 1 -> QoS ACL -> tc 24 -> dscp 10
            #  ACL entry should take precedence over qos-map
            print("Alloc ACL Entry")
            v6_acl_entry_id = sai_thrift_create_acl_entry(
                self.client,
                table_id=self.acl_table,
                field_dst_ipv6=dst_ip_t,
                action_set_tc=action_tc_set)
            sai_thrift_set_switch_attribute(
                self.client, ingress_acl=self.acl_table)
            #  ACL counter
            acl_counter_ingress = sai_thrift_create_acl_counter(
                self.client, table_id=self.acl_table)
            #  attach ACL counter to ACL entry
            action_counter_ingress = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=acl_counter_ingress),
                enable=True)
            sai_thrift_set_acl_entry_attribute(
                self.client, v6_acl_entry_id,
                action_counter=action_counter_ingress)

            send_packet(self, self.dev_port11, self.v6_pkt)
            verify_packet(self, self.v6_exp_pkt_acl, self.dev_port10)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter_ingress, packets=True)
            self.assertEqual(packets['packets'], 1)
            print("pass v6 packet w/ mapped dscp value 1 -> 10")

        finally:
            #  delete v6 acl entry and counters
            sai_thrift_set_switch_attribute(self.client, ingress_acl=0)
            action_counter_ingress = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=0),
                enable=True)
            sai_thrift_set_acl_entry_attribute(
                self.client, v6_acl_entry_id,
                action_counter=action_counter_ingress)
            sai_thrift_set_acl_counter_attribute(
                self.client, acl_counter_ingress, packets=None)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter_ingress, packets=True)
            self.assertEqual(packets['packets'], 0)
            sai_thrift_remove_acl_counter(self.client, acl_counter_ingress)
            sai_thrift_remove_acl_entry(self.client, v6_acl_entry_id)


@group('acl2')
class IngressIpQosColorAclPrecedenceTest(SaiHelper):
    """
    Verify ACL Precedence over QosMap
    """

    def setUp(self):
        super(IngressIpQosColorAclPrecedenceTest, self).setUp()

        #  configure port0 and port1 for dscp testing
        ip_addr = "172.16.10.1"
        ip_addr_subnet = "172.16.10.0"
        ip_addr_src = "192.168.100.100"
        dmac = "00:11:22:33:44:55"
        mac_src = '00:22:22:22:22:22'
        dst_v6 = '1234:5678:8ab4:5ef0:4422:1133:5500:55aa'
        dst_v6_subnet = '1234:5678:8ab4:5ef0:4422:1133:5500:0000/114'

        self.nhop = sai_thrift_create_next_hop(
            self.client,
            ip=sai_ipaddress(ip_addr),
            router_interface_id=self.port10_rif,
            type=SAI_NEXT_HOP_TYPE_IP)

        self.nbr_entry = sai_thrift_neighbor_entry_t(
            rif_id=self.port10_rif,
            ip_address=sai_ipaddress(ip_addr))
        sai_thrift_create_neighbor_entry(
            self.client,
            self.nbr_entry,
            dst_mac_address=dmac)

        self.route_entry = sai_thrift_route_entry_t(
            vr_id=self.default_vrf,
            destination=sai_ipprefix(ip_addr_subnet))
        sai_thrift_create_route_entry(
            self.client,
            self.route_entry,
            next_hop_id=self.port10_rif)

        #  allocate v6 neighbor, nhop, route
        self.v6_nbr_entry = sai_thrift_neighbor_entry_t(
            rif_id=self.port10_rif,
            ip_address=sai_ipaddress(dst_v6))
        sai_thrift_create_neighbor_entry(
            self.client,
            self.v6_nbr_entry,
            dst_mac_address=dmac)

        self.v6_nhop = sai_thrift_create_next_hop(
            self.client,
            ip=sai_ipaddress(dst_v6),
            router_interface_id=self.port10_rif,
            type=SAI_NEXT_HOP_TYPE_IP)

        self.v6_route_entry = sai_thrift_route_entry_t(
            vr_id=self.default_vrf,
            destination=sai_ipprefix(dst_v6_subnet))
        sai_thrift_create_route_entry(
            self.client,
            self.v6_route_entry,
            next_hop_id=self.v6_nhop)

        print("Configuring DSCP maps")
        #  setup dscp to color mapping
        #  Port 11 qos map
        #  Color - 0:GREEN 1:YELLOW 2:RED
        ingress_dscp_list = [1, 2]
        ingress_color_list = [0, 2]
        self.p0_qos_dscp_to_color_map = create_and_verify_qos_map(
            self.client, SAI_QOS_MAP_TYPE_DSCP_TO_COLOR, ingress_dscp_list,
            ingress_color_list)
        #  Verify QosMap value list
        self.assertTrue(self.p0_qos_dscp_to_color_map != 0,
                        "Failed to create dscp_to_color map")

        #  setup color to dscp mapping
        #  Port 10 qos map
        egress_tc_color_list = [
            [0, 0],
            [0, 1],
        ]
        egress_dscp_list = [
            9, 10,
        ]
        self.p1_qos_tc_color_to_dscp_map = create_and_verify_qos_map(
            self.client,
            SAI_QOS_MAP_TYPE_TC_AND_COLOR_TO_DSCP,
            egress_tc_color_list,
            egress_dscp_list)
        self.assertTrue(self.p1_qos_tc_color_to_dscp_map != 0,
                        "Failed to create tc_color_to_dscp map")
        self.assertEqual(self.status(), 0)

        sai_thrift_set_port_attribute(
            self.client,
            self.port11,
            qos_dscp_to_color_map=self.p0_qos_dscp_to_color_map)
        sai_thrift_set_port_attribute(
            self.client,
            self.port10,
            qos_tc_and_color_to_dscp_map=self.p1_qos_tc_color_to_dscp_map)

        table_stage_ingress = SAI_ACL_STAGE_INGRESS
        table_bind_point_list = [SAI_ACL_BIND_POINT_TYPE_SWITCH]

        table_bind_point_type_list = sai_thrift_s32_list_t(
            count=len(table_bind_point_list),
            int32list=table_bind_point_list)

        action_type = [SAI_ACL_ACTION_TYPE_SET_PACKET_COLOR]
        qos_action_type_list = sai_thrift_s32_list_t(
            count=len(action_type), int32list=action_type)

        print("Alloc ACL Table")
        self.acl_table = sai_thrift_create_acl_table(
            self.client,
            acl_stage=table_stage_ingress,
            field_dst_ip=True,
            field_dst_ipv6=True,
            acl_bind_point_type_list=table_bind_point_type_list,
            acl_action_type_list=qos_action_type_list)

    def runTest(self):
        self.v4ColorQosMapAndAclTest()
        self.v6ColorQosMapAndAclTest()

    def tearDown(self):
        sai_thrift_set_switch_attribute(self.client, ingress_acl=0)
        sai_thrift_remove_next_hop(self.client, self.nhop)
        sai_thrift_remove_next_hop(self.client, self.v6_nhop)
        sai_thrift_remove_neighbor_entry(self.client, self.nbr_entry)
        sai_thrift_remove_neighbor_entry(self.client, self.v6_nbr_entry)
        sai_thrift_remove_route_entry(self.client, self.route_entry)
        sai_thrift_remove_route_entry(self.client, self.v6_route_entry)
        sai_thrift_remove_acl_table(self.client, self.acl_table)
        sai_thrift_set_port_attribute(self.client, self.port11,
                                      qos_dscp_to_color_map=0)
        sai_thrift_set_port_attribute(self.client, self.port10,
                                      qos_tc_and_color_to_dscp_map=0)
        sai_thrift_remove_qos_map(self.client, self.p0_qos_dscp_to_color_map)
        sai_thrift_remove_qos_map(
            self.client, self.p1_qos_tc_color_to_dscp_map)
        super(IngressIpQosColorAclPrecedenceTest, self).tearDown()

    def v4ColorQosMapAndAclTest(self):
        print("v4DscpRewriteQosMapAndAclTest()")
        #  Test the case when both ingress QOS map and QOS ACL are enabled
        try:
            ip_dst = "172.16.10.1"
            ip_addr = "172.16.10.1"
            ip_dst_mask = "255.255.255.0"
            mac_src = "00:22:22:22:22:22"
            ip_addr_src = "192.168.100.100"
            dmac = "00:11:22:33:44:55"
            print("Alloc ACL Field Data")
            dst_ip_t = sai_thrift_acl_field_data_t(
                data=sai_thrift_acl_field_data_data_t(ip4=ip_dst),
                mask=sai_thrift_acl_field_data_mask_t(ip4=ip_dst_mask))

            #  set color yellow
            print("Alloc ACL Action")
            color = SAI_PACKET_COLOR_YELLOW
            action_set_color = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(s32=color))

            print("Alloc ACL Table")
            acl_entry_id = sai_thrift_create_acl_entry(
                self.client,
                table_id=self.acl_table,
                field_dst_ip=dst_ip_t,
                action_set_packet_color=action_set_color)

            #  ACL counter
            acl_counter_ingress = sai_thrift_create_acl_counter(
                self.client, table_id=self.acl_table)
            #  attach ACL counter to ACL entry
            action_counter_ingress = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=acl_counter_ingress),
                enable=True)
            sai_thrift_set_acl_entry_attribute(
                self.client, acl_entry_id,
                action_counter=action_counter_ingress)

            self.pkt = simple_tcp_packet(
                eth_dst=ROUTER_MAC,
                eth_src=mac_src,
                ip_dst=ip_addr,
                ip_src=ip_addr_src,
                ip_id=105,
                ip_tos=1 << 2,
                ip_ttl=64)
            self.exp_pkt = simple_tcp_packet(
                eth_dst=dmac,
                eth_src=ROUTER_MAC,
                ip_dst=ip_addr,
                ip_src=ip_addr_src,
                ip_id=105,
                ip_tos=9 << 2,
                ip_ttl=63)
            self.exp_pkt_acl = simple_tcp_packet(
                eth_dst=dmac,
                eth_src=ROUTER_MAC,
                ip_dst=ip_addr,
                ip_src=ip_addr_src,
                ip_id=105,
                ip_tos=10 << 2,
                ip_ttl=63)

            #  Send packet without ACL Applied
            #  dscp 1 -> ingress qos map -> color 0 -> dscp 9
            send_packet(self, self.dev_port11, self.pkt)
            verify_packet(self, self.exp_pkt, self.dev_port10)
            print("pass packet w/ mapped dscp value 1 -> 9")

            #  Send packet with ACL Applied
            #  dscp 1 -> ingress qos_map -> color 0 -> dscp 9
            #  dscp 1 -> QoS ACL -> color 1 - > dscp 10
            #  ACL entry should take precedence over qos-map
            sai_thrift_set_switch_attribute(
                self.client, ingress_acl=self.acl_table)
            send_packet(self, self.dev_port11, self.pkt)
            verify_packet(self, self.exp_pkt_acl, self.dev_port10)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter_ingress, packets=True)
            self.assertEqual(packets['packets'], 1)
            print("pass packet w/ mapped dscp value 1 -> 10")

        finally:
            #  delete v4 acl entry and counters
            sai_thrift_set_switch_attribute(self.client, ingress_acl=0)
            action_counter_ingress = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=0),
                enable=True)
            sai_thrift_set_acl_entry_attribute(
                self.client, acl_entry_id,
                action_counter=action_counter_ingress)
            sai_thrift_set_acl_counter_attribute(
                self.client, acl_counter_ingress, packets=None)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter_ingress, packets=True)
            self.assertEqual(packets['packets'], 0)
            sai_thrift_remove_acl_counter(self.client, acl_counter_ingress)
            sai_thrift_remove_acl_entry(self.client, acl_entry_id)

    def v6ColorQosMapAndAclTest(self):
        print("v6DscpRewriteQosMapAndAclTest()")
        #  Test the case when both ingress QOS map and QOS ACL are enabled
        try:
            dst_v6 = '1234:5678:8ab4:5ef0:4422:1133:5500:55aa'
            dst_v6_subnet = '1234:5678:8ab4:5ef0:4422:1133:5500:0000/114'
            mac_src = "00:22:22:22:22:22"
            dmac = "00:11:22:33:44:55"

            print("Alloc ACL Action")
            #  set color yellow
            color = SAI_PACKET_COLOR_YELLOW
            action_set_color = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(s32=color))
            print("Alloc ACL Field Data")
            dst_ip_t = sai_thrift_acl_field_data_t(
                data=sai_thrift_acl_field_data_data_t(ip6=dst_v6),
                mask=sai_thrift_acl_field_data_mask_t(ip6=dst_v6_subnet))

            self.v6_pkt = simple_tcpv6_packet(
                eth_dst=ROUTER_MAC,
                eth_src=mac_src,
                ipv6_dst=dst_v6,
                ipv6_src='2000::1',
                ipv6_hlim=64,
                ipv6_tc=1 << 2,
                pktlen=100)
            self.v6_exp_pkt = simple_tcpv6_packet(
                eth_dst=dmac,
                eth_src=ROUTER_MAC,
                ipv6_dst=dst_v6,
                ipv6_src='2000::1',
                ipv6_hlim=63,
                ipv6_tc=9 << 2,
                pktlen=100)
            self.v6_exp_pkt_acl = simple_tcpv6_packet(
                eth_dst=dmac,
                eth_src=ROUTER_MAC,
                ipv6_dst=dst_v6,
                ipv6_src='2000::1',
                ipv6_hlim=63,
                ipv6_tc=10 << 2,
                pktlen=100)

            #  Send packet without ACL Applied
            #  dscp 1 -> ingress qos map -> color 0 -> dscp 9
            send_packet(self, self.dev_port11, self.v6_pkt)
            verify_packet(self, self.v6_exp_pkt, self.dev_port10)
            print("pass v6 packet w/ mapped dscp value 1 -> 9")

            #  Send packet with ACL Applied
            #  dscp 1 -> ingress qos_map -> color 0 -> dscp 9
            #  dscp 1 -> QoS ACL -> color 1 -> dscp 10
            #  ACL entry should take precedence over qos-map
            print("Alloc ACL Entry")
            v6_acl_entry_id = sai_thrift_create_acl_entry(
                self.client,
                table_id=self.acl_table,
                field_dst_ipv6=dst_ip_t,
                action_set_packet_color=action_set_color)
            sai_thrift_set_switch_attribute(
                self.client, ingress_acl=self.acl_table)
            #  ACL counter
            acl_counter_ingress = sai_thrift_create_acl_counter(
                self.client, table_id=self.acl_table)
            #  attach ACL counter to ACL entry
            action_counter_ingress = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=acl_counter_ingress),
                enable=True)
            sai_thrift_set_acl_entry_attribute(
                self.client, v6_acl_entry_id,
                action_counter=action_counter_ingress)

            send_packet(self, self.dev_port11, self.v6_pkt)
            verify_packet(self, self.v6_exp_pkt_acl, self.dev_port10)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter_ingress, packets=True)
            self.assertEqual(packets['packets'], 1)
            print("pass v6 packet w/ mapped dscp value 1 -> 10")

        finally:
            #  delete v6 acl entry and counters
            sai_thrift_set_switch_attribute(self.client, ingress_acl=0)
            action_counter_ingress = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=0),
                enable=True)
            sai_thrift_set_acl_entry_attribute(
                self.client, v6_acl_entry_id,
                action_counter=action_counter_ingress)
            sai_thrift_set_acl_counter_attribute(
                self.client, acl_counter_ingress, packets=None)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter_ingress, packets=True)
            self.assertEqual(packets['packets'], 0)
            sai_thrift_remove_acl_counter(self.client, acl_counter_ingress)
            sai_thrift_remove_acl_entry(self.client, v6_acl_entry_id)


##########################################################################
#  Egress Acls Below


@group('acl2')
class EgressAclTablesAllFieldTest(SaiHelper):
    """
    Verify matching on all fields of all Egress Acl Tables
    """
    # pylint: disable=bad-whitespace,line-too-long
    table_rules = [
        #    field        ,      field value 1       ,     field value 2         ,traffic,matches,V4-Acl,V6-Acl,Qos-Acl,  Mir-Acl,  # noqa
        # ========================================================================================================================  # noqa
        ['dst_ip',            {'ip4': '10.10.50.100'}, {'ip4': '255.255.255.255'},   'v4',  'lag',  True, False,   True,    True],  # noqa
        ['dst_ip',            {'ip4': '55.55.55.100'}, {'ip4': '255.255.255.255'},   'v4', 'port',  True, False,   True,    True],  # noqa
        ['src_ip',          {'ip4': '100.55.155.100'},   {'ip4': '255.255.255.0'},   'v4', 'both',  True, False,   True,    True],  # noqa
        ['outer_vlan_id',                {'u16': 200},              {'u16': 4095}, 'both',  'lag',  True,  True,   True,    True],  # noqa
        ['ip_protocol',                     {'u8': 6},                {'u8': 127}, 'both', 'port',  True,  True,   True,    True],  # noqa
        ['ip_protocol',                    {'u8': 17},                 {'u8': 63}, 'both',  'lag',  True,  True,   True,    True],  # noqa
        ['dscp',                           {'u8': 14},                 {'u8': 63}, 'both', 'both',  True,  True,   True,    True],  # noqa
        ['ecn',                             {'u8': 0},                  {'u8': 3}, 'both', 'port',  True,  True,   True,    True],  # noqa
        ['ecn',                             {'u8': 2},                  {'u8': 3}, 'both',  'lag',  True,  True,   True,    True],  # noqa
        ['tcp_flags',                      {'u8': 41},                 {'u8': 63}, 'both', 'port',  True,  True,   True,    True],  # noqa
        ['icmp_code',                      {'u8': 25},                {'u8': 127},   'v4', 'port',  True, False,   True,    True],  # noqa
        ['icmp_type',                      {'u8': 40},                 {'u8': 63},   'v4', 'port',  True, False,   True,    True],  # noqa
        ['icmp_code',                      {'u8': 55},                {'u8': 127},   'v4',  'lag',  True, False,   True,    True],  # noqa
        ['icmp_type',                       {'u8': 5},                {'u8': 127},   'v4',  'lag',  True, False,   True,    True],  # noqa
        ['l4_src_port',                 {'u16': 4444},             {'u16': 32767}, 'both', 'both',  True,  True,   True,    True],  # noqa
        ['l4_dst_port',                {'u16': 28055},             {'u16': 32767}, 'both',  'lag',  True,  True,   True,    True],  # noqa
        ['l4_dst_port',                 {'u16': 5555},              {'u16': 8191}, 'both', 'port',  True,  True,   True,    True],  # noqa

        ['ipv6_next_header',                {'u8': 6},                 {'u8': 31},   'v6', 'port', False,  True,   True,    True],  # noqa
        ['ipv6_next_header',               {'u8': 17},                 {'u8': 63},   'v6',  'lag', False,  True,   True,    True],  # noqa
        ['icmpv6_code',                    {'u8': 25},                {'u8': 127},   'v6', 'port', False,  True,   True,    True],  # noqa
        ['icmpv6_type',                    {'u8': 40},                 {'u8': 63},   'v6', 'port', False,  True,   True,    True],  # noqa
        ['icmpv6_code',                    {'u8': 55},                {'u8': 127},   'v6',  'lag', False,  True,   True,    True],  # noqa
        ['icmpv6_type',                     {'u8': 5},                {'u8': 127},   'v6',  'lag', False,  True,   True,    True],  # noqa
        ['src_ipv6',
         {'ip6': '1234:5678:8ab4:5ef0:4422:1133:5500:55aa'},
         {'ip6': 'FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF'},                         'v6', 'both', False,  True,   True,    True],  # noqa
        ['dst_ipv6',                   {'ip6': '2000::100'},
         {'ip6': 'FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:0000'},                         'v6', 'port', False,  True,   True,    True],  # noqa
        ['dst_ipv6',              {'ip6': '5000::1000:100'},
         {'ip6': 'FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FF00'},                         'v6',  'lag', False,  True,   True,    True]   # noqa
        # ["{'eth_type': 0x0800, 'eth_type_mask': 0x7FFF}", True, None],
    ]
    # pylint: enable=bad-whitespace,line-too-long

    src_ip = '100.55.155.100'
    src_mac = '00:11:22:33:44:55'
    port_dst_mac = '00:22:22:22:22:22'
    lag_dst_mac = '00:44:44:44:44:44'
    port_dst_ip_subnet = '55.55.55.100/24'
    lag_dst_ip_subnet = '10.10.50.0/24'
    port_dst_ip = '55.55.55.100'
    lag_dst_ip = '10.10.50.100'
    tcp_dst_port = 5555
    tcp_src_port = 4444
    udp_dst_port = 28055
    udp_src_port = 4444

    src_v6 = '1234:5678:8ab4:5ef0:4422:1133:5500:55aa'
    port_dst_v6_subnet = '2000::0/114'
    lag_dst_v6_subnet = '5000::1000:100/128'
    port_dst_v6 = '2000::100'
    lag_dst_v6 = '5000::1000:100'
    dscp_val = 14
    ecn_val = 2
    tos_val = dscp_val << 2 | ecn_val

    high_prio = 500
    low_prio = 50
    lower_prio = 5

    def setUp(self):
        super(EgressAclTablesAllFieldTest, self).setUp()

        #  lag  as vlan 200 member, allocate rif for vlan 200
        self.vlan200 = sai_thrift_create_vlan(self.client, vlan_id=200)
        self.vlan_member1 = sai_thrift_create_vlan_member(
            self.client,
            vlan_id=self.vlan200,
            bridge_port_id=self.lag2_bp,
            vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_TAGGED)
        self.vlan200_rif = sai_thrift_create_router_interface(
            self.client,
            type=SAI_ROUTER_INTERFACE_TYPE_VLAN,
            virtual_router_id=self.default_vrf,
            vlan_id=self.vlan200)

        ingress_rif = self.port10_rif
        egress_rif1 = self.port11_rif
        egress_rif2 = self.vlan200_rif

        #  allocate v4 neighbor, nhop, route for port 11
        print("Allocate V4 neighbor with ip %s, router interface %x"
              " dst_mac %s "
              % (self.port_dst_ip, egress_rif1, self.port_dst_mac))
        self.port_nbr_entry = sai_thrift_neighbor_entry_t(
            rif_id=egress_rif1,
            ip_address=sai_ipaddress(self.port_dst_ip))
        sai_thrift_create_neighbor_entry(
            self.client,
            self.port_nbr_entry,
            dst_mac_address=self.port_dst_mac)

        print("Allocate nhop with ip %s, router interface %x"
              % (self.port_dst_ip, egress_rif1))
        self.port_nhop = sai_thrift_create_next_hop(
            self.client,
            ip=sai_ipaddress(self.port_dst_ip),
            router_interface_id=egress_rif1,
            type=SAI_NEXT_HOP_TYPE_IP)

        print("Allocate route with ip subnet %s --> port 11  "
              % (self.port_dst_ip_subnet))
        self.port_route_entry = sai_thrift_route_entry_t(
            vr_id=self.default_vrf,
            destination=sai_ipprefix(self.port_dst_ip_subnet))
        sai_thrift_create_route_entry(
            self.client,
            self.port_route_entry,
            next_hop_id=egress_rif1)

        #  allocate v4 neighbor, nhop, route for lag 2
        print("Allocate V4 neighbor with ip %s, router interface %x"
              " dst_mac %s "
              % (self.lag_dst_ip, egress_rif2, self.lag_dst_mac))
        self.nbr_entry = sai_thrift_neighbor_entry_t(
            rif_id=egress_rif2,
            ip_address=sai_ipaddress(self.lag_dst_ip))
        sai_thrift_create_neighbor_entry(
            self.client,
            self.nbr_entry,
            dst_mac_address=self.lag_dst_mac)

        print("Allocate nhop with ip %s, router interface %x"
              % (self.lag_dst_ip, egress_rif2))
        self.nhop = sai_thrift_create_next_hop(
            self.client,
            ip=sai_ipaddress(self.lag_dst_ip),
            router_interface_id=egress_rif2,
            type=SAI_NEXT_HOP_TYPE_IP)

        print("Allocate route with ip subnet %s --> lag 2  "
              % (self.lag_dst_ip_subnet))
        self.route_entry = sai_thrift_route_entry_t(
            vr_id=self.default_vrf,
            destination=sai_ipprefix(self.lag_dst_ip_subnet))
        sai_thrift_create_route_entry(
            self.client,
            self.route_entry,
            next_hop_id=egress_rif2)

        print("Add static fdb for lag 2")
        self.fdb = sai_thrift_fdb_entry_t(
            switch_id=self.switch_id,
            mac_address=self.lag_dst_mac,
            bv_id=self.vlan200)
        sai_thrift_create_fdb_entry(self.client,
                                    self.fdb,
                                    type=SAI_FDB_ENTRY_TYPE_STATIC,
                                    bridge_port_id=self.lag2_bp)

        #  allocate v6 neighbor, nhop, route for port 11
        print("Allocate V6 neighbor with ip %s, router interface %x"
              " dst_mac %s "
              % (self.port_dst_v6, egress_rif1, self.port_dst_mac))
        self.port_v6_nbr_entry = sai_thrift_neighbor_entry_t(
            rif_id=egress_rif1,
            ip_address=sai_ipaddress(self.port_dst_v6))
        sai_thrift_create_neighbor_entry(
            self.client,
            self.port_v6_nbr_entry,
            dst_mac_address=self.port_dst_mac)

        print("Allocate v6 nhop with ip %s, router interface %x"
              % (self.port_dst_v6, egress_rif1))
        self.port_v6_nhop = sai_thrift_create_next_hop(
            self.client,
            ip=sai_ipaddress(self.port_dst_v6),
            router_interface_id=egress_rif1,
            type=SAI_NEXT_HOP_TYPE_IP)

        print("Allocate v6 route with ip prefix %s --> nhop %x [port 11]  "
              % (self.port_dst_v6_subnet, self.port_v6_nhop))
        self.port_v6_route_entry = sai_thrift_route_entry_t(
            vr_id=self.default_vrf,
            destination=sai_ipprefix(self.port_dst_v6_subnet))
        sai_thrift_create_route_entry(
            self.client,
            self.port_v6_route_entry,
            next_hop_id=self.port_v6_nhop)

        #  allocate v6 neighbor, nhop, route for lag 2
        print("Allocate V6 neighbor with ip %s, router interface %x"
              " dst_mac %s "
              % (self.lag_dst_v6, egress_rif2, self.lag_dst_mac))
        self.v6_nbr_entry = sai_thrift_neighbor_entry_t(
            rif_id=egress_rif2,
            ip_address=sai_ipaddress(self.lag_dst_v6))
        sai_thrift_create_neighbor_entry(
            self.client,
            self.v6_nbr_entry,
            dst_mac_address=self.lag_dst_mac)

        print("Allocate v6 nhop with ip %s, router interface %x"
              % (self.lag_dst_v6, egress_rif2))
        self.v6_nhop = sai_thrift_create_next_hop(
            self.client,
            ip=sai_ipaddress(self.lag_dst_v6),
            router_interface_id=egress_rif2,
            type=SAI_NEXT_HOP_TYPE_IP)

        print("Allocate v6 route with ip prefix %s --> nhop %x --> lag 2  "
              % (self.lag_dst_v6_subnet, self.v6_nhop))
        self.v6_route_entry = sai_thrift_route_entry_t(
            vr_id=self.default_vrf,
            destination=sai_ipprefix(self.lag_dst_v6_subnet))
        sai_thrift_create_route_entry(
            self.client,
            self.v6_route_entry,
            next_hop_id=self.v6_nhop)

        #  ACL table group
        self.table_stage = SAI_ACL_STAGE_EGRESS

        bpoints = [SAI_ACL_BIND_POINT_TYPE_SWITCH]
        self.bpoint_type_list = sai_thrift_s32_list_t(
            count=len(bpoints), int32list=bpoints)
        group_type = SAI_ACL_TABLE_GROUP_TYPE_PARALLEL

        self.acl_group = sai_thrift_create_acl_table_group(
            self.client,
            acl_stage=self.table_stage,
            acl_bind_point_type_list=self.bpoint_type_list,
            type=group_type)
        sai_thrift_set_switch_attribute(
            self.client, egress_acl=self.acl_group)

        #  v4 pkt for out-port 11
        self.pkt = simple_tcp_packet(
            eth_dst=ROUTER_MAC,
            eth_src=self.src_mac,
            ip_dst=self.port_dst_ip,
            ip_src=self.src_ip,
            ip_id=105,
            tcp_sport=self.tcp_src_port,
            tcp_dport=self.tcp_dst_port,
            tcp_flags=41,
            ip_ttl=64,
            ip_dscp=self.dscp_val)
        self.e_pkt = simple_tcp_packet(
            eth_dst=self.port_dst_mac,
            eth_src=ROUTER_MAC,
            ip_dst=self.port_dst_ip,
            ip_src=self.src_ip,
            ip_id=105,
            tcp_sport=self.tcp_src_port,
            tcp_dport=self.tcp_dst_port,
            tcp_flags=41,
            ip_ttl=63,
            ip_dscp=self.dscp_val)
        #  v4 pkt for out-port lag 2
        self.lag_pkt = simple_udp_packet(
            eth_dst=ROUTER_MAC,
            eth_src=self.src_mac,
            ip_src=self.src_ip,
            ip_dst=self.lag_dst_ip,
            udp_sport=self.udp_src_port,
            udp_dport=self.udp_dst_port,
            pktlen=100,
            ip_ttl=64,
            ip_tos=self.tos_val)
        self.lag_e_tpkt = simple_udp_packet(
            eth_dst=self.lag_dst_mac,
            eth_src=ROUTER_MAC,
            dl_vlan_enable=True,
            vlan_vid=200,
            ip_src=self.src_ip,
            ip_dst=self.lag_dst_ip,
            udp_sport=self.udp_src_port,
            udp_dport=self.udp_dst_port,
            pktlen=104,
            ip_ttl=63,
            ip_tos=self.tos_val)
        self.lag_e_pkt = simple_udp_packet(
            eth_dst=self.lag_dst_mac,
            eth_src=ROUTER_MAC,
            ip_src=self.src_ip,
            ip_dst=self.lag_dst_ip,
            udp_sport=self.udp_src_port,
            udp_dport=self.udp_dst_port,
            pktlen=100,
            ip_ttl=63,
            ip_tos=self.tos_val)

        #  v4 icmp pkt for out-port 11
        self.icmp_pkt = simple_icmp_packet(
            eth_dst=ROUTER_MAC,
            eth_src=self.src_mac,
            ip_dst=self.port_dst_ip,
            ip_src=self.src_ip,
            icmp_type=40,
            icmp_code=25,
            ip_ttl=64,
            ip_dscp=self.dscp_val)
        self.e_icmp_pkt = simple_icmp_packet(
            eth_dst=self.port_dst_mac,
            eth_src=ROUTER_MAC,
            ip_dst=self.port_dst_ip,
            ip_src=self.src_ip,
            icmp_type=40,
            icmp_code=25,
            ip_ttl=63,
            ip_dscp=self.dscp_val)
        #  v4 icmp pkt for out-port lag 2
        self.lag_icmp_pkt = simple_icmp_packet(
            eth_dst=ROUTER_MAC,
            eth_src=self.src_mac,
            ip_src=self.src_ip,
            ip_dst=self.lag_dst_ip,
            icmp_type=5,
            icmp_code=55,
            pktlen=64,
            ip_ttl=64,
            ip_tos=self.tos_val)
        self.lag_e_icmp_tpkt = simple_icmp_packet(
            eth_dst=self.lag_dst_mac,
            eth_src=ROUTER_MAC,
            dl_vlan_enable=True,
            vlan_vid=200,
            ip_src=self.src_ip,
            ip_dst=self.lag_dst_ip,
            icmp_type=5,
            icmp_code=55,
            pktlen=68,
            ip_ttl=63,
            ip_tos=self.tos_val)
        self.lag_e_icmp_pkt = simple_icmp_packet(
            eth_dst=self.lag_dst_mac,
            eth_src=ROUTER_MAC,
            ip_src=self.src_ip,
            ip_dst=self.lag_dst_ip,
            icmp_type=5,
            icmp_code=55,
            pktlen=64,
            ip_ttl=63,
            ip_tos=self.tos_val)

        #  v6 pkt for out-port 11
        self.pkt6 = simple_tcpv6_packet(
            eth_dst=ROUTER_MAC,
            eth_src=self.src_mac,
            ipv6_dst=self.port_dst_v6,
            ipv6_src=self.src_v6,
            tcp_sport=self.tcp_src_port,
            tcp_dport=self.tcp_dst_port,
            tcp_flags=41,
            ipv6_hlim=64,
            ipv6_dscp=self.dscp_val)
        self.e_pkt6 = simple_tcpv6_packet(
            eth_dst=self.port_dst_mac,
            eth_src=ROUTER_MAC,
            ipv6_dst=self.port_dst_v6,
            ipv6_src=self.src_v6,
            tcp_sport=self.tcp_src_port,
            tcp_dport=self.tcp_dst_port,
            tcp_flags=41,
            ipv6_hlim=63,
            ipv6_dscp=self.dscp_val)
        #  v6 pkt for out-port lag 2
        self.lag_pkt6 = simple_udpv6_packet(
            eth_dst=ROUTER_MAC,
            eth_src=self.src_mac,
            ipv6_src=self.src_v6,
            ipv6_dst=self.lag_dst_v6,
            udp_sport=self.udp_src_port,
            udp_dport=self.udp_dst_port,
            pktlen=40+14,
            ipv6_hlim=64,
            ipv6_tc=self.tos_val)
        self.lag_e_tpkt6 = simple_udpv6_packet(
            eth_dst=self.lag_dst_mac,
            eth_src=ROUTER_MAC,
            dl_vlan_enable=True,
            vlan_vid=200,
            ipv6_src=self.src_v6,
            ipv6_dst=self.lag_dst_v6,
            udp_sport=self.udp_src_port,
            udp_dport=self.udp_dst_port,
            pktlen=40+18,
            ipv6_hlim=63,
            ipv6_tc=self.tos_val)
        self.lag_e_pkt6 = simple_udpv6_packet(
            eth_dst=self.lag_dst_mac,
            eth_src=ROUTER_MAC,
            ipv6_src=self.src_v6,
            ipv6_dst=self.lag_dst_v6,
            udp_sport=self.udp_src_port,
            udp_dport=self.udp_dst_port,
            pktlen=40+14,
            ipv6_hlim=63,
            ipv6_tc=self.tos_val)

        #  v6 icmp pkt for out-port 11
        self.icmp_pkt6 = simple_icmpv6_packet(
            eth_dst=ROUTER_MAC,
            eth_src=self.src_mac,
            ipv6_dst=self.port_dst_v6,
            ipv6_src=self.src_v6,
            icmp_type=40,
            icmp_code=25,
            ipv6_hlim=64,
            ipv6_dscp=self.dscp_val)
        self.e_icmp_pkt6 = simple_icmpv6_packet(
            eth_dst=self.port_dst_mac,
            eth_src=ROUTER_MAC,
            ipv6_dst=self.port_dst_v6,
            ipv6_src=self.src_v6,
            icmp_type=40,
            icmp_code=25,
            ipv6_hlim=63,
            ipv6_dscp=self.dscp_val)
        #  v6 icmp pkt for out-port lag 2
        self.lag_icmp_pkt6 = simple_icmpv6_packet(
            eth_dst=ROUTER_MAC,
            eth_src=self.src_mac,
            ipv6_src=self.src_v6,
            ipv6_dst=self.lag_dst_v6,
            icmp_type=5,
            icmp_code=55,
            pktlen=64,
            ipv6_hlim=64,
            ipv6_tc=self.tos_val)
        self.lag_e_icmp_tpkt6 = simple_icmpv6_packet(
            eth_dst=self.lag_dst_mac,
            eth_src=ROUTER_MAC,
            dl_vlan_enable=True,
            vlan_vid=200,
            ipv6_src=self.src_v6,
            ipv6_dst=self.lag_dst_v6,
            icmp_type=5,
            icmp_code=55,
            pktlen=68,
            ipv6_hlim=63,
            ipv6_tc=self.tos_val)
        self.lag_e_icmp_pkt6 = simple_icmpv6_packet(
            eth_dst=self.lag_dst_mac,
            eth_src=ROUTER_MAC,
            ipv6_src=self.src_v6,
            ipv6_dst=self.lag_dst_v6,
            icmp_type=5,
            icmp_code=55,
            pktlen=64,
            ipv6_hlim=63,
            ipv6_tc=self.tos_val)

    def AllTrafficTest(self,
                       table_type,
                       pkt_test_type="v4",
                       exact_match_on=None,
                       port_counter=None,
                       lag_counter=None,
                       icmp_pkt=False):
        '''
        Verify v4/v6 tcp/udp/icmp traffic test for
        egress ACl tables/entries
        '''
        print("    Test with %s traffic on port/lag " % (pkt_test_type))

        if pkt_test_type != "v4" and pkt_test_type != "v6":
            print("    Incorrect traffic pkt type, must be v4 or v6 ")
            return

        if port_counter is not None:
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, port_counter, packets=True)
            port_counter_cnt = packets['packets']

        if lag_counter is not None:
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, lag_counter, packets=True)
            lag_counter_cnt = packets['packets']

        print('   -----------------------------------------------------------')
        if icmp_pkt:
            if pkt_test_type == "v6":
                port_pkt = self.icmp_pkt6
                port_e_pkt = self.e_icmp_pkt6
                print("    Tx below V6 icmp packet from port 10 --> port 11 ")
                print("     [%s to %s], icmp code 25 type 40 "
                      % (self.src_v6, self.port_dst_v6))
            else:
                port_pkt = self.icmp_pkt
                port_e_pkt = self.e_icmp_pkt
                print("    Tx below V4 icmp packet from port 10 --> port 11 ")
                print("     [%s to %s], icmp code 25 type 40 "
                      % (self.src_ip, self.port_dst_ip))
        else:
            if pkt_test_type == "v6":
                port_pkt = self.pkt6
                port_e_pkt = self.e_pkt6
                print("    Tx below V6 tcp packet from port 10 --> port 11 ")
                print("     [%s to %s] " % (self.src_v6, self.port_dst_v6))
                print("     L4 port src [%d] dst [%d], flags 41, ip dscp 14"
                      % (self.tcp_src_port, self.tcp_dst_port))
            else:
                port_pkt = self.pkt
                port_e_pkt = self.e_pkt
                print("    Tx below V4 tcp packet from port 10 --> port 11 ")
                print("     [%s to %s] " % (self.src_ip, self.port_dst_ip))
                print("     L4 port src [%d] dst [%d], flags 41, ip dscp 14"
                      % (self.tcp_src_port, self.tcp_dst_port))

        ''' todo
        #  Qos Acl set-tc action --> verify tc-dscp map
        #  To verify, change Rx pkt to have new tos value
        #  For port catch-all entry action tc 10 --> 40 dscp
        if table_type == "Qos-Acl":
            temp_e_pkt = port_e_pkt.copy()
            if pkt_test_type == "v6":
                temp_e_pkt[IPv6].tc = 40 << 2
            else:
                temp_e_pkt[IP].tos = 40 << 2
            port_e_pkt = temp_e_pkt
        '''

        #  verify traffic for acl rule on port
        send_packet(self, self.dev_port10, port_pkt)
        if port_counter is None or exact_match_on == 'lag':
            #  verify port catch-all entry action/stats
            if table_type == "Mir-Acl":
                print("      ----> route to port 11 [catch-all action]  ")
                print("      ----> mirror in-pkt to port 4 [catch-all]  ")
                verify_each_packet_on_each_port(
                    self,
                    [port_e_pkt, port_e_pkt],
                    [self.dev_port11, self.catch_all_rx_m_port])
            else:
                print("      ----> route to port 11 [catch-all action]  ")
                verify_packets(self, port_e_pkt, [self.dev_port11])
            self.port_catch_all_cnt += 1
            time.sleep(1)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, self.port_catch_all_counter, packets=True)
            self.assertEqual(packets['packets'], self.port_catch_all_cnt)
        else:
            #  verify port rule entry action/stats
            if table_type == "Qos-Acl":
                ''' todo
                #  Qos Acl set-tc action --> verify tc-dscp map
                #  To verify, change Rx pkt to have new tos value
                #  For port rule entry action tc 7 --> 25 dscp
                if pkt_test_type == "v6":
                    port_e_pkt[IPv6].tc = 25 << 2
                else:
                    port_e_pkt[IP].tos = 25 << 2
                #  pkt will still be forw here
                print("      ----> route to port 10, with 25 dscp  ")
                verify_packets(self, port_e_pkt, [self.dev_port10])
                '''
                pass
            elif table_type == "Mir-Acl":
                #  pkt will be forw here
                #  out-pkt will also get mirror
                print("      ----> route to port 11  ")
                print("      ----> mirror out-pkt to port 12  ")
                verify_each_packet_on_each_port(
                    self,
                    [port_e_pkt, port_e_pkt],
                    [self.dev_port11, self.port_rule_rx_m_port])
            else:
                #  pkt will get drop for v4/v6 acl
                print("      ----> drop ")
                verify_no_other_packets(self, timeout=1)
            port_counter_cnt += 1
            time.sleep(1)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, port_counter, packets=True)
            self.assertEqual(packets['packets'], port_counter_cnt)
        print('   -----------------------------------------------------------')

        if icmp_pkt:
            if pkt_test_type == "v6":
                lag_pkt = self.lag_icmp_pkt6
                lag_e_pkt = self.lag_e_icmp_pkt6
                lag_e_tpkt = self.lag_e_icmp_tpkt6
                print("    Tx below V6 icmp packet from port 10 --> lag 2  ")
                print("     [%s to %s]" % (self.src_v6, self.lag_dst_v6))
                print("     Vlan 200, icmp code 55 type 5 ")
            else:
                lag_pkt = self.lag_icmp_pkt
                lag_e_pkt = self.lag_e_icmp_pkt
                lag_e_tpkt = self.lag_e_icmp_tpkt
                print("    Tx below V4 icmp packet from port 10 --> lag 2  ")
                print("     [%s to %s]" % (self.src_ip, self.lag_dst_ip))
                print("     Vlan 200, icmp code 55 type 5 ")
        else:
            if pkt_test_type == "v6":
                lag_pkt = self.lag_pkt6
                lag_e_pkt = self.lag_e_pkt6
                lag_e_tpkt = self.lag_e_tpkt6
                print("    Tx below V6 udp packet from port 10 --> lag 2  ")
                print("     [%s to %s]" % (self.src_v6, self.lag_dst_v6))
                print("     Vlan 200, L4 port src [%d] dst [%d], ip tos 58 "
                      % (self.udp_src_port, self.udp_dst_port))
            else:
                lag_pkt = self.lag_pkt
                lag_e_pkt = self.lag_e_pkt
                lag_e_tpkt = self.lag_e_tpkt
                print("    Tx below V4 udp packet from port 10 --> lag 2 ")
                print("     [%s to %s]" % (self.src_ip, self.lag_dst_ip))
                print("     Vlan 200, L4 port src [%d] dst [%d], ip tos 58 "
                      % (self.udp_src_port, self.udp_dst_port))

        ''' todo
        #  Qos Acl set-tc action --> verify tc-dscp map
        #  To verify, change Rx pkt to have new tos value
        #  For lag catch-all entry action tc 10 --> 40 dscp
        if table_type == "Qos-Acl":
            temp_e_pkt = lag_e_pkt.copy()
            if pkt_test_type == "v6":
                temp_e_pkt[IPv6].tc = 40 << 2 | self.ecn_val
            else:
                temp_e_pkt[IP].tos = 40 << 2 | self.ecn_val
            lag_e_pkt = temp_e_pkt
        '''

        lag2_plist = [self.dev_port7, self.dev_port8, self.dev_port9]

        #  verify traffic for acl rule on lag
        send_packet(self, self.dev_port10, lag_pkt)
        if lag_counter is None or exact_match_on == 'port':
            #  verify lag catch-all entry action/stats
            if table_type == "Mir-Acl":
                print("      ----> route to lag 2 [catch-all action]  ")
                print("      ----> mirror out-pkt to port 4 [catch-all]  ")
                verify_each_packet_on_multiple_port_lists(
                    self, [lag_e_tpkt, lag_e_tpkt],
                    [lag2_plist, [self.catch_all_rx_m_port]])
            else:
                print("      ----> route to lag 2 [catch-all action]  ")
                verify_packet_any_port(self, lag_e_tpkt, lag2_plist)
            self.lag_catch_all_cnt += 1
            time.sleep(1)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, self.lag_catch_all_counter, packets=True)
            self.assertEqual(packets['packets'], self.lag_catch_all_cnt)
        else:
            #  verify lag rule entry action/stats
            if table_type == "Qos-Acl":
                """
                todo - change pkt based of action
                #  Qos Acl set-tc action --> verify tc-dscp map
                #  To verify, change Rx pkt to have new tos value
                #  For lag rule entry action tc 5 --> 55 dscp
                if pkt_test_type == "v6":
                    lag_e_pkt[IPv6].tc = 55 << 2 | self.ecn_val
                else:
                    lag_e_pkt[IP].tos = 55 << 2 | self.ecn_val
                #  pkt will still be forw here
                print("      ----> route to port 10, with 55 dscp  ")
                verify_packets(self, lag_e_pkt, [self.dev_port10])
                """
                pass
            elif table_type == "Mir-Acl":
                #  pkt will be forw here
                #  in-pkt will also get mirror
                print("      ----> route to lag 2  ")
                print("      ----> mirror out-pkt to port 14  ")
                verify_each_packet_on_multiple_port_lists(
                    self, [lag_e_tpkt, lag_e_tpkt],
                    [lag2_plist, [self.lag_rule_rx_m_port]])
            else:
                #  pkt will get drop for v4/v6 acl
                print("      ----> drop ")
                verify_no_other_packets(self, timeout=1)
            lag_counter_cnt += 1
            time.sleep(1)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, lag_counter, packets=True)
            self.assertEqual(packets['packets'], lag_counter_cnt)
        print('   -----------------------------------------------------------')

    def egressV4AclTableTest(self):
        '''
        Verify all the match fields, along with
        both port/lag as out-port field using switch
        b-point in ipv4 ACL table
        '''
        print(" egressV4AclTableTest")

        try:
            acl_range_type = sai_thrift_s32_list_t(count=0, int32list=[])
            acl_table = sai_thrift_create_acl_table(
                self.client,
                acl_stage=self.table_stage,
                acl_bind_point_type_list=self.bpoint_type_list,
                field_src_ip=True,
                field_dst_ip=True,
                field_ip_protocol=True,
                field_dscp=True,
                field_ecn=True,
                field_l4_src_port=True,
                field_l4_dst_port=True,
                field_tcp_flags=True,
                field_icmp_code=True,
                field_icmp_type=True,
                field_outer_vlan_id=True,
                field_out_port=True)
            self.assertNotEqual(acl_table, 0)

            acl_group_member = sai_thrift_create_acl_table_group_member(
                self.client,
                acl_table_group_id=self.acl_group,
                acl_table_id=acl_table)
            self.assertNotEqual(acl_group_member, 0)

            print("  V4-Acl catch all entry with action permit ")
            #  setup action for catch all entries
            action_forw = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    s32=SAI_PACKET_ACTION_FORWARD))
            a_type_t = "action_packet_action"
            a_value_t = {a_type_t: action_forw}

            self.testAllTableField(acl_table, a_value_t, "V4-Acl", "v4")

        finally:
            #  cleanup acl group member, table
            sai_thrift_remove_acl_table_group_member(
                self.client, acl_group_member)
            sai_thrift_remove_acl_table(self.client, acl_table)

    def egressV6AclTableTest(self):
        '''
        Verify all the match fields, along with
        both port/lag as out-port field using switch
        b-point in V6 ACL table
        '''
        print(" egressV6AclTableTest")

        try:
            acl_range_type = sai_thrift_s32_list_t(count=0, int32list=[])
            v6_acl_table = sai_thrift_create_acl_table(
                self.client,
                acl_stage=self.table_stage,
                acl_bind_point_type_list=self.bpoint_type_list,
                field_src_ipv6=True,
                field_dst_ipv6=True,
                field_ip_protocol=True,
                field_ipv6_next_header=True,
                field_dscp=True,
                field_ecn=True,
                field_l4_src_port=True,
                field_l4_dst_port=True,
                field_tcp_flags=True,
                field_icmpv6_code=True,
                field_icmpv6_type=True,
                field_outer_vlan_id=True,
                field_out_port=True)
            self.assertNotEqual(v6_acl_table, 0)

            acl_group_member = sai_thrift_create_acl_table_group_member(
                self.client,
                acl_table_group_id=self.acl_group,
                acl_table_id=v6_acl_table)
            self.assertNotEqual(acl_group_member, 0)

            print("  V6-Acl catch all entry with action permit ")
            #  setup action for catch all entries
            action_forw = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    s32=SAI_PACKET_ACTION_FORWARD))
            a_type_t = "action_packet_action"
            a_value_t = {a_type_t: action_forw}

            self.testAllTableField(v6_acl_table, a_value_t, "V6-Acl", "v6")

        finally:
            #  cleanup acl group member, table
            sai_thrift_remove_acl_table_group_member(
                self.client, acl_group_member)
            sai_thrift_remove_acl_table(self.client, v6_acl_table)

    def egressQosAclTableTest(self):
        '''
        Verify all the match fields, along with
        both port/lag as out-port field using switch
        b-point in QoS ACL table
        '''
        print(" egressQosAclTableTest")

        try:
            action_type = [SAI_ACL_ACTION_TYPE_SET_ECN]
            qos_action_type_list = sai_thrift_s32_list_t(
                count=len(action_type), int32list=action_type)

            acl_range_type = sai_thrift_s32_list_t(count=0, int32list=[])
            qos_acl_table = sai_thrift_create_acl_table(
                self.client,
                acl_stage=self.table_stage,
                acl_bind_point_type_list=self.bpoint_type_list,
                field_src_ip=True,
                field_dst_ip=True,
                field_src_ipv6=True,
                field_dst_ipv6=True,
                field_ip_protocol=True,
                field_ipv6_next_header=True,
                field_dscp=True,
                field_ecn=True,
                field_l4_src_port=True,
                field_l4_dst_port=True,
                field_tcp_flags=True,
                field_icmp_code=True,
                field_icmp_type=True,
                field_icmpv6_code=True,
                field_icmpv6_type=True,
                field_outer_vlan_id=True,
                field_out_port=True,
                acl_action_type_list=qos_action_type_list)
            self.assertNotEqual(qos_acl_table, 0)

            acl_group_member = sai_thrift_create_acl_table_group_member(
                self.client,
                acl_table_group_id=self.acl_group,
                acl_table_id=qos_acl_table)
            self.assertNotEqual(acl_group_member, 0)

            """
            todo - setup things to reflect set-ecn, catch-all
            #  map all tc values with color green to dscp
            #  This will change the dscp value on egress
            #  based of tc value set by qos Acl entry
            egress_tc_color_list = [
                [10, 0],
                [7, 0],
                [8, 0],
                [5, 0],  # green
            ]
            egress_dscp_list = [
                40, 25, 18, 55,  # mapping green
            ]
            qos_tc_color_to_dscp_map = create_and_verify_qos_map(
                self.client,
                SAI_QOS_MAP_TYPE_TC_AND_COLOR_TO_DSCP,
                egress_tc_color_list,
                egress_dscp_list)
            self.assertTrue(qos_tc_color_to_dscp_map != 0,
                            "  Fail to alloc tc_color_to_dscp map  ")

            #  map above qos map to egress port
            status = sai_thrift_set_port_attribute(
                self.client,
                self.port10,
                qos_tc_and_color_to_dscp_map=qos_tc_color_to_dscp_map)
            self.assertEqual(status, SAI_STATUS_SUCCESS,
                             "  Fail to set tc_color_to_dscp map to port 10  ")
            attr = sai_thrift_get_port_attribute(
                self.client, self.port10,
                qos_tc_and_color_to_dscp_map=True)
            self.assertEqual(attr['qos_tc_and_color_to_dscp_map'],
                             qos_tc_color_to_dscp_map)

            print("  Qos Acl catch all entry action set-tc to 10-->40 dscp  ")
            #  setup action for catch all entries
            action_tc_set = sai_thrift_acl_action_data_t(
                enable=True,
                parameter=sai_thrift_acl_action_parameter_t(u8=10))
            a_type_t = "action_set_ecn"
            a_value_t = {a_type_t: action_tc_set}
            """
            self.testAllTableField(qos_acl_table, a_value_t, "Qos-Acl", "v4")
            self.testAllTableField(qos_acl_table, a_value_t, "Qos-Acl", "v6")

        finally:
            """
            #  cleanup egress qos map
            status = sai_thrift_set_port_attribute(
                self.client, self.port10,
                qos_tc_and_color_to_dscp_map=0)
            self.assertEqual(status, SAI_STATUS_SUCCESS,
                             "  Fail to reset tc_color_to_dscp for port 10  ")
            sai_thrift_remove_qos_map(self.client, qos_tc_color_to_dscp_map)
            """

            #  cleanup acl group member, table
            sai_thrift_remove_acl_table_group_member(
                self.client, acl_group_member)
            sai_thrift_remove_acl_table(self.client, qos_acl_table)

    def egressMirrorAclTableTest(self):
        '''
        Verify all the match fields, along with
        both port/lag as ot-port field using switch
        b-point in IP Mirror ACL table
        '''
        print(" egressMirrorAclTableTest ")

        self.catch_all_rx_m_port = self.dev_port4
        self.catch_all_m_port = self.port4
        self.port_rule_rx_m_port = self.dev_port12
        self.port_rule_m_port = self.port12
        self.lag_rule_rx_m_port = self.dev_port14
        self.lag_rule_m_port = self.port14

        try:
            action_type = [SAI_ACL_ACTION_TYPE_MIRROR_EGRESS]
            action_type_list = sai_thrift_s32_list_t(
                count=len(action_type), int32list=action_type)

            acl_range_type = sai_thrift_s32_list_t(count=0, int32list=[])
            mir_acl_table = sai_thrift_create_acl_table(
                self.client,
                acl_stage=self.table_stage,
                acl_bind_point_type_list=self.bpoint_type_list,
                field_src_ip=True,
                field_dst_ip=True,
                field_src_ipv6=True,
                field_dst_ipv6=True,
                field_ip_protocol=True,
                field_ipv6_next_header=True,
                field_dscp=True,
                field_ecn=True,
                field_l4_src_port=True,
                field_l4_dst_port=True,
                field_tcp_flags=True,
                field_icmp_code=True,
                field_icmp_type=True,
                field_icmpv6_code=True,
                field_icmpv6_type=True,
                field_outer_vlan_id=True,
                field_out_port=True,
                acl_action_type_list=action_type_list)
            self.assertNotEqual(mir_acl_table, 0)

            acl_group_member = sai_thrift_create_acl_table_group_member(
                self.client,
                acl_table_group_id=self.acl_group,
                acl_table_id=mir_acl_table)
            self.assertNotEqual(acl_group_member, 0)

            #  alloc mirror port 4 for catch all rule
            self.catch_all_mirror_session = sai_thrift_create_mirror_session(
                self.client,
                monitor_port=self.catch_all_m_port,
                type=SAI_MIRROR_SESSION_TYPE_LOCAL)
            #  alloc mirror port 12 for rule matching out-port 11
            self.port_entry_mirror_session = sai_thrift_create_mirror_session(
                self.client,
                monitor_port=self.port_rule_m_port,
                type=SAI_MIRROR_SESSION_TYPE_LOCAL)
            #  alloc mirror port 14 for rule matching out-port lag 2
            self.lag_entry_mirror_session = sai_thrift_create_mirror_session(
                self.client,
                monitor_port=self.lag_rule_m_port,
                type=SAI_MIRROR_SESSION_TYPE_LOCAL)

            print("  IP Mirror Acl catch all entry action out-mirror port 4 ")
            #  setup action for catch all entries
            mirror_session_list = sai_thrift_object_list_t(
                count=1, idlist=[self.catch_all_mirror_session])
            action_mirror = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    objlist=mirror_session_list))
            a_type_t = "action_mirror_egress"
            a_value_t = {a_type_t: action_mirror}

            self.testAllTableField(mir_acl_table, a_value_t, "Mir-Acl", "v4")
            self.testAllTableField(mir_acl_table, a_value_t, "Mir-Acl", "v6")

        finally:
            #  cleanup mirror sessions
            sai_thrift_remove_mirror_session(
                self.client,
                self.catch_all_mirror_session)
            sai_thrift_remove_mirror_session(
                self.client,
                self.port_entry_mirror_session)
            sai_thrift_remove_mirror_session(
                self.client,
                self.lag_entry_mirror_session)

            #  cleanup acl group member, table
            sai_thrift_remove_acl_table_group_member(
                self.client, acl_group_member)
            sai_thrift_remove_acl_table(self.client, mir_acl_table)

    def setPortLagRuleAction(self, table_type):
        print("  Set rule action for port/lag in %s Table " % table_type)

        #   action config for every port/lag rule
        if table_type == "V4-Acl" or table_type == "V6-Acl":
            """
            V4/V6 Acl rule matching actions
                Matching on out-port 11
                    --> action drop
                Matching on out-port lag 2
                    --> action drop
            """
            print("  Set port/lag %s rule action to drop  " % table_type)
            action_value = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    s32=SAI_PACKET_ACTION_DROP))
            a_type_t = "action_packet_action"
            self.port_rule_action = {a_type_t: action_value}
            self.lag_rule_action = {a_type_t: action_value}
        elif table_type == "Qos-Acl":
            """
            Qos Acl rule matching actions
                Matching on out-port 11
                    --> route to port 11
                    --> action set-tc 7 --> 25 dscp
                Matching on out-port lag 2
                    --> route to lag 2
                    --> action set-tc 5 --> 55 dscp
            """
            """ todo - setup set-ecn for rules
            print("  Set port qos acl rule action to set-tc 7 --> 25 dscp  ")
            port_action_value = sai_thrift_acl_action_data_t(
                enable=True,
                parameter=sai_thrift_acl_action_parameter_t(u8=7))
            a_type_t = "action_set_ecn"
            self.port_rule_action = {a_type_t: port_action_value}

            print("  Set lag qos acl rule action to set-tc 5 --> 55 dscp  ")
            lag_action_value = sai_thrift_acl_action_data_t(
                enable=True,
                parameter=sai_thrift_acl_action_parameter_t(u8=5))
            self.lag_rule_action = {a_type_t: lag_action_value}
            """
            pass
        elif table_type == "Mir-Acl":
            """
            Mirror Acl rule matching actions
                Matching on out-port 11
                    --> route to port 11
                    --> action out-pkt mirror to port 12
                Matching on out-port lag 2
                    --> route to lag 2
                    --> action out-pkt mirror to port 14
            """
            print("  Set port mirror acl rule action out-mirror to port 12  ")
            mirror_session_list = sai_thrift_object_list_t(
                count=1, idlist=[self.port_entry_mirror_session])
            port_action_value = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    objlist=mirror_session_list))
            a_type_t = "action_mirror_egress"
            self.port_rule_action = {a_type_t: port_action_value}

            print("  Set lag mirror acl rule action out-mirror to port 14  ")
            mirror_session_list = sai_thrift_object_list_t(
                count=1, idlist=[self.lag_entry_mirror_session])
            lag_action_value = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    objlist=mirror_session_list))
            a_type_t = "action_mirror_egress"
            self.lag_rule_action = {a_type_t: lag_action_value}

    def testAllTableField(self, acl_table, action_catch_all,
                          table_type, pkt_test_type):
        print("  Test all match fields in %s Table with %s traffic "
              % (table_type, pkt_test_type))

        #  install/verify traffic with catch-all rules first
        print("  Acl catch all entry for out-port 11 ")
        out_port_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(oid=self.port11))
        port_catch_all_acl_entry = sai_thrift_create_acl_entry(
            self.client,
            table_id=acl_table,
            priority=self.lower_prio,
            field_out_port=out_port_t,
            **action_catch_all)
        self.assertNotEqual(port_catch_all_acl_entry, 0)

        #  ACL catch all counter for port 11
        self.port_catch_all_counter = sai_thrift_create_acl_counter(
            self.client, table_id=acl_table)
        #  Attach port catch all counter to port catch all entry
        action_counter_t = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=self.port_catch_all_counter),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, port_catch_all_acl_entry,
            action_counter=action_counter_t)

        print("  Acl catch all entry for out-port lag 2 ")
        out_lag_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(oid=self.lag2))
        lag_catch_all_acl_entry = sai_thrift_create_acl_entry(
            self.client,
            table_id=acl_table,
            priority=self.lower_prio,
            field_out_port=out_lag_t,
            **action_catch_all)
        self.assertNotEqual(lag_catch_all_acl_entry, 0)

        #  ACL catch all counter for lag 2
        self.lag_catch_all_counter = sai_thrift_create_acl_counter(
            self.client, table_id=acl_table)
        #  Attach lag catch all counter to lag catch all entry
        action_counter_t1 = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=self.lag_catch_all_counter),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, lag_catch_all_acl_entry,
            action_counter=action_counter_t1)

        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.port_catch_all_counter, packets=True)
        self.assertEqual(packets['packets'], 0)
        self.port_catch_all_cnt = packets['packets']

        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.lag_catch_all_counter, packets=True)
        self.assertEqual(packets['packets'], 0)
        self.lag_catch_all_cnt = packets['packets']

        print("  Test %s traffic only with catch-all acl entries "
              % (pkt_test_type))
        self.AllTrafficTest(table_type, pkt_test_type)

        no_action_counter = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=0),
            enable=True)

        self.setPortLagRuleAction(table_type)

        #  walk through the table_rules to install/verify/remove
        #  rule for each field
        for i_rule in self.table_rules:
            print("  ==================================================== ")
            print("  ---------- Rule/Field for %s -----------" % table_type)
            print("   Field type:       %s " % i_rule[0])
            print("   Field value1:     %s " % i_rule[1])
            print("   Field value2:     %s " % i_rule[2])
            print("   Field pkt type:   %s " % i_rule[3])
            print("   Field matches on: %s " % i_rule[4])
            print("   Field in V4-Acl:  %s " % i_rule[5])
            print("   Field in V6-Acl:  %s " % i_rule[6])
            print("   Field in Qos-Acl: %s " % i_rule[7])
            print("   Field in Mir-Acl: %s " % i_rule[8])
            print(" ")

            #  if field not part of this acl table type, continue
            if ((table_type == "V4-Acl" and i_rule[5] is False) or
                    (table_type == "V6-Acl" and i_rule[6] is False) or
                    (table_type == "Qos-Acl" and i_rule[7] is False) or
                    (table_type == "Mir-Acl" and i_rule[8] is False)):
                print("   Skip, rule field %s not part of table_type %s "
                      % (i_rule[0], table_type))
                continue

            #  if traffic type req for field i.e.[v4, v6] is not same
            #  as traffic type tested, continue
            if i_rule[3] != 'both' and pkt_test_type != i_rule[3]:
                print("   Skip rule field %s in table type %s, "
                      "  traffic req for this rule %s - testing %s traffic "
                      % (table_type, i_rule[0], i_rule[3], pkt_test_type))
                continue

            #  if fields are icmp param, use icmp packet
            icmp_pkt = False
            if ((i_rule[0] == 'icmp_code') or
                    (i_rule[0] == 'icmp_type') or
                    (i_rule[0] == 'icmpv6_code') or
                    (i_rule[0] == 'icmpv6_type')):
                icmp_pkt = True

            #  field value
            if i_rule[0] == 'acl_range_type':
                #  For acl range
                if i_rule[4] == 'lag':
                    range_type = SAI_ACL_RANGE_TYPE_L4_DST_PORT_RANGE
                else:
                    range_type = SAI_ACL_RANGE_TYPE_L4_SRC_PORT_RANGE
                u32range = sai_thrift_u32_range_t(
                    **i_rule[1], **i_rule[2])
                acl_range = sai_thrift_create_acl_range(
                    self.client,
                    type=range_type,
                    limit=u32range)
                range_list = [acl_range]
                print("  ACL range alloc 0x%lx for range type %d "
                      % (acl_range, range_type))

                field_value_t = sai_thrift_acl_field_data_t(
                    data=sai_thrift_acl_field_data_data_t(
                        objlist=sai_thrift_object_list_t(
                            count=len(range_list),
                            idlist=range_list)))
            else:
                #  For all other field
                field_value_t = sai_thrift_acl_field_data_t(
                    data=sai_thrift_acl_field_data_data_t(**i_rule[1]),
                    mask=sai_thrift_acl_field_data_mask_t(**i_rule[2]))

            field_t = 'field_'+i_rule[0]
            field_value = {field_t: field_value_t}

            #  program the rule with out-port port 11
            print("  Acl entry with field %s [%s %s], out-port 11 "
                  % (i_rule[0], i_rule[1], i_rule[2]))
            port_acl_entry = sai_thrift_create_acl_entry(
                self.client,
                table_id=acl_table,
                priority=self.low_prio,
                field_out_port=out_port_t,
                **self.port_rule_action,
                **field_value)
            self.assertNotEqual(port_acl_entry, 0)

            #  acl counter
            port_acl_counter = sai_thrift_create_acl_counter(
                self.client, table_id=acl_table)
            #  Attach acl counter to port acl entry
            port_action_counter = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=port_acl_counter),
                enable=True)
            sai_thrift_set_acl_entry_attribute(
                self.client, port_acl_entry,
                action_counter=port_action_counter)

            self.AllTrafficTest(table_type, pkt_test_type, i_rule[4],
                                port_acl_counter, None, icmp_pkt)

            #  program the rule with out-port lag 2
            print("  Acl entry with field %s [%s %s], out-port lag 2  "
                  % (i_rule[0], i_rule[1], i_rule[2]))
            lag_acl_entry = sai_thrift_create_acl_entry(
                self.client,
                table_id=acl_table,
                priority=self.low_prio,
                field_out_port=out_lag_t,
                **self.lag_rule_action,
                **field_value)
            self.assertNotEqual(lag_acl_entry, 0)

            #  acl counter
            lag_acl_counter = sai_thrift_create_acl_counter(
                self.client, table_id=acl_table)
            #  Attach acl counter to lag acl entry
            lag_action_counter = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=lag_acl_counter),
                enable=True)
            sai_thrift_set_acl_entry_attribute(
                self.client, lag_acl_entry,
                action_counter=lag_action_counter)

            self.AllTrafficTest(table_type, pkt_test_type, i_rule[4],
                                port_acl_counter, lag_acl_counter, icmp_pkt)

            #  cleanup acl entry, counter on lag 1
            sai_thrift_set_acl_entry_attribute(
                self.client, lag_acl_entry,
                action_counter=no_action_counter)
            sai_thrift_remove_acl_counter(self.client, lag_acl_counter)
            sai_thrift_remove_acl_entry(self.client, lag_acl_entry)

            #  cleanup acl entry, counter on port 11
            sai_thrift_set_acl_entry_attribute(
                self.client, port_acl_entry,
                action_counter=no_action_counter)
            sai_thrift_remove_acl_counter(self.client, port_acl_counter)
            sai_thrift_remove_acl_entry(self.client, port_acl_entry)

            #  cleanup acl range if exists
            if i_rule[0] == 'acl_range_type':
                sai_thrift_remove_acl_range(self.client, acl_range)

        #  cleanup catch all acl entry, counter on lag 1
        sai_thrift_set_acl_entry_attribute(
            self.client, lag_catch_all_acl_entry,
            action_counter=no_action_counter)
        sai_thrift_remove_acl_counter(self.client, self.lag_catch_all_counter)
        sai_thrift_remove_acl_entry(self.client, lag_catch_all_acl_entry)

        #  cleanup catch all acl entry, counter on port 11
        sai_thrift_set_acl_entry_attribute(
            self.client, port_catch_all_acl_entry,
            action_counter=no_action_counter)
        sai_thrift_remove_acl_counter(self.client, self.port_catch_all_counter)
        sai_thrift_remove_acl_entry(self.client, port_catch_all_acl_entry)

    def runTest(self):
        print(" AclTableAllFieldTest ")
        self.egressV4AclTableTest()
        print(" ")
        self.egressV6AclTableTest()
        print(" ")
        self.egressMirrorAclTableTest()
        print(" ")
        # self.egressQosAclTableTest()  # todo

    def tearDown(self):
        sai_thrift_set_switch_attribute(self.client, egress_acl=0)
        sai_thrift_remove_acl_table_group(self.client, self.acl_group)

        sai_thrift_remove_route_entry(self.client, self.v6_route_entry)
        sai_thrift_remove_next_hop(self.client, self.v6_nhop)
        sai_thrift_remove_neighbor_entry(self.client, self.v6_nbr_entry)
        sai_thrift_remove_route_entry(self.client, self.route_entry)
        sai_thrift_remove_fdb_entry(self.client, self.fdb)
        sai_thrift_remove_next_hop(self.client, self.nhop)
        sai_thrift_remove_neighbor_entry(self.client, self.nbr_entry)
        sai_thrift_remove_route_entry(self.client, self.port_v6_route_entry)
        sai_thrift_remove_next_hop(self.client, self.port_v6_nhop)
        sai_thrift_remove_neighbor_entry(self.client, self.port_v6_nbr_entry)
        sai_thrift_remove_route_entry(self.client, self.port_route_entry)
        sai_thrift_remove_next_hop(self.client, self.port_nhop)
        sai_thrift_remove_neighbor_entry(self.client, self.port_nbr_entry)

        sai_thrift_remove_router_interface(self.client, self.vlan200_rif)
        sai_thrift_remove_vlan_member(self.client, self.vlan_member1)
        sai_thrift_remove_vlan(self.client, self.vlan200)
        super(EgressAclTablesAllFieldTest, self).tearDown()


@group('acl2')
class EgressIpQosAclDscpRewriteTest(SaiHelper):
    """
    Verify DSCP Rewrite on Egress IP QoS ACL
    """

    def setUp(self):
        super(EgressIpQosAclDscpRewriteTest, self).setUp()

        #  configure port0 and port1 for dscp testing
        ip_addr = "172.16.10.1"
        ip_addr_subnet = "172.16.10.0"
        ip_addr_src = "192.168.100.100"
        dmac = "00:11:22:33:44:55"
        mac_src = '00:22:22:22:22:22'
        dst_v6 = '1234:5678:8ab4:5ef0:4422:1133:5500:55aa'
        dst_v6_subnet = '1234:5678:8ab4:5ef0:4422:1133:5500:0000/114'

        self.rif_id1 = self.port10_rif
        self.nhop = sai_thrift_create_next_hop(
            self.client,
            ip=sai_ipaddress(ip_addr),
            router_interface_id=self.rif_id1,
            type=SAI_NEXT_HOP_TYPE_IP)

        self.nbr_entry = sai_thrift_neighbor_entry_t(
            rif_id=self.rif_id1,
            ip_address=sai_ipaddress(ip_addr))
        sai_thrift_create_neighbor_entry(
            self.client,
            self.nbr_entry,
            dst_mac_address=dmac)

        self.route_entry = sai_thrift_route_entry_t(
            vr_id=self.default_vrf,
            destination=sai_ipprefix(ip_addr_subnet))
        sai_thrift_create_route_entry(
            self.client,
            self.route_entry,
            next_hop_id=self.rif_id1)

        #  allocate v6 neighbor, nhop, route
        self.v6_nbr_entry = sai_thrift_neighbor_entry_t(
            rif_id=self.rif_id1,
            ip_address=sai_ipaddress(dst_v6))
        sai_thrift_create_neighbor_entry(
            self.client,
            self.v6_nbr_entry,
            dst_mac_address=dmac)

        self.v6_nhop = sai_thrift_create_next_hop(
            self.client,
            ip=sai_ipaddress(dst_v6),
            router_interface_id=self.rif_id1,
            type=SAI_NEXT_HOP_TYPE_IP)

        self.v6_route_entry = sai_thrift_route_entry_t(
            vr_id=self.default_vrf,
            destination=sai_ipprefix(dst_v6_subnet))
        sai_thrift_create_route_entry(
            self.client,
            self.v6_route_entry,
            next_hop_id=self.v6_nhop)

        print("Configuring DSCP maps")
        #  setup dscp to tc mapping
        #  Port 11 qos map
        ingress_dscp_list = [1, 2]
        ingress_tc_list = [20, 24]
        self.p0_qos_dscp_to_tc_map = create_and_verify_qos_map(
            self.client, SAI_QOS_MAP_TYPE_DSCP_TO_TC, ingress_dscp_list,
            ingress_tc_list)
        #  Verify QosMap value list
        self.assertTrue(self.p0_qos_dscp_to_tc_map != 0,
                        "Failed to create dscp_to_tc map")

        #  setup tc to dscp mapping
        #  Port 10 qos map
        egress_tc_color_list = [
            [20, 0],
            [24, 0],
        ]
        egress_dscp_list = [
            9, 10,
        ]
        self.p1_qos_tc_color_to_dscp_map = create_and_verify_qos_map(
            self.client,
            SAI_QOS_MAP_TYPE_TC_AND_COLOR_TO_DSCP,
            egress_tc_color_list,
            egress_dscp_list)
        self.assertTrue(self.p1_qos_tc_color_to_dscp_map != 0,
                        "Failed to create tc_color_to_dscp map")
        self.assertEqual(self.status(), 0)

        sai_thrift_set_port_attribute(
            self.client,
            self.port11,
            qos_dscp_to_tc_map=self.p0_qos_dscp_to_tc_map)
        sai_thrift_set_port_attribute(
            self.client,
            self.port10,
            qos_tc_and_color_to_dscp_map=self.p1_qos_tc_color_to_dscp_map)

        table_stage_egress = SAI_ACL_STAGE_EGRESS
        table_bind_point_list = [SAI_ACL_BIND_POINT_TYPE_SWITCH]
        action = SAI_PACKET_ACTION_FORWARD

        table_bind_point_type_list = sai_thrift_s32_list_t(
            count=len(table_bind_point_list),
            int32list=table_bind_point_list)

        self.packet_action = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                s32=action))

        self.acl_table = sai_thrift_create_acl_table(
            self.client,
            acl_stage=table_stage_egress,
            acl_bind_point_type_list=table_bind_point_type_list)

    def runTest(self):
        self.v4DscpRewriteQosMapAndAclTest()
        self.v6DscpRewriteQosMapAndAclTest()

    def tearDown(self):
        sai_thrift_set_switch_attribute(self.client, egress_acl=0)
        sai_thrift_remove_next_hop(self.client, self.nhop)
        sai_thrift_remove_next_hop(self.client, self.v6_nhop)
        sai_thrift_remove_neighbor_entry(self.client, self.nbr_entry)
        sai_thrift_remove_neighbor_entry(self.client, self.v6_nbr_entry)
        sai_thrift_remove_route_entry(self.client, self.route_entry)
        sai_thrift_remove_route_entry(self.client, self.v6_route_entry)
        sai_thrift_remove_acl_table(self.client, self.acl_table)
        sai_thrift_set_port_attribute(self.client, self.port11,
                                      qos_dscp_to_tc_map=0)
        sai_thrift_set_port_attribute(self.client, self.port10,
                                      qos_tc_and_color_to_dscp_map=0)
        sai_thrift_remove_qos_map(self.client, self.p0_qos_dscp_to_tc_map)
        sai_thrift_remove_qos_map(
            self.client, self.p1_qos_tc_color_to_dscp_map)
        super(EgressIpQosAclDscpRewriteTest, self).tearDown()

    def v4DscpRewriteQosMapAndAclTest(self):
        print("v4DscpRewriteQosMapAndAclTest()")
        #  Test the case when both ingress QOS map and QOS ACL are enabled
        try:
            ip_dst = "172.16.10.1"
            ip_addr = "172.16.10.1"
            ip_dst_mask = "255.255.255.0"
            mac_src = "00:22:22:22:22:22"
            ip_addr_src = "192.168.100.100"
            dmac = "00:11:22:33:44:55"
            dst_ip_t = sai_thrift_acl_field_data_t(
                data=sai_thrift_acl_field_data_data_t(ip4=ip_dst),
                mask=sai_thrift_acl_field_data_mask_t(ip4=ip_dst_mask))

            #  set dscp to 10
            action_set_dscp = sai_thrift_acl_action_data_t(
                enable=True,
                parameter=sai_thrift_acl_action_parameter_t(u8=10))

            #  set ecn to 3
            action_set_ecn = sai_thrift_acl_action_data_t(
                enable=True,
                parameter=sai_thrift_acl_action_parameter_t(u8=3))

            #  CASE 1: Setting only DSCP:10
            acl_entry_id = sai_thrift_create_acl_entry(
                self.client,
                table_id=self.acl_table,
                field_dst_ip=dst_ip_t,
                action_set_dscp=action_set_dscp,
                action_packet_action=self.packet_action)

            #  ACL counter
            acl_counter_egress = sai_thrift_create_acl_counter(
                self.client, table_id=self.acl_table)
            #  attach ACL counter to ACL entry
            action_counter_egress = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=acl_counter_egress),
                enable=True)
            sai_thrift_set_acl_entry_attribute(
                self.client, acl_entry_id,
                action_counter=action_counter_egress)

            self.pkt = simple_tcp_packet(
                eth_dst=ROUTER_MAC,
                eth_src=mac_src,
                ip_dst=ip_addr,
                ip_src=ip_addr_src,
                ip_id=105,
                ip_tos=1 << 2,
                ip_ttl=64)
            self.exp_pkt = simple_tcp_packet(
                eth_dst=dmac,
                eth_src=ROUTER_MAC,
                ip_dst=ip_addr,
                ip_src=ip_addr_src,
                ip_id=105,
                ip_tos=9 << 2,
                ip_ttl=63)
            self.exp_pkt_acl = simple_tcp_packet(
                eth_dst=dmac,
                eth_src=ROUTER_MAC,
                ip_dst=ip_addr,
                ip_src=ip_addr_src,
                ip_id=105,
                ip_tos=10 << 2,
                ip_ttl=63)

            #  Send packet without ACL Applied
            #  dscp 1 -> ingress qos map -> tc 20 -> dscp 9
            send_packet(self, self.dev_port11, self.pkt)
            verify_packet(self, self.exp_pkt, self.dev_port10)
            print("pass packet w/ mapped dscp value 1 -> 9")

            #  Send packet with ACL Applied
            #  dscp 1 -> ingress qos_map -> tc 20 -> dscp 9
            #  dscp 1 -> tc 24 -> dscp 9 -> QoS ACL -> dscp 10
            #  ACL entry should take precedence over qos-map
            sai_thrift_set_switch_attribute(
                self.client, egress_acl=self.acl_table)
            send_packet(self, self.dev_port11, self.pkt)
            verify_packet(self, self.exp_pkt_acl, self.dev_port10)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter_egress, packets=True)
            self.assertEqual(packets['packets'], 1)
            print("pass packet w/ mapped dscp value 1 -> 10")

            #  CASE 2: Setting both DSCP:10 and ECN:3
            sai_thrift_remove_acl_entry(self.client, acl_entry_id)
            self.exp_pkt_acl = simple_tcp_packet(
                eth_dst=dmac,
                eth_src=ROUTER_MAC,
                ip_dst=ip_addr,
                ip_src=ip_addr_src,
                ip_id=105,
                ip_tos=43,
                ip_ttl=63)

            acl_entry_id = sai_thrift_create_acl_entry(
                self.client,
                table_id=self.acl_table,
                field_dst_ip=dst_ip_t,
                action_set_ecn=action_set_ecn,
                action_set_dscp=action_set_dscp,
                action_packet_action=self.packet_action)
            sai_thrift_set_acl_entry_attribute(
                self.client, acl_entry_id,
                action_counter=action_counter_egress)

            send_packet(self, self.dev_port11, self.pkt)
            verify_packet(self, self.exp_pkt_acl, self.dev_port10)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter_egress, packets=True)
            self.assertEqual(packets['packets'], 1)
            print("pass packet w/ mapped tos value 4 -> 43")

            #  CASE 3: Setting only ECN:3
            sai_thrift_remove_acl_entry(self.client, acl_entry_id)
            self.exp_pkt_acl = simple_tcp_packet(
                eth_dst=dmac,
                eth_src=ROUTER_MAC,
                ip_dst=ip_addr,
                ip_src=ip_addr_src,
                ip_id=105,
                ip_tos=3,
                ip_ttl=63)

            acl_entry_id = sai_thrift_create_acl_entry(
                self.client,
                table_id=self.acl_table,
                field_dst_ip=dst_ip_t,
                action_set_ecn=action_set_ecn,
                action_packet_action=self.packet_action)
            sai_thrift_set_acl_entry_attribute(
                self.client, acl_entry_id,
                action_counter=action_counter_egress)

            send_packet(self, self.dev_port11, self.pkt)
            verify_packet(self, self.exp_pkt_acl, self.dev_port10)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter_egress, packets=True)
            self.assertEqual(packets['packets'], 1)
            print("pass packet w/ mapped tos value 4 -> 3")

            #  CASE 4: Setting both ECN and DSCP to 0
            self.exp_pkt_acl = simple_tcp_packet(
                eth_dst=dmac,
                eth_src=ROUTER_MAC,
                ip_dst=ip_addr,
                ip_src=ip_addr_src,
                ip_id=105,
                ip_tos=0,
                ip_ttl=63)

            #  set dscp to 0
            action_set_dscp = sai_thrift_acl_action_data_t(
                enable=True,
                parameter=sai_thrift_acl_action_parameter_t(u8=0))

            #  set ecn to 0
            action_set_ecn = sai_thrift_acl_action_data_t(
                enable=True,
                parameter=sai_thrift_acl_action_parameter_t(u8=0))

            #  Modify acl_entry with qos action set ecn 0 set dscp 0
            sai_thrift_set_acl_entry_attribute(
                    self.client, acl_entry_id,
                    action_set_ecn=action_set_ecn,
                    action_set_dscp=action_set_dscp)
            sai_thrift_set_acl_entry_attribute(
                self.client, acl_entry_id,
                action_counter=action_counter_egress)

            send_packet(self, self.dev_port11, self.pkt)
            verify_packet(self, self.exp_pkt_acl, self.dev_port10)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter_egress, packets=True)
            self.assertEqual(packets['packets'], 1)
            print("pass packet w/ mapped tos value 4 -> 0")

        finally:
            #  delete v4 acl entry and counters
            action_counter_egress = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=0),
                enable=True)
            sai_thrift_set_acl_entry_attribute(
                self.client, acl_entry_id,
                action_counter=action_counter_egress)
            sai_thrift_set_acl_counter_attribute(
                self.client, acl_counter_egress, packets=None)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter_egress, packets=True)
            self.assertEqual(packets['packets'], 0)
            sai_thrift_remove_acl_counter(self.client, acl_counter_egress)
            sai_thrift_remove_acl_entry(self.client, acl_entry_id)

    def v6DscpRewriteQosMapAndAclTest(self):
        print("v6DscpRewriteQosMapAndAclTest()")
        #  Test the case when both ingress QOS map and QOS ACL are enabled
        try:
            dst_v6 = '1234:5678:8ab4:5ef0:4422:1133:5500:55aa'
            dst_v6_subnet = '1234:5678:8ab4:5ef0:4422:1133:5500:0000/114'
            mac_src = "00:22:22:22:22:22"
            dmac = "00:11:22:33:44:55"

            #  set dscp to 10
            action_set_dscp = sai_thrift_acl_action_data_t(
                enable=True,
                parameter=sai_thrift_acl_action_parameter_t(u8=10))
            #  set ecn to 3
            action_set_ecn = sai_thrift_acl_action_data_t(
                enable=True,
                parameter=sai_thrift_acl_action_parameter_t(u8=3))

            dst_ip_t = sai_thrift_acl_field_data_t(
                data=sai_thrift_acl_field_data_data_t(ip6=dst_v6),
                mask=sai_thrift_acl_field_data_mask_t(ip6=dst_v6_subnet))

            self.v6_pkt = simple_tcpv6_packet(
                eth_dst=ROUTER_MAC,
                eth_src=mac_src,
                ipv6_dst=dst_v6,
                ipv6_src='2000::1',
                ipv6_hlim=64,
                ipv6_tc=1 << 2,
                pktlen=100)
            self.v6_exp_pkt = simple_tcpv6_packet(
                eth_dst=dmac,
                eth_src=ROUTER_MAC,
                ipv6_dst=dst_v6,
                ipv6_src='2000::1',
                ipv6_hlim=63,
                ipv6_tc=9 << 2,
                pktlen=100)
            self.v6_exp_pkt_acl = simple_tcpv6_packet(
                eth_dst=dmac,
                eth_src=ROUTER_MAC,
                ipv6_dst=dst_v6,
                ipv6_src='2000::1',
                ipv6_hlim=63,
                ipv6_tc=10 << 2,
                pktlen=100)

            #  Send packet without ACL Applied
            #  dscp 1 -> ingress qos map -> tc 20 -> dscp 9
            send_packet(self, self.dev_port11, self.v6_pkt)
            verify_packet(self, self.v6_exp_pkt, self.dev_port10)
            print("pass v6 packet w/ mapped dscp value 1 -> 9")

            #  Send packet with ACL Applied
            #  dscp 1 -> ingress qos_map -> tc 20 -> dscp 9
            #  dscp 1 -> tc 24 -> dscp 9 -> QoS ACL -> dscp 10
            #  ACL entry should take precedence over qos-map
            #  CASE 1: Setting only DSCP:10
            v6_acl_entry_id = sai_thrift_create_acl_entry(
                self.client,
                table_id=self.acl_table,
                field_dst_ipv6=dst_ip_t,
                action_set_dscp=action_set_dscp,
                action_packet_action=self.packet_action)
            sai_thrift_set_switch_attribute(
                self.client, egress_acl=self.acl_table)
            #  ACL counter
            acl_counter_egress = sai_thrift_create_acl_counter(
                self.client, table_id=self.acl_table)
            #  attach ACL counter to ACL entry
            action_counter_egress = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=acl_counter_egress),
                enable=True)
            sai_thrift_set_acl_entry_attribute(
                self.client, v6_acl_entry_id,
                action_counter=action_counter_egress)

            send_packet(self, self.dev_port11, self.v6_pkt)
            verify_packet(self, self.v6_exp_pkt_acl, self.dev_port10)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter_egress, packets=True)
            self.assertEqual(packets['packets'], 1)
            print("pass v6 packet w/ mapped dscp value 1 -> 10")

            #  CASE 2: Setting both DSCP:10 and ECN:3
            sai_thrift_remove_acl_entry(self.client, v6_acl_entry_id)
            self.v6_exp_pkt_acl = simple_tcpv6_packet(
                eth_dst=dmac,
                eth_src=ROUTER_MAC,
                ipv6_dst=dst_v6,
                ipv6_src='2000::1',
                ipv6_hlim=63,
                ipv6_tc=43,
                pktlen=100)

            #  create acl_entry with qos action set dscp 10 and set ecn 3
            v6_acl_entry_id = sai_thrift_create_acl_entry(
                self.client,
                table_id=self.acl_table,
                field_dst_ipv6=dst_ip_t,
                action_set_dscp=action_set_dscp,
                action_set_ecn=action_set_ecn,
                action_packet_action=self.packet_action)
            sai_thrift_set_acl_entry_attribute(
                self.client, v6_acl_entry_id,
                action_counter=action_counter_egress)

            send_packet(self, self.dev_port11, self.v6_pkt)
            verify_packet(self, self.v6_exp_pkt_acl, self.dev_port10)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter_egress, packets=True)
            self.assertEqual(packets['packets'], 1)
            print("pass v6 packet w/ mapped tos value 4 -> 43")

            #  CASE 3: Setting only ECN:3
            sai_thrift_remove_acl_entry(self.client, v6_acl_entry_id)
            self.v6_exp_pkt_acl = simple_tcpv6_packet(
                eth_dst=dmac,
                eth_src=ROUTER_MAC,
                ipv6_dst=dst_v6,
                ipv6_src='2000::1',
                ipv6_hlim=63,
                ipv6_tc=3,
                pktlen=100)

            #  create acl_entry with qos action set ecn 3
            v6_acl_entry_id = sai_thrift_create_acl_entry(
                self.client,
                table_id=self.acl_table,
                field_dst_ipv6=dst_ip_t,
                action_set_ecn=action_set_ecn,
                action_packet_action=self.packet_action)
            sai_thrift_set_acl_entry_attribute(
                self.client, v6_acl_entry_id,
                action_counter=action_counter_egress)

            send_packet(self, self.dev_port11, self.v6_pkt)
            verify_packet(self, self.v6_exp_pkt_acl, self.dev_port10)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter_egress, packets=True)
            self.assertEqual(packets['packets'], 1)
            print("pass v6 packet w/ mapped tos value 4 -> 3")

            #  CASE 4: Setting both ECN and DSCP to 0
            self.v6_exp_pkt_acl = simple_tcpv6_packet(
                eth_dst=dmac,
                eth_src=ROUTER_MAC,
                ipv6_dst=dst_v6,
                ipv6_src='2000::1',
                ipv6_hlim=63,
                ipv6_tc=0,
                pktlen=100)

            #  set dscp to 0
            action_set_dscp = sai_thrift_acl_action_data_t(
                enable=True,
                parameter=sai_thrift_acl_action_parameter_t(u8=0))

            #  set ecn to 0
            action_set_ecn = sai_thrift_acl_action_data_t(
                enable=True,
                parameter=sai_thrift_acl_action_parameter_t(u8=0))

            #  Modify acl_entry with qos action set ecn 0 set dscp 0
            sai_thrift_set_acl_entry_attribute(
                    self.client, v6_acl_entry_id,
                    action_set_ecn=action_set_ecn,
                    action_set_dscp=action_set_dscp)

            sai_thrift_set_acl_entry_attribute(
                self.client, v6_acl_entry_id,
                action_counter=action_counter_egress)

            send_packet(self, self.dev_port11, self.v6_pkt)
            verify_packet(self, self.v6_exp_pkt_acl, self.dev_port10)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter_egress, packets=True)
            self.assertEqual(packets['packets'], 1)
            print("pass v6 packet w/ mapped tos value 4 -> 0")

        finally:
            #  delete v6 acl entry and counters
            action_counter_egress = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=0),
                enable=True)
            sai_thrift_set_acl_entry_attribute(
                self.client, v6_acl_entry_id,
                action_counter=action_counter_egress)
            sai_thrift_set_acl_counter_attribute(
                self.client, acl_counter_egress, packets=None)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter_egress, packets=True)
            self.assertEqual(packets['packets'], 0)
            sai_thrift_remove_acl_counter(self.client, acl_counter_egress)
            sai_thrift_remove_acl_entry(self.client, v6_acl_entry_id)


@group('acl2')
class EgressIpQosAclPcpRewriteTest(SaiHelper):
    """
    Verify PCP Rewrite on Egress IP QoS ACL
    """

    def setUp(self):
        super(EgressIpQosAclPcpRewriteTest, self).setUp()

        self.dmac = '00:11:22:33:44:55'
        self.src_mac = '00:22:22:22:22:22'
        self.ip_1 = '10.0.0.1'
        self.ip_2 = '10.10.10.2'

        self.port24_rif = sai_thrift_create_router_interface(
            self.client,
            type=SAI_ROUTER_INTERFACE_TYPE_PORT,
            virtual_router_id=self.default_vrf,
            port_id=self.port24)

        self.port25_rif = sai_thrift_create_router_interface(
            self.client,
            type=SAI_ROUTER_INTERFACE_TYPE_PORT,
            virtual_router_id=self.default_vrf,
            port_id=self.port25)

        self.nhop1 = sai_thrift_create_next_hop(
            self.client,
            ip=sai_ipaddress(self.ip_2),
            router_interface_id=self.port25_rif,
            type=SAI_NEXT_HOP_TYPE_IP)
        self.neighbor_entry1 = sai_thrift_neighbor_entry_t(
            rif_id=self.port25_rif, ip_address=sai_ipaddress(self.ip_2))
        sai_thrift_create_neighbor_entry(
            self.client, self.neighbor_entry1, dst_mac_address=self.dmac)

        self.route_entry0 = sai_thrift_route_entry_t(
            vr_id=self.default_vrf, destination=sai_ipprefix('10.0.0.1/32'))
        sai_thrift_create_route_entry(
            self.client, self.route_entry0, next_hop_id=self.nhop1)

        self.vlan_oid = sai_thrift_create_vlan(self.client, 100)
        mac_action = SAI_PACKET_ACTION_FORWARD

        self.port26_bp = sai_thrift_create_bridge_port(
            self.client,
            bridge_id=self.default_1q_bridge,
            port_id=self.port26,
            type=SAI_BRIDGE_PORT_TYPE_PORT,
            admin_state=True)

        self.vlan_member1 = sai_thrift_create_vlan_member(
            self.client,
            vlan_id=self.vlan_oid,
            bridge_port_id=self.port26_bp,
            vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_TAGGED)

        self.port27_bp = sai_thrift_create_bridge_port(
            self.client,
            bridge_id=self.default_1q_bridge,
            port_id=self.port27,
            type=SAI_BRIDGE_PORT_TYPE_PORT,
            admin_state=True)

        self.vlan_member2 = sai_thrift_create_vlan_member(
            self.client,
            vlan_id=self.vlan_oid,
            bridge_port_id=self.port27_bp,
            vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_TAGGED)

        self.fdb_entry1 = sai_thrift_fdb_entry_t(
            switch_id=self.switch_id,
            mac_address=self.src_mac,
            bv_id=self.vlan_oid)
        sai_thrift_create_fdb_entry(
            self.client,
            self.fdb_entry1,
            type=SAI_FDB_ENTRY_TYPE_STATIC,
            bridge_port_id=self.port26_bp,
            packet_action=mac_action)

        self.fdb_entry2 = sai_thrift_fdb_entry_t(
            switch_id=self.switch_id,
            mac_address=self.dmac,
            bv_id=self.vlan_oid)
        sai_thrift_create_fdb_entry(
            self.client,
            self.fdb_entry2,
            type=SAI_FDB_ENTRY_TYPE_STATIC,
            bridge_port_id=self.port27_bp,
            packet_action=mac_action)

        print("Configuring PCP maps")
        #  setup pcp to tc mapping
        #  Port 26 qos map
        ingress_pcp_list = [1, 2]
        ingress_tc_list = [20, 24]
        self.p0_qos_pcp_to_tc_map = create_and_verify_qos_map(
            self.client, SAI_QOS_MAP_TYPE_DOT1P_TO_TC, ingress_pcp_list,
            ingress_tc_list)
        #  Verify QosMap value list
        self.assertTrue(self.p0_qos_pcp_to_tc_map != 0,
                        "Failed to create pcp_to_tc map")

        #  setup tc to dscp mapping
        #  Port 27 qos map
        egress_tc_color_list = [
            [20, 0],
            [24, 0],
        ]
        egress_pcp_list = [4, 5]
        self.p1_qos_tc_to_pcp_map = create_and_verify_qos_map(
            self.client,
            SAI_QOS_MAP_TYPE_TC_AND_COLOR_TO_DOT1P,
            egress_tc_color_list,
            egress_pcp_list)
        self.assertTrue(self.p1_qos_tc_to_pcp_map != 0,
                        "Failed to create tc_to_pcp map")

        table_stage_egress = SAI_ACL_STAGE_EGRESS
        table_bind_point_list = [SAI_ACL_BIND_POINT_TYPE_SWITCH]
        action = SAI_PACKET_ACTION_FORWARD

        table_bind_point_type_list = sai_thrift_s32_list_t(
            count=len(table_bind_point_list),
            int32list=table_bind_point_list)

        self.packet_action = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                s32=action))

        self.acl_table = sai_thrift_create_acl_table(
            self.client,
            acl_stage=table_stage_egress,
            acl_bind_point_type_list=table_bind_point_type_list)

    def runTest(self):
        self.PcpRewriteQosMapAndAclTest()

    def tearDown(self):
        sai_thrift_set_switch_attribute(self.client, egress_acl=0)
        sai_thrift_remove_fdb_entry(self.client, self.fdb_entry1)
        sai_thrift_remove_fdb_entry(self.client, self.fdb_entry2)
        sai_thrift_remove_vlan_member(self.client, self.vlan_member1)
        sai_thrift_remove_vlan_member(self.client, self.vlan_member2)
        sai_thrift_remove_bridge_port(self.client, self.port26_bp)
        sai_thrift_remove_bridge_port(self.client, self.port27_bp)
        sai_thrift_remove_vlan(self.client, self.vlan_oid)

        sai_thrift_remove_route_entry(self.client, self.route_entry0)
        sai_thrift_remove_next_hop(self.client, self.nhop1)
        sai_thrift_remove_neighbor_entry(self.client, self.neighbor_entry1)
        sai_thrift_remove_router_interface(self.client, self.port25_rif)
        sai_thrift_remove_router_interface(self.client, self.port24_rif)
        sai_thrift_remove_acl_table(self.client, self.acl_table)
        super(EgressIpQosAclPcpRewriteTest, self).tearDown()

    def PcpRewriteQosMapAndAclTest(self):
        print("PcpRewriteQosMapAndAclTest()")
        #  Test the case when both ingress QOS map and QOS ACL are enabled
        try:
            sai_thrift_set_port_attribute(
                self.client,
                self.port26,
                qos_dot1p_to_tc_map=self.p0_qos_pcp_to_tc_map)
            sai_thrift_set_port_attribute(
                self.client,
                self.port27,
                qos_tc_and_color_to_dot1p_map=self.p1_qos_tc_to_pcp_map)

            #  set pcp to 5
            action_set_outer_vlan_pri = sai_thrift_acl_action_data_t(
                enable=True,
                parameter=sai_thrift_acl_action_parameter_t(u8=5))

            acl_entry_id = sai_thrift_create_acl_entry(
                self.client,
                table_id=self.acl_table,
                action_set_outer_vlan_pri=action_set_outer_vlan_pri,
                action_packet_action=self.packet_action)

            #  ACL counter
            acl_counter_egress = sai_thrift_create_acl_counter(
                self.client, table_id=self.acl_table)
            #  attach ACL counter to ACL entry
            action_counter_egress = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=acl_counter_egress),
                enable=True)
            sai_thrift_set_acl_entry_attribute(
                self.client, acl_entry_id,
                action_counter=action_counter_egress)

            pkt = simple_tcp_packet(eth_dst=self.dmac,
                                    eth_src=self.src_mac,
                                    dl_vlan_enable=True,
                                    vlan_vid=100,
                                    vlan_pcp=1,
                                    ip_src=self.ip_2,
                                    ip_dst=self.ip_1,
                                    ip_id=102,
                                    ip_ttl=64)
            e_pkt = simple_tcp_packet(eth_dst=self.dmac,
                                      eth_src=self.src_mac,
                                      ip_dst=self.ip_1,
                                      ip_src=self.ip_2,
                                      ip_id=102,
                                      dl_vlan_enable=True,
                                      vlan_vid=100,
                                      vlan_pcp=4,
                                      ip_ttl=64)

            l2_pkt = simple_tcp_packet(eth_dst=self.dmac,
                                       eth_src=self.src_mac,
                                       dl_vlan_enable=True,
                                       vlan_vid=100,
                                       vlan_pcp=1,
                                       pktlen=104)
            l2_e_pkt = simple_tcp_packet(eth_dst=self.dmac,
                                         eth_src=self.src_mac,
                                         dl_vlan_enable=True,
                                         vlan_vid=100,
                                         vlan_pcp=4,
                                         pktlen=104)

            #  Test traffic without ACL applied
            #  pcp 1 -> ingress qos_map -> tc 20 -> pcp 4
            send_packet(self, self.dev_port26, pkt)
            verify_packet(self, e_pkt, self.dev_port27)
            send_packet(self, self.dev_port26, l2_pkt)
            verify_packet(self, l2_e_pkt, self.dev_port27)
            print("pass packet w/ mapped pcp value 1 -> 4")

            #  Test traffic with QoS ACL applied
            #  pcp 1 -> ingress qos_map -> tc 20 -> pcp 4
            #  pcp 1 -> tc 20 -> pcp 4-> QoS ACL -> pcp 5
            #  ACL entry should take precedence over qos-map
            sai_thrift_set_switch_attribute(
                self.client, egress_acl=self.acl_table)
            e_pkt[Dot1Q].prio = 5
            l2_e_pkt[Dot1Q].prio = 5

            send_packet(self, self.dev_port26, pkt)
            verify_packet(self, e_pkt, self.dev_port27)
            send_packet(self, self.dev_port26, l2_pkt)
            verify_packet(self, l2_e_pkt, self.dev_port27)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter_egress, packets=True)
            self.assertEqual(packets['packets'], 2)
            print("pass packet w/ mapped pcp value 1 -> 5")

            #  set pcp to 0
            action_set_outer_vlan_pri = sai_thrift_acl_action_data_t(
                enable=True,
                parameter=sai_thrift_acl_action_parameter_t(u8=0))

            #  Modify acl_entry with qos action set pcp 0

            sai_thrift_set_acl_entry_attribute(
                self.client, acl_entry_id,
                action_set_outer_vlan_pri=action_set_outer_vlan_pri)
            sai_thrift_set_acl_entry_attribute(
                self.client, acl_entry_id,
                action_counter=action_counter_egress)
            e_pkt[Dot1Q].prio = 0
            l2_e_pkt[Dot1Q].prio = 0

            send_packet(self, self.dev_port26, pkt)
            verify_packet(self, e_pkt, self.dev_port27)
            send_packet(self, self.dev_port26, l2_pkt)
            verify_packet(self, l2_e_pkt, self.dev_port27)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter_egress, packets=True)
            self.assertEqual(packets['packets'], 2)
            print("pass packet w/ mapped pcp value 1 -> 0")
        finally:
            #  delete qos map and acl counter and entry
            action_counter_egress = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=0),
                enable=True)
            sai_thrift_set_acl_entry_attribute(
                self.client, acl_entry_id,
                action_counter=action_counter_egress)
            sai_thrift_set_acl_counter_attribute(
                self.client, acl_counter_egress, packets=None)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter_egress, packets=True)
            self.assertEqual(packets['packets'], 0)
            sai_thrift_remove_acl_counter(self.client, acl_counter_egress)
            sai_thrift_set_port_attribute(self.client, self.port26,
                                          qos_dot1p_to_tc_map=0)
            sai_thrift_set_port_attribute(self.client, self.port27,
                                          qos_tc_and_color_to_dot1p_map=0)
            sai_thrift_remove_qos_map(self.client, self.p0_qos_pcp_to_tc_map)
            sai_thrift_remove_qos_map(self.client, self.p1_qos_tc_to_pcp_map)
            sai_thrift_remove_acl_entry(self.client, acl_entry_id)


@group('acl2')
class EgressIpQosAclDscpPcpRewriteTest(SaiHelper):
    """
        Verify PCP Rewrite on Egress IP QoS ACL
    """

    def setUp(self):
        super(EgressIpQosAclDscpPcpRewriteTest, self).setUp()

        self.dmac = '00:11:22:33:44:55'
        self.src_mac = '00:22:22:22:22:22'
        self.ip_1 = '10.0.0.1'
        self.ip_2 = '10.10.10.2'
        dst_v6 = '1234:5678:8ab4:5ef0:4422:1133:5500:55aa'
        dst_v6_subnet = '1234:5678:8ab4:5ef0:4422:1133:5500:0000/114'

        self.port24_rif = sai_thrift_create_router_interface(
            self.client,
            type=SAI_ROUTER_INTERFACE_TYPE_PORT,
            virtual_router_id=self.default_vrf,
            port_id=self.port24)

        self.port25_rif = sai_thrift_create_router_interface(
            self.client,
            type=SAI_ROUTER_INTERFACE_TYPE_PORT,
            virtual_router_id=self.default_vrf,
            port_id=self.port25)

        self.nhop1 = sai_thrift_create_next_hop(
            self.client,
            ip=sai_ipaddress(self.ip_2),
            router_interface_id=self.port25_rif,
            type=SAI_NEXT_HOP_TYPE_IP)
        self.neighbor_entry1 = sai_thrift_neighbor_entry_t(
            rif_id=self.port25_rif, ip_address=sai_ipaddress(self.ip_2))
        sai_thrift_create_neighbor_entry(
            self.client, self.neighbor_entry1, dst_mac_address=self.dmac)

        self.route_entry0 = sai_thrift_route_entry_t(
            vr_id=self.default_vrf, destination=sai_ipprefix('10.0.0.1/32'))
        sai_thrift_create_route_entry(
            self.client, self.route_entry0, next_hop_id=self.nhop1)

        #  allocate v6 neighbor, nhop, route
        self.v6_nbr_entry = sai_thrift_neighbor_entry_t(
                    rif_id=self.port25_rif,
                    ip_address=sai_ipaddress(dst_v6))
        sai_thrift_create_neighbor_entry(
                    self.client,
                    self.v6_nbr_entry,
                    dst_mac_address=self.dmac)

        self.v6_nhop = sai_thrift_create_next_hop(
                    self.client,
                    ip=sai_ipaddress(dst_v6),
                    router_interface_id=self.port25_rif,
                    type=SAI_NEXT_HOP_TYPE_IP)

        self.v6_route_entry = sai_thrift_route_entry_t(
                    vr_id=self.default_vrf,
                    destination=sai_ipprefix(dst_v6_subnet))
        sai_thrift_create_route_entry(
                    self.client,
                    self.v6_route_entry,
                    next_hop_id=self.v6_nhop)

        self.vlan_oid = sai_thrift_create_vlan(self.client, 100)
        mac_action = SAI_PACKET_ACTION_FORWARD

        self.port26_bp = sai_thrift_create_bridge_port(
            self.client,
            bridge_id=self.default_1q_bridge,
            port_id=self.port26,
            type=SAI_BRIDGE_PORT_TYPE_PORT,
            admin_state=True)

        self.vlan_member1 = sai_thrift_create_vlan_member(
            self.client,
            vlan_id=self.vlan_oid,
            bridge_port_id=self.port26_bp,
            vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_TAGGED)

        self.port27_bp = sai_thrift_create_bridge_port(
            self.client,
            bridge_id=self.default_1q_bridge,
            port_id=self.port27,
            type=SAI_BRIDGE_PORT_TYPE_PORT,
            admin_state=True)

        self.vlan_member2 = sai_thrift_create_vlan_member(
            self.client,
            vlan_id=self.vlan_oid,
            bridge_port_id=self.port27_bp,
            vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_TAGGED)

        self.fdb_entry1 = sai_thrift_fdb_entry_t(
            switch_id=self.switch_id,
            mac_address=self.src_mac,
            bv_id=self.vlan_oid)
        sai_thrift_create_fdb_entry(
            self.client,
            self.fdb_entry1,
            type=SAI_FDB_ENTRY_TYPE_STATIC,
            bridge_port_id=self.port26_bp,
            packet_action=mac_action)

        self.fdb_entry2 = sai_thrift_fdb_entry_t(
            switch_id=self.switch_id,
            mac_address=self.dmac,
            bv_id=self.vlan_oid)
        sai_thrift_create_fdb_entry(
            self.client,
            self.fdb_entry2,
            type=SAI_FDB_ENTRY_TYPE_STATIC,
            bridge_port_id=self.port27_bp,
            packet_action=mac_action)

        print("Configuring DSCP maps")
        #  setup dscp to tc mapping
        #  Port 26 qos map
        ingress_dscp_list = [1, 2]
        ingress_tc_list = [20, 24]
        self.p0_qos_dscp_to_tc_map = create_and_verify_qos_map(
            self.client, SAI_QOS_MAP_TYPE_DSCP_TO_TC, ingress_dscp_list,
            ingress_tc_list)
        #  Verify QosMap value list
        self.assertTrue(self.p0_qos_dscp_to_tc_map != 0,
                        "Failed to create dscp_to_tc map")

        #  setup tc to dscp mapping
        #  Port 27 qos map
        egress_tc_color_list = [
            [20, 0],
            [24, 0],
        ]
        egress_dscp_list = [
            9, 10,
        ]
        self.p1_qos_tc_color_to_dscp_map = create_and_verify_qos_map(
            self.client,
            SAI_QOS_MAP_TYPE_TC_AND_COLOR_TO_DSCP,
            egress_tc_color_list,
            egress_dscp_list)
        self.assertTrue(self.p1_qos_tc_color_to_dscp_map != 0,
                        "Failed to create tc_color_to_dscp map")
        self.assertEqual(self.status(), 0)

        print("Configuring DSCP maps")
        #  setup pcp to tc mapping
        #  Port 26 qos map
        ingress_pcp_list = [1, 2]
        ingress_tc_list = [20, 24]
        self.p0_qos_pcp_to_tc_map = create_and_verify_qos_map(
            self.client, SAI_QOS_MAP_TYPE_DOT1P_TO_TC, ingress_pcp_list,
            ingress_tc_list)
        #  Verify QosMap value list
        self.assertTrue(self.p0_qos_pcp_to_tc_map != 0,
                        "Failed to create pcp_to_tc map")

        #  setup tc to dscp mapping
        #  Port 27 qos map
        egress_tc_color_list = [
            [20, 0],
            [24, 0],
        ]
        egress_pcp_list = [4, 5]
        self.p1_qos_tc_to_pcp_map = create_and_verify_qos_map(
            self.client,
            SAI_QOS_MAP_TYPE_TC_AND_COLOR_TO_DOT1P,
            egress_tc_color_list,
            egress_pcp_list)
        self.assertTrue(self.p1_qos_tc_to_pcp_map != 0,
                        "Failed to create tc_to_pcp map")

        sai_thrift_set_port_attribute(
            self.client,
            self.port26,
            qos_dscp_to_tc_map=self.p0_qos_dscp_to_tc_map)
        sai_thrift_set_port_attribute(
            self.client,
            self.port27,
            qos_tc_and_color_to_dscp_map=self.p1_qos_tc_color_to_dscp_map)
        sai_thrift_set_port_attribute(
            self.client,
            self.port26,
            qos_dot1p_to_tc_map=self.p0_qos_pcp_to_tc_map)
        sai_thrift_set_port_attribute(
            self.client,
            self.port27,
            qos_tc_and_color_to_dot1p_map=self.p1_qos_tc_to_pcp_map)

        table_stage_egress = SAI_ACL_STAGE_EGRESS
        table_bind_point_list = [SAI_ACL_BIND_POINT_TYPE_SWITCH]
        action = SAI_PACKET_ACTION_FORWARD

        table_bind_point_type_list = sai_thrift_s32_list_t(
            count=len(table_bind_point_list),
            int32list=table_bind_point_list)

        self.packet_action = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                s32=action))

        self.acl_table = sai_thrift_create_acl_table(
            self.client,
            acl_stage=table_stage_egress,
            acl_bind_point_type_list=table_bind_point_type_list)
        sai_thrift_set_switch_attribute(
            self.client, egress_acl=self.acl_table)

    def runTest(self):
        self.v4DscpPcpRewriteQosMapAndAclTest()
        self.v6DscpPcpRewriteQosMapAndAclTest()

    def tearDown(self):
        sai_thrift_set_switch_attribute(self.client, egress_acl=0)
        sai_thrift_set_port_attribute(self.client, self.port26,
                                      qos_dot1p_to_tc_map=0)
        sai_thrift_set_port_attribute(self.client, self.port26,
                                      qos_dscp_to_tc_map=0)
        sai_thrift_set_port_attribute(self.client, self.port27,
                                      qos_tc_and_color_to_dscp_map=0)
        sai_thrift_set_port_attribute(self.client, self.port27,
                                      qos_tc_and_color_to_dot1p_map=0)
        sai_thrift_remove_qos_map(self.client, self.p0_qos_pcp_to_tc_map)
        sai_thrift_remove_qos_map(self.client, self.p0_qos_dscp_to_tc_map)
        sai_thrift_remove_qos_map(self.client, self.p1_qos_tc_to_pcp_map)
        sai_thrift_remove_qos_map(
            self.client, self.p1_qos_tc_color_to_dscp_map)
        sai_thrift_remove_fdb_entry(self.client, self.fdb_entry1)
        sai_thrift_remove_fdb_entry(self.client, self.fdb_entry2)
        sai_thrift_remove_vlan_member(self.client, self.vlan_member1)
        sai_thrift_remove_vlan_member(self.client, self.vlan_member2)
        sai_thrift_remove_bridge_port(self.client, self.port26_bp)
        sai_thrift_remove_bridge_port(self.client, self.port27_bp)
        sai_thrift_remove_vlan(self.client, self.vlan_oid)

        sai_thrift_remove_route_entry(self.client, self.route_entry0)
        sai_thrift_remove_route_entry(self.client, self.v6_route_entry)
        sai_thrift_remove_next_hop(self.client, self.nhop1)
        sai_thrift_remove_next_hop(self.client, self.v6_nhop)
        sai_thrift_remove_neighbor_entry(self.client, self.neighbor_entry1)
        sai_thrift_remove_neighbor_entry(self.client, self.v6_nbr_entry)
        sai_thrift_remove_router_interface(self.client, self.port25_rif)
        sai_thrift_remove_router_interface(self.client, self.port24_rif)
        sai_thrift_remove_acl_table(self.client, self.acl_table)
        super(EgressIpQosAclDscpPcpRewriteTest, self).tearDown()

    def v4DscpPcpRewriteQosMapAndAclTest(self):
        print("v4DscpPcpRewriteQosMapAndAclTest()")
        #  Test the case when both ingress QOS map and QOS ACL are enabled
        try:
            #  set dscp to 10
            action_set_dscp = sai_thrift_acl_action_data_t(
                enable=True,
                parameter=sai_thrift_acl_action_parameter_t(u8=10))
            #  set pcp to 5
            action_set_outer_vlan_pri = sai_thrift_acl_action_data_t(
                enable=True,
                parameter=sai_thrift_acl_action_parameter_t(u8=5))

            acl_entry_id = sai_thrift_create_acl_entry(
                self.client,
                table_id=self.acl_table,
                action_set_dscp=action_set_dscp,
                action_set_outer_vlan_pri=action_set_outer_vlan_pri,
                action_packet_action=self.packet_action)

            #  ACL counter
            acl_counter_egress = sai_thrift_create_acl_counter(
                self.client, table_id=self.acl_table)
            #  attach ACL counter to ACL entry
            action_counter_egress = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=acl_counter_egress),
                enable=True)
            sai_thrift_set_acl_entry_attribute(
                self.client, acl_entry_id,
                action_counter=action_counter_egress)

            pkt = simple_tcp_packet(eth_dst=self.dmac,
                                    eth_src=self.src_mac,
                                    dl_vlan_enable=True,
                                    vlan_vid=100,
                                    vlan_pcp=1,
                                    ip_src=self.ip_2,
                                    ip_dst=self.ip_1,
                                    ip_id=102,
                                    ip_tos=1 << 2,
                                    ip_ttl=64)
            e_pkt = simple_tcp_packet(eth_dst=self.dmac,
                                      eth_src=self.src_mac,
                                      ip_dst=self.ip_1,
                                      ip_src=self.ip_2,
                                      ip_id=102,
                                      dl_vlan_enable=True,
                                      vlan_vid=100,
                                      vlan_pcp=5,
                                      ip_tos=10 << 2,
                                      ip_ttl=64)

            #  Test traffic with QoS ACL applied
            #  pcp 1 -> ingress qos_map -> tc 20 -> pcp 4
            #  pcp 1 -> tc 20 -> pcp 4-> QoS ACL -> pcp 5
            #  dscp 1 -> ingress qos map -> tc 20 -> dscp 9
            #  dscp 1 -> tc 20 -> dscp 9 -> QoS ACL -> dscp 10
            #  ACL entry should take precedence over qos-map
            send_packet(self, self.dev_port26, pkt)
            verify_packet(self, e_pkt, self.dev_port27)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter_egress, packets=True)
            self.assertEqual(packets['packets'], 1)
            print("pass packet w/ mapped pcp 1 -> 5 and dscp 1 -> 10")

        finally:
            #  delete qos map and acl counter and entry
            action_counter_egress = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=0),
                enable=True)
            sai_thrift_set_acl_entry_attribute(
                self.client, acl_entry_id,
                action_counter=action_counter_egress)
            sai_thrift_set_acl_counter_attribute(
                self.client, acl_counter_egress, packets=None)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter_egress, packets=True)
            self.assertEqual(packets['packets'], 0)
            sai_thrift_remove_acl_counter(self.client, acl_counter_egress)
            sai_thrift_remove_acl_entry(self.client, acl_entry_id)

    def v6DscpPcpRewriteQosMapAndAclTest(self):
        print("v6DscpPcpRewriteQosMapAndAclTest()")
        #  Test the case when both ingress QOS map and QOS ACL are enabled
        try:
            dst_v6 = '1234:5678:8ab4:5ef0:4422:1133:5500:55aa'
            dst_v6_subnet = '1234:5678:8ab4:5ef0:4422:1133:5500:0000/114'
            #  set dscp to 10
            action_set_dscp = sai_thrift_acl_action_data_t(
                enable=True,
                parameter=sai_thrift_acl_action_parameter_t(u8=10))
            #  set pcp to 5
            action_set_outer_vlan_pri = sai_thrift_acl_action_data_t(
                enable=True,
                parameter=sai_thrift_acl_action_parameter_t(u8=5))

            dst_ip_t = sai_thrift_acl_field_data_t(
                data=sai_thrift_acl_field_data_data_t(ip6=dst_v6),
                mask=sai_thrift_acl_field_data_mask_t(ip6=dst_v6_subnet))

            v6_acl_entry_id = sai_thrift_create_acl_entry(
                self.client,
                table_id=self.acl_table,
                field_dst_ipv6=dst_ip_t,
                action_set_dscp=action_set_dscp,
                action_set_outer_vlan_pri=action_set_outer_vlan_pri,
                action_packet_action=self.packet_action)

            #  ACL counter
            acl_counter_egress = sai_thrift_create_acl_counter(
                self.client, table_id=self.acl_table)
            #  attach ACL counter to ACL entry
            action_counter_egress = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=acl_counter_egress),
                enable=True)
            sai_thrift_set_acl_entry_attribute(
                self.client, v6_acl_entry_id,
                action_counter=action_counter_egress)

            v6_pkt = simple_tcpv6_packet(eth_dst=self.dmac,
                                         eth_src=self.src_mac,
                                         dl_vlan_enable=True,
                                         vlan_vid=100,
                                         vlan_pcp=1,
                                         ipv6_src='2000::1',
                                         ipv6_dst=dst_v6,
                                         ipv6_hlim=64,
                                         ipv6_tc=1 << 2,
                                         pktlen=100)
            v6_e_pkt = simple_tcpv6_packet(eth_dst=self.dmac,
                                           eth_src=self.src_mac,
                                           dl_vlan_enable=True,
                                           vlan_vid=100,
                                           vlan_pcp=5,
                                           ipv6_src='2000::1',
                                           ipv6_dst=dst_v6,
                                           ipv6_hlim=64,
                                           ipv6_tc=10 << 2,
                                           pktlen=100)

            #  Test traffic with QoS ACL applied
            #  pcp 1 -> ingress qos_map -> tc 20 -> pcp 4
            #  pcp 1 -> tc 20 -> pcp 4-> QoS ACL -> pcp 5
            #  dscp 1 -> ingress qos map -> tc 20 -> dscp 9
            #  dscp 1 -> tc 20 -> dscp 9 -> QoS ACL -> dscp 10
            #  ACL entry should take precedence over qos-map
            send_packet(self, self.dev_port26, v6_pkt)
            verify_packet(self, v6_e_pkt, self.dev_port27)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter_egress, packets=True)
            self.assertEqual(packets['packets'], 1)
            print("pass v6 packet w/ mapped pcp 1 -> 5 and dscp 1 -> 10")

        finally:
            #  delete qos map and acl counter and entry
            action_counter_egress = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=0),
                enable=True)
            sai_thrift_set_acl_entry_attribute(
                self.client, v6_acl_entry_id,
                action_counter=action_counter_egress)
            sai_thrift_set_acl_counter_attribute(
                self.client, acl_counter_egress, packets=None)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter_egress, packets=True)
            self.assertEqual(packets['packets'], 0)
            sai_thrift_remove_acl_counter(self.client, acl_counter_egress)
            sai_thrift_remove_acl_entry(self.client, v6_acl_entry_id)


@group('acl2')
class EgressIpQosAclPcpRewriteSVITest(SaiHelper):
    """
    Verify PCP rewrite for egress ip qos ACL on SVI
    """

    def setUp(self):
        super(EgressIpQosAclPcpRewriteSVITest, self).setUp()

        self.dmac1 = "00:22:22:33:44:55"
        self.dmac2 = "00:22:33:33:44:55"

        self.port26_bp = sai_thrift_create_bridge_port(
            self.client,
            bridge_id=self.default_1q_bridge,
            port_id=self.port26,
            type=SAI_BRIDGE_PORT_TYPE_PORT,
            admin_state=True)

        self.port27_bp = sai_thrift_create_bridge_port(
            self.client,
            bridge_id=self.default_1q_bridge,
            port_id=self.port27,
            type=SAI_BRIDGE_PORT_TYPE_PORT,
            admin_state=True)

        #  create vlan 111 with member port 26, tagged
        self.vlan111 = sai_thrift_create_vlan(self.client, vlan_id=111)
        self.vlan111_member1 = sai_thrift_create_vlan_member(
            self.client,
            vlan_id=self.vlan111,
            bridge_port_id=self.port26_bp,
            vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_TAGGED)

        #  vlan 111 router interface
        self.vlan111_rif = sai_thrift_create_router_interface(
            self.client,
            type=SAI_ROUTER_INTERFACE_TYPE_VLAN,
            virtual_router_id=self.default_vrf,
            vlan_id=self.vlan111)

        #  create nexthop, neighbor and route for SVI
        self.nexthop1 = sai_thrift_create_next_hop(
            self.client,
            ip=sai_ipaddress('10.10.0.2'),
            router_interface_id=self.vlan111_rif,
            type=SAI_NEXT_HOP_TYPE_IP)
        self.neighbor_entry1 = sai_thrift_neighbor_entry_t(
            rif_id=self.vlan111_rif, ip_address=sai_ipaddress('10.10.0.2'))
        sai_thrift_create_neighbor_entry(
            self.client, self.neighbor_entry1, dst_mac_address=self.dmac1)
        self.route_entry1 = sai_thrift_route_entry_t(
            vr_id=self.default_vrf, destination=sai_ipprefix('10.10.10.2/32'))
        sai_thrift_create_route_entry(
            self.client, self.route_entry1, next_hop_id=self.nexthop1)

        #  create vlan 222 with member port 27, tagged
        self.vlan222 = sai_thrift_create_vlan(self.client, vlan_id=222)
        self.vlan222_member1 = sai_thrift_create_vlan_member(
            self.client,
            vlan_id=self.vlan222,
            bridge_port_id=self.port27_bp,
            vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_TAGGED)

        #  vlan 222 router interface
        self.vlan222_rif = sai_thrift_create_router_interface(
            self.client,
            type=SAI_ROUTER_INTERFACE_TYPE_VLAN,
            virtual_router_id=self.default_vrf,
            vlan_id=self.vlan222)

        #  create nexthop, neighbor and route for SVI
        self.nexthop2 = sai_thrift_create_next_hop(
            self.client,
            ip=sai_ipaddress('20.10.0.2'),
            router_interface_id=self.vlan222_rif,
            type=SAI_NEXT_HOP_TYPE_IP)
        self.neighbor_entry2 = sai_thrift_neighbor_entry_t(
            rif_id=self.vlan222_rif, ip_address=sai_ipaddress('20.10.0.2'))
        sai_thrift_create_neighbor_entry(
            self.client, self.neighbor_entry2, dst_mac_address=self.dmac2)
        self.route_entry2 = sai_thrift_route_entry_t(
            vr_id=self.default_vrf, destination=sai_ipprefix('20.10.10.2/32'))
        sai_thrift_create_route_entry(
            self.client, self.route_entry2, next_hop_id=self.nexthop2)

        mac_action = SAI_PACKET_ACTION_FORWARD

        #  FDB entries
        self.fdb_entry26 = sai_thrift_fdb_entry_t(switch_id=self.switch_id,
                                                  mac_address=self.dmac1,
                                                  bv_id=self.vlan111)
        sai_thrift_create_fdb_entry(self.client,
                                    self.fdb_entry26,
                                    type=SAI_FDB_ENTRY_TYPE_STATIC,
                                    bridge_port_id=self.port26_bp,
                                    packet_action=mac_action)

        self.fdb_entry27 = sai_thrift_fdb_entry_t(switch_id=self.switch_id,
                                                  mac_address=self.dmac2,
                                                  bv_id=self.vlan222)
        sai_thrift_create_fdb_entry(self.client,
                                    self.fdb_entry27,
                                    type=SAI_FDB_ENTRY_TYPE_STATIC,
                                    bridge_port_id=self.port27_bp,
                                    packet_action=mac_action)

        print("Configuring PCP maps")
        #  setup pcp to tc mapping
        #  Port 26 qos map
        ingress_pcp_list = [1, 2]
        ingress_tc_list = [20, 24]
        self.p0_qos_pcp_to_tc_map = create_and_verify_qos_map(
            self.client, SAI_QOS_MAP_TYPE_DOT1P_TO_TC, ingress_pcp_list,
            ingress_tc_list)
        #  Verify QosMap value list
        self.assertTrue(self.p0_qos_pcp_to_tc_map != 0,
                        "Failed to create pcp_to_tc map")

        #  setup tc to dscp mapping
        #  Port 27 qos map
        egress_tc_color_list = [
            [20, 0],
            [24, 0],
        ]
        egress_pcp_list = [4, 5]
        self.p1_qos_tc_to_pcp_map = create_and_verify_qos_map(
            self.client,
            SAI_QOS_MAP_TYPE_TC_AND_COLOR_TO_DOT1P,
            egress_tc_color_list,
            egress_pcp_list)
        self.assertTrue(self.p1_qos_tc_to_pcp_map != 0,
                        "Failed to create tc_to_pcp map")

        table_stage_egress = SAI_ACL_STAGE_EGRESS
        table_bind_point_list = [SAI_ACL_BIND_POINT_TYPE_SWITCH]
        action = SAI_PACKET_ACTION_FORWARD

        table_bind_point_type_list = sai_thrift_s32_list_t(
            count=len(table_bind_point_list),
            int32list=table_bind_point_list)

        self.packet_action = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                s32=action))

        self.acl_table = sai_thrift_create_acl_table(
            self.client,
            acl_stage=table_stage_egress,
            acl_bind_point_type_list=table_bind_point_type_list)

    def runTest(self):
        try:
            sai_thrift_set_port_attribute(
                self.client,
                self.port26,
                qos_dot1p_to_tc_map=self.p0_qos_pcp_to_tc_map)
            sai_thrift_set_port_attribute(
                self.client,
                self.port27,
                qos_tc_and_color_to_dot1p_map=self.p1_qos_tc_to_pcp_map)

            #  set pcp to 5
            action_set_outer_vlan_pri = sai_thrift_acl_action_data_t(
                enable=True,
                parameter=sai_thrift_acl_action_parameter_t(u8=5))

            acl_entry_id = sai_thrift_create_acl_entry(
                self.client,
                table_id=self.acl_table,
                action_set_outer_vlan_pri=action_set_outer_vlan_pri,
                action_packet_action=self.packet_action)

            #  ACL counter
            acl_counter_egress = sai_thrift_create_acl_counter(
                self.client, table_id=self.acl_table)
            #  attach ACL counter to ACL entry
            action_counter_egress = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=acl_counter_egress),
                enable=True)
            sai_thrift_set_acl_entry_attribute(
                self.client, acl_entry_id,
                action_counter=action_counter_egress)

            tagged_pkt = simple_tcp_packet(eth_dst=ROUTER_MAC,
                                           eth_src=self.dmac1,
                                           ip_dst='20.10.10.2',
                                           ip_src='192.168.0.1',
                                           dl_vlan_enable=True,
                                           vlan_vid=111,
                                           vlan_pcp=1,
                                           ip_ttl=64,
                                           pktlen=104)

            tagged_exp_pkt = simple_tcp_packet(eth_dst=self.dmac2,
                                               eth_src=ROUTER_MAC,
                                               ip_dst='20.10.10.2',
                                               ip_src='192.168.0.1',
                                               dl_vlan_enable=True,
                                               vlan_vid=222,
                                               vlan_pcp=4,
                                               ip_ttl=63,
                                               pktlen=104)

            #  Test traffic without QoS ACL applied
            #  pcp 1 -> ingress qos_map -> tc 20 -> pcp 4
            send_packet(self, self.dev_port26, tagged_pkt)
            verify_packet(self, tagged_exp_pkt, self.dev_port27)

            #  Test traffic with QoS ACL applied
            #  pcp 1 -> ingress qos_map -> tc 20 -> pcp 4
            #  pcp 1 -> tc 20 -> pcp 4-> QoS ACL -> pcp 5
            #  ACL entry should take precedence over qos-map
            sai_thrift_set_switch_attribute(
                self.client, egress_acl=self.acl_table)
            tagged_exp_pkt[Dot1Q].prio = 5
            send_packet(self, self.dev_port26, tagged_pkt)
            verify_packet(self, tagged_exp_pkt, self.dev_port27)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter_egress, packets=True)
            self.assertEqual(packets['packets'], 1)
            print("pass packet w/ mapped pcp 1 -> 5")

        finally:
            #  delete qos map and acl counter and entry
            action_counter_egress = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=0),
                enable=True)
            sai_thrift_set_acl_entry_attribute(
                self.client, acl_entry_id,
                action_counter=action_counter_egress)
            sai_thrift_set_acl_counter_attribute(
                self.client, acl_counter_egress, packets=None)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter_egress, packets=True)
            self.assertEqual(packets['packets'], 0)
            sai_thrift_remove_acl_counter(self.client, acl_counter_egress)
            sai_thrift_set_port_attribute(self.client, self.port26,
                                          qos_dot1p_to_tc_map=0)
            sai_thrift_set_port_attribute(self.client, self.port27,
                                          qos_tc_and_color_to_dot1p_map=0)
            sai_thrift_remove_qos_map(self.client, self.p0_qos_pcp_to_tc_map)
            sai_thrift_remove_qos_map(self.client, self.p1_qos_tc_to_pcp_map)
            sai_thrift_remove_acl_entry(self.client, acl_entry_id)

    def tearDown(self):
        sai_thrift_set_switch_attribute(self.client, egress_acl=0)
        sai_thrift_remove_fdb_entry(self.client, self.fdb_entry26)
        sai_thrift_remove_fdb_entry(self.client, self.fdb_entry27)
        sai_thrift_remove_vlan_member(self.client, self.vlan111_member1)
        sai_thrift_remove_vlan_member(self.client, self.vlan222_member1)
        sai_thrift_remove_bridge_port(self.client, self.port26_bp)
        sai_thrift_remove_bridge_port(self.client, self.port27_bp)

        sai_thrift_remove_route_entry(self.client, self.route_entry1)
        sai_thrift_remove_route_entry(self.client, self.route_entry2)
        sai_thrift_remove_next_hop(self.client, self.nexthop1)
        sai_thrift_remove_next_hop(self.client, self.nexthop2)
        sai_thrift_remove_neighbor_entry(self.client, self.neighbor_entry1)
        sai_thrift_remove_neighbor_entry(self.client, self.neighbor_entry2)
        sai_thrift_remove_router_interface(self.client, self.vlan111_rif)
        sai_thrift_remove_router_interface(self.client, self.vlan222_rif)
        sai_thrift_remove_vlan(self.client, self.vlan111)
        sai_thrift_remove_vlan(self.client, self.vlan222)
        sai_thrift_remove_acl_table(self.client, self.acl_table)
        super(EgressIpQosAclPcpRewriteSVITest, self).tearDown()


@group('acl2')
class EgressOutPortV4AclTest(SaiHelper):
    """
    Verify matching on Out Port for ipv4
    """

    def setUp(self):
        super(EgressOutPortV4AclTest, self).setUp()

        l4_src_port = 1000

        rif_id1 = self.port10_rif
        self.rif_id2 = self.port11_rif
        self.rif_id3 = self.port12_rif

        ip_addr_subnet = '172.16.10.0'
        ip_addr = '172.16.10.1'
        dmac = '00:11:22:33:44:55'
        mac_src = '00:22:22:22:22:22'
        ip_addr_src = '192.168.100.100'

        print("Alloc neighbor with %s ip address, %d router interface"
              " id and %s destination mac" % (
                  ip_addr, rif_id1, dmac))
        self.nbr_entry = sai_thrift_neighbor_entry_t(
            rif_id=rif_id1,
            ip_address=sai_ipaddress(ip_addr))
        sai_thrift_create_neighbor_entry(
            self.client, self.nbr_entry, dst_mac_address=dmac)

        print("Alloc nhop with %s ip address and %d router"
              " interface id" % (ip_addr, rif_id1))
        self.nhop = sai_thrift_create_next_hop(
            self.client,
            ip=sai_ipaddress(ip_addr),
            router_interface_id=rif_id1,
            type=SAI_NEXT_HOP_TYPE_IP)

        self.pkt = simple_tcp_packet(eth_dst=ROUTER_MAC,
                                     eth_src=mac_src,
                                     ip_dst=ip_addr,
                                     ip_src=ip_addr_src,
                                     tcp_sport=l4_src_port,
                                     ip_id=105,
                                     ip_ttl=64)
        self.exp_pkt = simple_tcp_packet(eth_dst=dmac,
                                         eth_src=ROUTER_MAC,
                                         ip_dst=ip_addr,
                                         ip_src=ip_addr_src,
                                         tcp_sport=l4_src_port,
                                         ip_id=105,
                                         ip_ttl=63)

    def basicV4TrafficTest(self):
        '''
        Verify v4 traffic test before
        applying egress ipv4 ACl table entry.
        '''
        print("basicV4TrafficTest")

        print('--------------------------------------------------------------')
        print("Sending packet port 11 -> port 10 (192.168.100.100 "
              "--->172.16.10.1 [id = 105])")

        try:
            print('#### NO ACL Applied ####')
            print('#### Sending  ', ROUTER_MAC, '| 00:22:22:22:22:22 | '
                  '172.16.10.1 | 192.168.100.100 | @ port 11')
            send_packet(self, self.dev_port11, self.pkt)
            print('#### Expecting 00:11:22:33:44:55 |', ROUTER_MAC, '| '
                  '172.16.10.1 | 192.168.100.100 | @ port 10')
            verify_packets(self, self.exp_pkt, [self.dev_port10])
        finally:
            print('----------------------------------------------------------'
                  '------------------------------------')

    def egressAclSrcIpOutPortTest(self):
        '''
        Verify out-port field with switch b-point to
        egress ipv4 ACL table entry with src-ip match
        '''
        print("egressAclSrcIpOutPortTest")

        table_stage_egress = SAI_ACL_STAGE_EGRESS
        entry_priority = 1
        ip_src = "192.168.100.1"
        ip_src_mask = "255.255.255.0"
        out_port_id = self.port10

        table_bind_points = [SAI_ACL_BIND_POINT_TYPE_SWITCH]
        table_bind_point_type_list = sai_thrift_s32_list_t(
            count=len(table_bind_points), int32list=table_bind_points)

        print("Alloc ACL Table")
        acl_egress_table_id = sai_thrift_create_acl_table(
            self.client,
            acl_stage=table_stage_egress,
            acl_bind_point_type_list=table_bind_point_type_list,
            field_src_ip=True,
            field_out_port=True)
        self.assertNotEqual(acl_egress_table_id, 0)

        print("Alloc ACL Field Data")
        src_ip_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(ip4=ip_src),
            mask=sai_thrift_acl_field_data_mask_t(ip4=ip_src_mask))
        out_port_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(oid=out_port_id))

        print("Alloc ACL Action")
        packet_action = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                s32=SAI_PACKET_ACTION_DROP))

        print("Alloc ACL Entry")
        acl_egress_entry_id = sai_thrift_create_acl_entry(
            self.client,
            table_id=acl_egress_table_id,
            priority=entry_priority,
            field_src_ip=src_ip_t,
            field_out_port=out_port_t,
            action_packet_action=packet_action)
        self.assertNotEqual(acl_egress_entry_id, 0)

        # ACL counter
        acl_counter_egress = sai_thrift_create_acl_counter(
            self.client, table_id=acl_egress_table_id)
        # attach ACL counter to ACL entry
        action_counter_egress = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=acl_counter_egress),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, acl_egress_entry_id,
            action_counter=action_counter_egress)

        # Attach ACL in egress direction
        sai_thrift_set_switch_attribute(
            self.client, egress_acl=acl_egress_table_id)

        try:
            print("Sending packet port 11 -[ACL]-> port 10 (192.168.0.1"
                  "-[ACL]-> 172.16.10.1 [id = 105])")
            print('#### ACL \'DROP, src ip 192.168.100.1/255.255.255.0, '
                  ' Out Port port10 \' Applied ####')
            print('#### Sending      ', ROUTER_MAC, '| 00:22:22:22:22:22 | '
                  '172.16.10.1 | 192.168.100.100 | @ Port 11')
            send_packet(self, self.dev_port11, self.pkt)
            print('#### NOT Expecting 00:11:22:33:44:55 |', ROUTER_MAC, '| '
                  '172.16.10.1 | 192.168.100.100 | @ Port 10')
            verify_no_other_packets(self, timeout=1)

            time.sleep(2)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter_egress, packets=True)
            self.assertEqual(packets['packets'], 1)

            print('#### Check No Drop on other ports for srcip/outport####')
            print("Creating a new route entry for a different destination"
                  " with same src ip")

            ipv4_dst = '182.16.10.1'
            dmac = '00:11:22:33:44:56'
            ipv4_dst_subnet = '182.16.10.0'

            print("Alloc neighbor with %s ip address, %d router interface"
                  " id and %s destination mac" % (
                      ipv4_dst, self.rif_id3, dmac))
            self.nbr_entry1 = sai_thrift_neighbor_entry_t(
                rif_id=self.rif_id3,
                ip_address=sai_ipaddress(ipv4_dst))
            sai_thrift_create_neighbor_entry(
                self.client, self.nbr_entry1, dst_mac_address=dmac)

            print("Alloc nhop with %s ip address and %d router"
                  " interface id" % (ipv4_dst, self.rif_id3))
            self.nhop1 = sai_thrift_create_next_hop(
                self.client,
                ip=sai_ipaddress(ipv4_dst),
                router_interface_id=self.rif_id3,
                type=SAI_NEXT_HOP_TYPE_IP)

            pkt = simple_tcp_packet(eth_dst=ROUTER_MAC,
                                    eth_src="00:22:22:22:22:22",
                                    ip_dst=ipv4_dst,
                                    ip_src="192.168.100.100",
                                    tcp_sport=1000,
                                    ip_id=105,
                                    ip_ttl=64)
            exp_pkt = simple_tcp_packet(eth_dst=dmac,
                                        eth_src=ROUTER_MAC,
                                        ip_dst=ipv4_dst,
                                        ip_src="192.168.100.100",
                                        tcp_sport=1000,
                                        ip_id=105,
                                        ip_ttl=63)

            print('#### Sending  ', ROUTER_MAC, '| 00:22:22:22:22:22 | '
                  '182.16.10.1 | 192.168.100.100 | @ port 11')
            send_packet(self, self.dev_port11, pkt)
            print('#### Expecting 00:11:22:33:44:56 |', ROUTER_MAC, '| '
                  '182.16.10.1 | 192.168.100.100 | @ port 12')
            verify_packets(self, exp_pkt, [self.dev_port12])

        finally:
            # cleanup ACL
            action_counter_egress = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=0),
                enable=True)
            sai_thrift_set_acl_entry_attribute(
                self.client, acl_egress_entry_id,
                action_counter=action_counter_egress)
            sai_thrift_set_acl_counter_attribute(
                self.client, acl_counter_egress, packets=None)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter_egress, packets=True)
            self.assertEqual(packets['packets'], 0)
            sai_thrift_remove_acl_counter(self.client, acl_counter_egress)

            sai_thrift_remove_acl_entry(self.client, acl_egress_entry_id)
            sai_thrift_set_switch_attribute(self.client, egress_acl=0)
            sai_thrift_remove_acl_table(self.client, acl_egress_table_id)

    def egressAclDstIpOutPortTest(self):
        '''
        Verify out-port field with switch b-point to
        egress ipv4 ACL table entry with dst-ip match
        '''
        print("egressAclDstIpOutPortTest")

        table_stage_egress = SAI_ACL_STAGE_EGRESS
        entry_priority = 1
        ip_dst = "172.16.10.1"
        ip_dst_mask = "255.255.255.0"
        out_port_id = self.port10

        table_bind_points = [SAI_ACL_BIND_POINT_TYPE_SWITCH]
        table_bind_point_type_list = sai_thrift_s32_list_t(
            count=len(table_bind_points), int32list=table_bind_points)

        print("Alloc ACL Table")
        acl_egress_table_id = sai_thrift_create_acl_table(
            self.client,
            acl_stage=table_stage_egress,
            acl_bind_point_type_list=table_bind_point_type_list,
            field_dst_ip=True,
            field_out_port=True)
        self.assertNotEqual(acl_egress_table_id, 0)

        print("Alloc ACL field data")
        dst_ip_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(ip4=ip_dst),
            mask=sai_thrift_acl_field_data_mask_t(ip4=ip_dst_mask))
        out_port_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(oid=out_port_id))

        print("Alloc ACL Action")
        packet_action = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                s32=SAI_PACKET_ACTION_DROP))

        print("Alloc ACL Entry")
        acl_egress_entry_id = sai_thrift_create_acl_entry(
            self.client,
            table_id=acl_egress_table_id,
            priority=entry_priority,
            field_dst_ip=dst_ip_t,
            field_out_port=out_port_t,
            action_packet_action=packet_action)
        self.assertNotEqual(acl_egress_entry_id, 0)

        # create ACL counter
        acl_counter_egress = sai_thrift_create_acl_counter(
            self.client, table_id=acl_egress_table_id)
        # attach ACL counter to ACL entry
        action_counter_egress = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=acl_counter_egress),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, acl_egress_entry_id,
            action_counter=action_counter_egress)

        # attach ACL in egress direction
        sai_thrift_set_switch_attribute(
            self.client, egress_acl=acl_egress_table_id)

        try:
            print('#### ACL \'DROP, dst ip 172.16.10.1/255.255.255.0,'
                  ' out port Port 10\' Applied ####')
            print('#### Sending      ', ROUTER_MAC, '| 00:22:22:22:22:22 | '
                  '172.16.10.1 | 192.168.100.100 | @ Port 11')
            send_packet(self, self.dev_port11, self.pkt)
            print('#### NOT Expecting 00:11:22:33:44:55 |', ROUTER_MAC, '| '
                  '172.16.10.1 | 192.168.100.100 | @ Port 10')
            verify_no_other_packets(self, timeout=1)

            time.sleep(2)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter_egress, packets=True)
            self.assertEqual(packets['packets'], 1)

            print("Check no DROP on other ports for dstip/outport")
            print("Before updating route entry to new Nhop, delete existing")
            # cleanup Nhop, Neighbor
            sai_thrift_remove_next_hop(self.client, self.nhop)
            sai_thrift_remove_neighbor_entry(self.client, self.nbr_entry)

            ip_addr_subnet = '172.16.10.0'
            ip_addr = '172.16.10.1'
            dmac = '00:11:22:33:44:55'

            print("Alloc neighbor with %s ip address, %d router interface"
                  " id and %s destination mac" % (
                      ip_addr, self.rif_id3, dmac))
            self.nbr_entry = sai_thrift_neighbor_entry_t(
                rif_id=self.rif_id3,
                ip_address=sai_ipaddress(ip_addr))
            sai_thrift_create_neighbor_entry(
                self.client, self.nbr_entry, dst_mac_address=dmac)

            print("Alloc nhop with %s ip address and %d router"
                  " interface id" % (ip_addr, self.rif_id3))
            self.nhop = sai_thrift_create_next_hop(
                self.client,
                ip=sai_ipaddress(ip_addr),
                router_interface_id=self.rif_id3,
                type=SAI_NEXT_HOP_TYPE_IP)

            print('#### Sending  ', ROUTER_MAC, '| 00:22:22:22:22:22 | '
                  '172.16.10.1 | 192.168.100.1 | @ port 11 ')
            send_packet(self, self.dev_port11, self.pkt)
            print('#### Expecting 00:11:22:33:44:55 |', ROUTER_MAC, '| '
                  '172.16.10.1 | 192.168.100.1 | @ port 10 ')
            verify_packets(self, self.exp_pkt, [self.dev_port12])

        finally:
            # cleanup ACL
            action_counter_egress = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=0),
                enable=True)
            sai_thrift_set_acl_entry_attribute(
                self.client, acl_egress_entry_id,
                action_counter=action_counter_egress)
            sai_thrift_set_acl_counter_attribute(
                self.client, acl_counter_egress, packets=None)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter_egress, packets=True)
            self.assertEqual(packets['packets'], 0)
            sai_thrift_remove_acl_counter(self.client, acl_counter_egress)

            sai_thrift_remove_acl_entry(self.client, acl_egress_entry_id)
            sai_thrift_set_switch_attribute(self.client, egress_acl=0)
            sai_thrift_remove_acl_table(self.client, acl_egress_table_id)

    def runTest(self):
        print("Testing OutPortAclTest")
        self.basicV4TrafficTest()
        self.egressAclSrcIpOutPortTest()
        self.egressAclDstIpOutPortTest()

    def tearDown(self):
        sai_thrift_remove_next_hop(self.client, self.nhop)
        sai_thrift_remove_next_hop(self.client, self.nhop1)
        sai_thrift_remove_neighbor_entry(self.client, self.nbr_entry)
        sai_thrift_remove_neighbor_entry(self.client, self.nbr_entry1)
        super(EgressOutPortV4AclTest, self).tearDown()


@group('acl2')
class EgressOutPortV6AclTest(SaiHelper):
    """
    Verify matching on Out Port for ipv6
    """
    def setUp(self):
        super(EgressOutPortV6AclTest, self).setUp()

        rif_id1 = self.port10_rif

        self.ipv6_addr = '4000::1'
        self.dmac = '00:22:22:22:22:22'
        ipv6_mask = "ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff"
        self.ipv6_addr_src = '2000::1'

        print("Alloc neighbor with %s ip address, %d router interface"
              " id and %s destination mac" % (
                  self.ipv6_addr, rif_id1, self.dmac))
        self.nbr_entry = sai_thrift_neighbor_entry_t(
            rif_id=rif_id1,
            ip_address=sai_ipaddress(self.ipv6_addr))
        sai_thrift_create_neighbor_entry(
            self.client, self.nbr_entry, dst_mac_address=self.dmac)

        print("Alloc nhop with %s ip address and %d router"
              " interface id" % (self.ipv6_addr, rif_id1))
        self.nhop = sai_thrift_create_next_hop(
            self.client,
            ip=sai_ipaddress(self.ipv6_addr),
            router_interface_id=rif_id1,
            type=SAI_NEXT_HOP_TYPE_IP)

        self.pktv6 = simple_tcpv6_packet(eth_dst=ROUTER_MAC,
                                         eth_src=self.dmac,
                                         ipv6_dst=self.ipv6_addr,
                                         ipv6_src=self.ipv6_addr_src,
                                         ipv6_hlim=64)
        self.exp_pktv6 = simple_tcpv6_packet(eth_dst=self.dmac,
                                             eth_src=ROUTER_MAC,
                                             ipv6_dst=self.ipv6_addr,
                                             ipv6_src=self.ipv6_addr_src,
                                             ipv6_hlim=63)

    def basicV6TrafficTest(self):
        '''
        Verify v6 traffic test before
        applying egress ipv6 ACl table entry.
        '''
        print("basicV6TrafficTest")

        print('--------------------------------------------------------------')
        print("Sending packet port 11 -> port 10 (2000::1 ---> 4000::1)")

        try:
            print('#### NO ACL APPLIED ####')
            print('#### Sending  ', ROUTER_MAC, '| 00:22:22:22:22:22 | 4000::1'
                  ' | 2000::1 | @ port 11')
            send_packet(self, self.dev_port11, self.pktv6)
            print('#### Expecting ', self.dmac, ' | ', ROUTER_MAC, '| 4000::1'
                  ' | 2000::1 | @ port 10')
            verify_packets(self, self.exp_pktv6, [self.dev_port10])

        finally:
            print('----------------------------------------------------------'
                  '------------------------------------')

    def egressAclSrcIpv6OutPortTest(self):
        '''
        Verify out-port field with switch b-point to
        egress ipv6 ACL table entry with src-ip match
        '''
        print("egressAclSrcIpv6OutPortTest")

        table_stage_egress = SAI_ACL_STAGE_EGRESS
        ipv6_mask = "ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff"
        out_port_id = self.port10

        table_bind_points = [SAI_ACL_BIND_POINT_TYPE_SWITCH]
        table_bind_point_type_list = sai_thrift_s32_list_t(
            count=len(table_bind_points), int32list=table_bind_points)

        print("Alloc ACL Table")
        acl_egress_table_id = sai_thrift_create_acl_table(
            self.client,
            acl_stage=table_stage_egress,
            acl_bind_point_type_list=table_bind_point_type_list,
            field_src_ipv6=True,
            field_out_port=True)
        self.assertNotEqual(acl_egress_table_id, 0)

        print("Alloc ACL field data")
        src_ip_t_ipv6 = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(ip6=self.ipv6_addr_src),
            mask=sai_thrift_acl_field_data_mask_t(
                ip6=ipv6_mask))

        out_port_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(oid=out_port_id))

        packet_action = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                s32=SAI_PACKET_ACTION_DROP))

        #  ACL entries
        print("Alloc ACL entries")

        ipv6_acl_egress_entry_id = sai_thrift_create_acl_entry(
            self.client,
            table_id=acl_egress_table_id,
            priority=9998,
            field_src_ipv6=src_ip_t_ipv6,
            field_out_port=out_port_t,
            action_packet_action=packet_action)
        self.assertNotEqual(ipv6_acl_egress_entry_id, 0)

        #  ACL counter
        acl_counter_egress_ipv6 = sai_thrift_create_acl_counter(
            self.client, table_id=acl_egress_table_id)

        # attach ACL counter to ACL entry
        action_counter_egress_ipv6 = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=acl_counter_egress_ipv6),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, ipv6_acl_egress_entry_id,
            action_counter=action_counter_egress_ipv6)

        # attach ACL in egress direction
        sai_thrift_set_switch_attribute(
            self.client, egress_acl=acl_egress_table_id)

        try:
            print('#### ACL \'DROP, src ip 2000::1, out port Port 10 \''
                  ' Applied ####')
            print('#### Sending  ', ROUTER_MAC, '| 00:22:22:22:22:22 | 4000::1'
                  ' | 2000::1 | @ Port 11')
            send_packet(self, self.dev_port11, self.pktv6)
            print('#### NOT Expecting ', self.dmac, ' | ', ROUTER_MAC, '| '
                  '4000::1 | 2000::1 | @ port 10')
            verify_no_other_packets(self, timeout=2)

            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter_egress_ipv6, packets=True)
            self.assertEqual(packets['packets'], 1)

            print("Check No Drop on other ports for srcipv6/outport")

            ipv6_dst = '3000::1'
            dmac = '00:11:22:33:44:56'

            print("Alloc neighbor with %s ip address, %d router interface"
                  " id and %s destination mac" % (
                      ipv6_dst, self.port12_rif, dmac))
            nbr_entry = sai_thrift_neighbor_entry_t(
                rif_id=self.port12_rif,
                ip_address=sai_ipaddress(ipv6_dst))
            sai_thrift_create_neighbor_entry(
                self.client, nbr_entry, dst_mac_address=dmac)

            print("Alloc nhop with %s ip address and %d router"
                  " interface id" % (ipv6_dst, self.port12_rif))
            nhop = sai_thrift_create_next_hop(
                self.client,
                ip=sai_ipaddress(ipv6_dst),
                router_interface_id=self.port12_rif,
                type=SAI_NEXT_HOP_TYPE_IP)

            pktv6 = simple_tcpv6_packet(eth_dst=ROUTER_MAC,
                                        eth_src=self.dmac,
                                        ipv6_dst=ipv6_dst,
                                        ipv6_src=self.ipv6_addr_src,
                                        ipv6_hlim=64)
            exp_pktv6 = simple_tcpv6_packet(eth_dst=dmac,
                                            eth_src=ROUTER_MAC,
                                            ipv6_dst=ipv6_dst,
                                            ipv6_src=self.ipv6_addr_src,
                                            ipv6_hlim=63)

            print('#### Sending  ', ROUTER_MAC, '| 00:22:22:22:22:22 | 3000::1'
                  ' | 2000::1 | @ dev_port11')
            send_packet(self, self.dev_port11, pktv6)
            print('#### Expecting ', dmac, ' | ', ROUTER_MAC, '| 3000::1'
                  ' | 2000::1 | @ dev_port12')
            verify_packets(self, exp_pktv6, [self.dev_port12])

        finally:
            # cleanup ACL
            action_counter_egress_ipv6 = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=0),
                enable=True)
            sai_thrift_set_acl_entry_attribute(
                self.client, ipv6_acl_egress_entry_id,
                action_counter=action_counter_egress_ipv6)
            sai_thrift_set_acl_counter_attribute(
                self.client, acl_counter_egress_ipv6, packets=None)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter_egress_ipv6, packets=True)
            self.assertEqual(packets['packets'], 0)
            sai_thrift_remove_acl_counter(self.client, acl_counter_egress_ipv6)

            sai_thrift_remove_acl_entry(self.client, ipv6_acl_egress_entry_id)
            sai_thrift_set_switch_attribute(self.client, egress_acl=0)
            sai_thrift_remove_acl_table(self.client, acl_egress_table_id)
            sai_thrift_remove_next_hop(self.client, nhop)
            sai_thrift_remove_neighbor_entry(self.client, nbr_entry)

    def egressAclDstIpv6OutPortTest(self):
        '''
        Verify out-port field with switch b-point to
        egress ipv6 ACL table entry with dst-ip match
        '''
        print("egressAclDstIpv6OutPortTest")

        # setup ACL table groups

        table_stage_egress = SAI_ACL_STAGE_EGRESS
        ipv6_mask = "ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff"
        ipv6_addr_dst = '4000::1'
        out_port_id = self.port10

        table_bind_points = [SAI_ACL_BIND_POINT_TYPE_SWITCH]
        table_bind_point_type_list = sai_thrift_s32_list_t(
            count=len(table_bind_points), int32list=table_bind_points)

        print("Alloc ACL Table")
        acl_egress_table_id = sai_thrift_create_acl_table(
            self.client,
            acl_stage=table_stage_egress,
            acl_bind_point_type_list=table_bind_point_type_list,
            field_dst_ipv6=True,
            field_out_port=True)
        self.assertNotEqual(acl_egress_table_id, 0)

        print("Alloc ACL field data")
        dst_ip_t_ipv6 = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(ip6=ipv6_addr_dst),
            mask=sai_thrift_acl_field_data_mask_t(
                ip6=ipv6_mask))

        out_port_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(oid=out_port_id))

        packet_action = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                s32=SAI_PACKET_ACTION_DROP))

        #  ACL entries
        print("Alloc ACL entries")

        ipv6_acl_egress_entry_id = sai_thrift_create_acl_entry(
            self.client,
            table_id=acl_egress_table_id,
            priority=9998,
            field_dst_ipv6=dst_ip_t_ipv6,
            field_out_port=out_port_t,
            action_packet_action=packet_action)
        self.assertNotEqual(ipv6_acl_egress_entry_id, 0)

        #  ACL counter
        acl_counter_egress_ipv6 = sai_thrift_create_acl_counter(
            self.client, table_id=acl_egress_table_id)

        # attach ACL counter to ACL entry
        action_counter_egress_ipv6 = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=acl_counter_egress_ipv6),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, ipv6_acl_egress_entry_id,
            action_counter=action_counter_egress_ipv6)

        # attach ACL in egress direction
        sai_thrift_set_switch_attribute(
            self.client, egress_acl=acl_egress_table_id)

        try:
            print('#### ACL \'DROP, dst ip 4000::1, out port Port 10 \''
                  ' Applied ####')
            print('#### Sending  ', ROUTER_MAC, '| 00:22:22:22:22:22 | 4000::1'
                  ' | 2000::1 | @ Port 11')
            send_packet(self, self.dev_port11, self.pktv6)
            print('#### NOT Expecting ', self.dmac, ' | ', ROUTER_MAC, '| '
                  '4000::1 | 2000::1 | @ Port 10')
            verify_no_other_packets(self, timeout=2)

            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter_egress_ipv6, packets=True)
            self.assertEqual(packets['packets'], 1)

            print("Check no DROP on other ports for dstipv6/outport")
            print("Before updating route entry to new Nhop, delete existing")
            # cleanup Route, Nhop, Neighbor
            sai_thrift_remove_next_hop(self.client, self.nhop)
            sai_thrift_remove_neighbor_entry(self.client, self.nbr_entry)

            rif_id2 = self.port12_rif
            print("Alloc neighbor with %s ip address, %d router interface"
                  " id and %s destination mac" % (
                      self.ipv6_addr, rif_id2, self.dmac))
            self.nbr_entry = sai_thrift_neighbor_entry_t(
                rif_id=rif_id2,
                ip_address=sai_ipaddress(self.ipv6_addr))
            sai_thrift_create_neighbor_entry(
                self.client, self.nbr_entry, dst_mac_address=self.dmac)

            print("Alloc nhop with %s ip address and %d router"
                  " interface id" % (self.ipv6_addr, rif_id2))
            self.nhop = sai_thrift_create_next_hop(
                self.client,
                ip=sai_ipaddress(self.ipv6_addr),
                router_interface_id=rif_id2,
                type=SAI_NEXT_HOP_TYPE_IP)

            print('#### Sending  ', ROUTER_MAC, '| 00:22:22:22:22:22 | 4000::1'
                  ' | 2000::1 | @ Port 11')
            send_packet(self, self.dev_port11, self.pktv6)
            print('#### Expecting ', self.dmac, ' | ', ROUTER_MAC, '| 4000::1'
                  ' | 2000::1 | @ Port 12')
            verify_packets(self, self.exp_pktv6, [self.dev_port12])

        finally:
            # cleanup ACL
            action_counter_egress_ipv6 = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=0),
                enable=True)
            sai_thrift_set_acl_entry_attribute(
                self.client, ipv6_acl_egress_entry_id,
                action_counter=action_counter_egress_ipv6)
            sai_thrift_set_acl_counter_attribute(
                self.client, acl_counter_egress_ipv6, packets=None)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter_egress_ipv6, packets=True)
            self.assertEqual(packets['packets'], 0)
            sai_thrift_remove_acl_counter(self.client, acl_counter_egress_ipv6)

            sai_thrift_remove_acl_entry(self.client, ipv6_acl_egress_entry_id)
            sai_thrift_set_switch_attribute(self.client, egress_acl=0)
            sai_thrift_remove_acl_table(self.client, acl_egress_table_id)

    def runTest(self):
        print("Testing OutPortAclTest")
        self.basicV6TrafficTest()
        self.egressAclSrcIpv6OutPortTest()
        self.egressAclDstIpv6OutPortTest()

    def tearDown(self):
        sai_thrift_remove_next_hop(self.client, self.nhop)
        sai_thrift_remove_neighbor_entry(self.client, self.nbr_entry)
        super(EgressOutPortV6AclTest, self).tearDown()


@group('acl2')
class EgressOutPortMACAclTest(SaiHelper):
    """
    Verify matching on Out Port and MAC
    """

    def setUp(self):
        super(EgressOutPortMACAclTest, self).setUp()

        rif_id1 = self.port10_rif
        self.rif_id2 = self.port11_rif

        ip_addr_subnet = '172.16.10.0'
        ip_addr = '172.16.10.1'
        dmac = '00:11:22:33:44:55'
        self.mac_src = '00:22:22:22:22:22'
        ip_addr_src = '192.168.0.1'

        print("Alloc neighbor with %s ip address, %d router interface"
              " id and %s destination mac" % (
                  ip_addr, rif_id1, dmac))
        self.nbr_entry = sai_thrift_neighbor_entry_t(
            rif_id=rif_id1,
            ip_address=sai_ipaddress(ip_addr))
        sai_thrift_create_neighbor_entry(
            self.client, self.nbr_entry, dst_mac_address=dmac)

        print("Alloc nhop with %s ip address and %d router"
              " interface id" % (ip_addr, rif_id1))
        self.nhop = sai_thrift_create_next_hop(
            self.client,
            ip=sai_ipaddress(ip_addr),
            router_interface_id=rif_id1,
            type=SAI_NEXT_HOP_TYPE_IP)

        self.pkt = simple_tcp_packet(eth_dst=ROUTER_MAC,
                                     eth_src=self.mac_src,
                                     ip_dst=ip_addr,
                                     ip_src=ip_addr_src,
                                     ip_id=105,
                                     ip_ttl=64)
        self.exp_pkt = simple_tcp_packet(eth_dst=dmac,
                                         eth_src=ROUTER_MAC,
                                         ip_dst=ip_addr,
                                         ip_src=ip_addr_src,
                                         ip_id=105,
                                         ip_ttl=63)

    def basicMacTrafficTest(self):
        '''
        Verify mac traffic test before
        applying egress mac ACl table entry.
        '''
        print("basicMacTrafficTest")

        print('--------------------------------------------------------------')
        print("Sending packet port 11 -> port 10 (192.168.0.1 --->"
              " 172.16.10.1 [id = 105])")

        try:
            print('#### NO ACL Applied ####')
            print('#### Sending  ', ROUTER_MAC, '| 00:22:22:22:22:22 | '
                  '172.16.10.1 | 192.168.100.1 | @ port 11 ')
            send_packet(self, self.dev_port11, self.pkt)
            print('#### Expecting 00:11:22:33:44:55 |', ROUTER_MAC, '| '
                  '172.16.10.1 | 192.168.100.1 | @ port 10 ')
            verify_packets(self, self.exp_pkt, [self.dev_port10])
        finally:
            print('----------------------------------------------------------')

            print("Sending packet port 11 -[ACL]-> port 10 (192.168.0.1-"
                  "[ACL]-> 172.16.10.1 [id = 105])")
            # setup ACL to block based on Source MAC

    def egressAclSrcMacOutPortTest(self):
        '''
        Verify out-port field with switch b-point to
        egress MAC ACL table entry with Src Mac match
        '''
        print("egressMacAclTableTest")

        table_stage_egress = SAI_ACL_STAGE_EGRESS
        entry_priority = 1
        mac_src = ROUTER_MAC
        mac_src_mask = 'ff:ff:ff:ff:ff:ff'
        out_port_id = self.port10

        table_bind_points = [SAI_ACL_BIND_POINT_TYPE_SWITCH]
        table_bind_point_type_list = sai_thrift_s32_list_t(
            count=len(table_bind_points), int32list=table_bind_points)

        print("Alloc ACL Table")
        acl_egress_table_id = sai_thrift_create_acl_table(
            self.client,
            acl_stage=table_stage_egress,
            acl_bind_point_type_list=table_bind_point_type_list,
            field_src_mac=True,
            field_out_port=True)
        self.assertNotEqual(acl_egress_table_id, 0)

        print("Alloc ACL Field Data")
        src_mac_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(mac=mac_src),
            mask=sai_thrift_acl_field_data_mask_t(mac=mac_src_mask))
        out_port_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(oid=out_port_id))

        print("Alloc ACL Action")
        packet_action = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                s32=SAI_PACKET_ACTION_DROP))

        print("Alloc ACL Entry")
        acl_egress_entry_id = sai_thrift_create_acl_entry(
            self.client,
            table_id=acl_egress_table_id,
            priority=entry_priority,
            field_src_mac=src_mac_t,
            field_out_port=out_port_t,
            action_packet_action=packet_action)
        self.assertNotEqual(acl_egress_entry_id, 0)

        #  ACL counter
        acl_counter_egress = sai_thrift_create_acl_counter(
            self.client, table_id=acl_egress_table_id)
        # attach ACL counter to ACL entry
        action_counter_egress = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=acl_counter_egress),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, acl_egress_entry_id,
            action_counter=action_counter_egress)

        # attach this ACL table to rif_id2s object id
        sai_thrift_set_switch_attribute(
            self.client, egress_acl=acl_egress_table_id)

        try:
            print('#### ACL \'DROP, src mac 00:22:22:22:22:22, Out Port 10'
                  '\' Applied ####')
            print('#### Sending      ', ROUTER_MAC, '| 00:22:22:22:22:22 | '
                  '172.16.10.1 | 192.168.0.1 | @ Port 11')
            # send the same packet
            send_packet(self, self.dev_port11, self.pkt)
            # ensure packet is dropped
            # check for absence of packet here!
            print('#### NOT Expecting 00:11:22:33:44:55 |', ROUTER_MAC,
                  '| 172.16.10.1 | 192.168.0.1 | @ Port 10')
            verify_no_other_packets(self, timeout=2)

            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter_egress, packets=True)
            self.assertEqual(packets['packets'], 1)

            print('#### Check No Drop on other ports ####')

            ipv4_dst = '182.16.10.1'
            dmac = '00:11:22:33:44:56'
            ipv4_dst_subnet = '182.16.10.0'
            print("Alloc neighbor with %s ip address, %d router interface"
                  " id and %s destination mac" % (
                      ipv4_dst, self.dev_port12, dmac))
            nbr_entry = sai_thrift_neighbor_entry_t(
                rif_id=self.port12_rif,
                ip_address=sai_ipaddress(ipv4_dst))
            sai_thrift_create_neighbor_entry(
                self.client, nbr_entry, dst_mac_address=dmac)

            print("Alloc nhop with %s ip address and %d router"
                  " interface id" % (ipv4_dst, self.dev_port12))
            nhop = sai_thrift_create_next_hop(
                self.client,
                ip=sai_ipaddress(ipv4_dst),
                router_interface_id=self.port12_rif,
                type=SAI_NEXT_HOP_TYPE_IP)

            pkt = simple_tcp_packet(eth_dst=ROUTER_MAC,
                                    eth_src="00:22:22:22:22:22",
                                    ip_dst=ipv4_dst,
                                    ip_src="192.168.100.100",
                                    tcp_sport=1000,
                                    ip_id=105,
                                    ip_ttl=64)
            exp_pkt = simple_tcp_packet(eth_dst=dmac,
                                        eth_src=ROUTER_MAC,
                                        ip_dst=ipv4_dst,
                                        ip_src="192.168.100.100",
                                        tcp_sport=1000,
                                        ip_id=105,
                                        ip_ttl=63)

            print('#### Sending  ', ROUTER_MAC, '| 00:22:22:22:22:22 | '
                  '182.16.10.1 | 192.168.100.100 | SPORT 1000 | @ port 11')
            send_packet(self, self.dev_port11, pkt)
            print('#### Expecting 00:11:22:33:44:56 |', ROUTER_MAC, '| '
                  '182.16.10.1 | 192.168.100.100 | SPORT 1000 | @ port 12')
            verify_packets(self, exp_pkt, [self.dev_port12])

        finally:
            # cleanup ACL
            action_counter_egress = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=0),
                enable=True)
            sai_thrift_set_acl_entry_attribute(
                self.client, acl_egress_entry_id,
                action_counter=action_counter_egress)
            sai_thrift_set_acl_counter_attribute(
                self.client, acl_counter_egress, packets=None)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter_egress, packets=True)
            self.assertEqual(packets['packets'], 0)
            sai_thrift_remove_acl_counter(self.client, acl_counter_egress)

            # cleanup ACL
            sai_thrift_remove_acl_entry(self.client, acl_egress_entry_id)
            sai_thrift_set_switch_attribute(self.client, egress_acl=0)
            sai_thrift_remove_acl_table(self.client, acl_egress_table_id)
            sai_thrift_remove_next_hop(self.client, nhop)
            sai_thrift_remove_neighbor_entry(self.client, nbr_entry)

    def egressAclDstMacOutPortTest(self):
        '''
        Verify out-port field with switch b-point to
        egress MAC ACL table entry with Dst Mac match
        '''
        print("egressMacAclTableTest")

        table_stage_egress = SAI_ACL_STAGE_EGRESS
        entry_priority = 1
        mac_dst = '00:11:22:33:44:55'
        mac_dst_mask = 'ff:ff:ff:ff:ff:ff'
        out_port_id = self.port10

        table_bind_points = [SAI_ACL_BIND_POINT_TYPE_SWITCH]
        table_bind_point_type_list = sai_thrift_s32_list_t(
            count=len(table_bind_points), int32list=table_bind_points)

        print("Alloc ACL Table")
        acl_egress_table_id = sai_thrift_create_acl_table(
            self.client,
            acl_stage=table_stage_egress,
            acl_bind_point_type_list=table_bind_point_type_list,
            field_dst_mac=True,
            field_out_port=True)
        self.assertNotEqual(acl_egress_table_id, 0)

        print("Alloc ACL Field Data")
        dst_mac_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(mac=mac_dst),
            mask=sai_thrift_acl_field_data_mask_t(mac=mac_dst_mask))
        out_port_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(oid=out_port_id))

        packet_action = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                s32=SAI_PACKET_ACTION_DROP))

        print("Alloc ACL Entry")
        acl_egress_entry_id = sai_thrift_create_acl_entry(
            self.client,
            table_id=acl_egress_table_id,
            priority=entry_priority,
            field_dst_mac=dst_mac_t,
            field_out_port=out_port_t,
            action_packet_action=packet_action)
        self.assertNotEqual(acl_egress_entry_id, 0)

        # Alloc ACL counter
        acl_counter_egress = sai_thrift_create_acl_counter(
            self.client, table_id=acl_egress_table_id)
        # attach ACL counter to ACL entry
        action_counter_egress = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=acl_counter_egress),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, acl_egress_entry_id,
            action_counter=action_counter_egress)

        # attach this ACL table to rif_id2s object id
        sai_thrift_set_switch_attribute(
            self.client, egress_acl=acl_egress_table_id)

        try:
            print('#### ACL \'DROP, dst mac 00:11:22:33:44:55, '
                  'Out Port 10\' Applied ####')
            print('#### Sending      ', ROUTER_MAC, '| 00:22:22:22:22:22 | '
                  '172.16.10.1 | 192.168.0.1 | @ Port 11')
            # send the same packet
            send_packet(self, self.dev_port11, self.pkt)
            # ensure packet is dropped
            # check for absence of packet here!
            print('#### NOT Expecting 00:11:22:33:44:55 |', ROUTER_MAC,
                  '| 172.16.10.1 | 192.168.0.1 | @ Port 10')
            verify_no_other_packets(self, timeout=2)

            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter_egress, packets=True)
            self.assertEqual(packets['packets'], 1)

            sai_thrift_remove_next_hop(self.client, self.nhop)
            sai_thrift_remove_neighbor_entry(self.client, self.nbr_entry)

            ip_addr = '172.16.10.1'
            ip_addr_subnet = '172.16.10.0'
            dmac = '00:11:22:33:44:55'
            print("Alloc neighbor with %s ip address, %d router interface"
                  " id and %s destination mac" % (
                      ip_addr, self.port12_rif, dmac))
            self.nbr_entry = sai_thrift_neighbor_entry_t(
                rif_id=self.port12_rif,
                ip_address=sai_ipaddress(ip_addr))
            sai_thrift_create_neighbor_entry(
                self.client, self.nbr_entry, dst_mac_address=dmac)

            print("Alloc nhop with %s ip address and %d router"
                  " interface id" % (ip_addr, self.port12_rif))
            self.nhop = sai_thrift_create_next_hop(
                self.client,
                ip=sai_ipaddress(ip_addr),
                router_interface_id=self.port12_rif,
                type=SAI_NEXT_HOP_TYPE_IP)

            print('#### NO ACL Applied ####')
            print('#### Sending  ', ROUTER_MAC, '| 00:22:22:22:22:22 | '
                  '172.16.10.1 | 192.168.100.1 | @ port 11 ')
            send_packet(self, self.dev_port11, self.pkt)
            print('#### Expecting 00:11:22:33:44:55 |', ROUTER_MAC, '| '
                  '172.16.10.1 | 192.168.100.1 | @ port 10 ')
            verify_packets(self, self.exp_pkt, [self.dev_port12])
        finally:
            # cleanup ACL
            action_counter_egress = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=0),
                enable=True)
            sai_thrift_set_acl_entry_attribute(
                self.client, acl_egress_entry_id,
                action_counter=action_counter_egress)
            sai_thrift_set_acl_counter_attribute(
                self.client, acl_counter_egress, packets=None)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter_egress, packets=True)
            self.assertEqual(packets['packets'], 0)
            sai_thrift_remove_acl_counter(self.client, acl_counter_egress)

            # cleanup ACL
            sai_thrift_remove_acl_entry(self.client, acl_egress_entry_id)
            sai_thrift_set_switch_attribute(self.client, egress_acl=0)
            sai_thrift_remove_acl_table(self.client, acl_egress_table_id)

    def runTest(self):
        print("Testing EgressOutPortMACAclTest")
        self.basicMacTrafficTest()
        self.egressAclSrcMacOutPortTest()
        self.egressAclDstMacOutPortTest()

    def tearDown(self):
        sai_thrift_remove_next_hop(self.client, self.nhop)
        sai_thrift_remove_neighbor_entry(self.client, self.nbr_entry)
        super(EgressOutPortMACAclTest, self).tearDown()


@group('acl2')
class EgressOutPortLagAclTest(SaiHelper):
    """
    Verify Out Port as lag
    """
    def setUp(self):
        super(EgressOutPortLagAclTest, self).setUp()

        print("Alloc Lag")
        self.lag_id = sai_thrift_create_lag(self.client)
        self.lag_id1 = sai_thrift_create_lag(self.client)

        self.lag_member_id1 = sai_thrift_create_lag_member(
            self.client, lag_id=self.lag_id, port_id=self.port24)

        self.lag_member_id2 = sai_thrift_create_lag_member(
            self.client, lag_id=self.lag_id1, port_id=self.port25)

        print("Alloc Vrf, nbr, nhop, route")
        self.vrf = sai_thrift_create_virtual_router(self.client)
        self.rif_id1 = sai_thrift_create_router_interface(
            self.client,
            type=SAI_ROUTER_INTERFACE_TYPE_PORT,
            virtual_router_id=self.vrf,
            port_id=self.lag_id)

        self.rif_id2 = sai_thrift_create_router_interface(
            self.client,
            type=SAI_ROUTER_INTERFACE_TYPE_PORT,
            virtual_router_id=self.vrf,
            port_id=self.port26)

        self.rif_id3 = sai_thrift_create_router_interface(
            self.client,
            type=SAI_ROUTER_INTERFACE_TYPE_PORT,
            virtual_router_id=self.vrf,
            port_id=self.lag_id1)

        self.ip_addr1 = "20.0.0.2"
        self.ip_addr_subnet1 = '20.0.0.0'
        self.dmac1 = '00:22:22:22:22:22'
        self.ip_addr_subnet2 = '192.168.0.0'
        self.ip_addr2 = '192.168.0.1'
        self.dmac2 = '00:11:22:33:44:55'
        self.ip_addr_subnet3 = '182.168.0.0'
        self.ip_addr3 = '182.168.0.1'
        self.dmac3 = '00:11:22:33:44:56'
        self.ip_src_mask = "255.255.255.255"
        mask = '/16'

        ip_src = self.ip_addr1
        ip_dst = self.ip_addr_subnet2
        ip_dst1 = self.ip_addr_subnet3
        sport = self.dev_port26
        dport1 = self.dev_port24

        self.neighbor_entry1 = sai_thrift_neighbor_entry_t(
            rif_id=self.rif_id1, ip_address=sai_ipaddress(self.ip_addr2))
        sai_thrift_create_neighbor_entry(
            self.client,
            self.neighbor_entry1,
            dst_mac_address=self.dmac1)

        self.nhop1 = sai_thrift_create_next_hop(
            self.client,
            ip=sai_ipaddress(self.ip_addr2),
            router_interface_id=self.rif_id1,
            type=SAI_NEXT_HOP_TYPE_IP)

        self.route_entry1 = sai_thrift_route_entry_t(
            vr_id=self.vrf,
            destination=sai_ipprefix(self.ip_addr_subnet2 + mask))
        sai_thrift_create_route_entry(
            self.client,
            self.route_entry1,
            next_hop_id=self.nhop1)

        self.neighbor_entry2 = sai_thrift_neighbor_entry_t(
            rif_id=self.rif_id2, ip_address=sai_ipaddress(self.ip_addr1))
        sai_thrift_create_neighbor_entry(
            self.client,
            self.neighbor_entry2,
            dst_mac_address=self.dmac2)

        self.nhop2 = sai_thrift_create_next_hop(
            self.client,
            ip=sai_ipaddress(self.ip_addr1),
            router_interface_id=self.rif_id2,
            type=SAI_NEXT_HOP_TYPE_IP)

        self.route_entry2 = sai_thrift_route_entry_t(
            vr_id=self.vrf,
            destination=sai_ipprefix(self.ip_addr_subnet1 + mask))
        sai_thrift_create_route_entry(
            self.client,
            self.route_entry2,
            next_hop_id=self.nhop2)

        self.neighbor_entry3 = sai_thrift_neighbor_entry_t(
            rif_id=self.rif_id3, ip_address=sai_ipaddress(self.ip_addr3))
        sai_thrift_create_neighbor_entry(
            self.client,
            self.neighbor_entry3,
            dst_mac_address=self.dmac3)

        self.nhop3 = sai_thrift_create_next_hop(
            self.client,
            ip=sai_ipaddress(self.ip_addr3),
            router_interface_id=self.rif_id3,
            type=SAI_NEXT_HOP_TYPE_IP)

        self.route_entry3 = sai_thrift_route_entry_t(
            vr_id=self.vrf,
            destination=sai_ipprefix(self.ip_addr_subnet3 + mask))
        sai_thrift_create_route_entry(
            self.client,
            self.route_entry3,
            next_hop_id=self.nhop3)

        self.pkt = simple_tcp_packet(
            eth_dst=ROUTER_MAC,
            eth_src=self.dmac1,
            ip_src=ip_src,
            ip_dst=ip_dst,
            tcp_sport=0x4321,
            tcp_dport=0x51,
            ip_ttl=64)
        self.exp_pkt = simple_tcp_packet(
            eth_dst=self.dmac1,
            eth_src=ROUTER_MAC,
            ip_src=ip_src,
            ip_dst=ip_dst,
            tcp_sport=0x4321,
            tcp_dport=0x51,
            ip_ttl=63)

        try:
            # Validate regular traffic on lag
            print("Check Regular traffic")
            send_packet(self, sport, self.pkt)
            verify_packets(self, self.exp_pkt, ports=[self.dev_port24])

        finally:
            print('----------------------------------------------------------')

    def runTest(self):
        self.egressAclLagOutPortTest()

    def tearDown(self):
        sai_thrift_remove_route_entry(self.client, self.route_entry3)
        sai_thrift_remove_next_hop(self.client, self.nhop3)
        sai_thrift_remove_neighbor_entry(self.client, self.neighbor_entry3)
        sai_thrift_remove_route_entry(self.client, self.route_entry2)
        sai_thrift_remove_next_hop(self.client, self.nhop2)
        sai_thrift_remove_neighbor_entry(self.client, self.neighbor_entry2)
        sai_thrift_remove_route_entry(self.client, self.route_entry1)
        sai_thrift_remove_next_hop(self.client, self.nhop1)
        sai_thrift_remove_neighbor_entry(self.client, self.neighbor_entry1)
        sai_thrift_remove_router_interface(self.client, self.rif_id3)
        sai_thrift_remove_router_interface(self.client, self.rif_id2)
        sai_thrift_remove_router_interface(self.client, self.rif_id1)
        sai_thrift_remove_lag_member(self.client, self.lag_member_id1)
        sai_thrift_remove_lag(self.client, self.lag_id)
        sai_thrift_remove_lag_member(self.client, self.lag_member_id2)
        sai_thrift_remove_lag(self.client, self.lag_id1)
        sai_thrift_remove_virtual_router(self.client, self.vrf)
        super(EgressOutPortLagAclTest, self).tearDown()

    def egressAclLagOutPortTest(self):
        '''
        Verify out-port as Lag with switch b-point to
        egress IPV4 ACL table entry with Src IP match
        '''
        table_stage_egress = SAI_ACL_STAGE_EGRESS
        table_bind_point_list = [SAI_ACL_BIND_POINT_TYPE_SWITCH]
        action = SAI_PACKET_ACTION_DROP

        out_port_id = self.lag_id

        table_bind_point_type_list = sai_thrift_s32_list_t(
            count=len(table_bind_point_list),
            int32list=table_bind_point_list)

        packet_action = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                s32=action))

        print("Alloc ACL Table")
        acl_table_ipv4_id = sai_thrift_create_acl_table(
            self.client,
            acl_stage=table_stage_egress,
            acl_bind_point_type_list=table_bind_point_type_list,
            field_out_port=True,
            field_src_ip=True)

        print("Alloc ACL Field Data")
        src_ip_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(ip4=self.ip_addr1),
            mask=sai_thrift_acl_field_data_mask_t(ip4=self.ip_src_mask))
        out_port_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(oid=out_port_id))

        print("Alloc ACL Entry")
        acl_entry_id = sai_thrift_create_acl_entry(
            self.client,
            table_id=acl_table_ipv4_id,
            priority=9999,
            field_src_ip=src_ip_t,
            field_out_port=out_port_t,
            action_packet_action=packet_action)

        # ACL counter
        acl_counter_egress = sai_thrift_create_acl_counter(
            self.client, table_id=acl_table_ipv4_id)

        # attach ACL counter to ACL entry
        action_counter_egress = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=acl_counter_egress),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, acl_entry_id,
            action_counter=action_counter_egress)

        # Now attach the ACL table to egress- the packet should be dropped
        print("Attach ACL Table in the egress direction")
        sai_thrift_set_switch_attribute(
            self.client, egress_acl=acl_table_ipv4_id)

        try:
            print("Drop packets with Src IP 20.0.0.2 and "
                  "outport as lag")
            send_packet(self, self.dev_port26, self.pkt)
            verify_no_other_packets(self, timeout=1)

            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter_egress, packets=True)
            self.assertEqual(packets['packets'], 1)

            print("Check No Drop on other lag")
            pkt1 = simple_tcp_packet(
                eth_dst=ROUTER_MAC,
                eth_src=self.dmac1,
                ip_src=self.ip_addr1,
                ip_dst=self.ip_addr_subnet3,
                tcp_sport=0x4321,
                tcp_dport=0x51,
                ip_ttl=64)
            exp_pkt1 = simple_tcp_packet(
                eth_dst=self.dmac3,
                eth_src=ROUTER_MAC,
                ip_src=self.ip_addr1,
                ip_dst=self.ip_addr_subnet3,
                tcp_sport=0x4321,
                tcp_dport=0x51,
                ip_ttl=63)

            send_packet(self, self.dev_port26, pkt1)
            verify_packets(self, exp_pkt1, ports=[self.dev_port25])

        finally:
            # cleanup ACL
            action_counter_egress = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=0),
                enable=True)
            sai_thrift_set_acl_entry_attribute(
                self.client, acl_entry_id,
                action_counter=action_counter_egress)
            sai_thrift_set_acl_counter_attribute(
                self.client, acl_counter_egress, packets=None)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter_egress, packets=True)
            self.assertEqual(packets['packets'], 0)
            sai_thrift_remove_acl_counter(self.client, acl_counter_egress)

            sai_thrift_remove_acl_entry(self.client, acl_entry_id)
            sai_thrift_set_switch_attribute(self.client, egress_acl=0)
            sai_thrift_remove_acl_table(self.client, acl_table_ipv4_id)


###############################################################################
# Below PTF are WIP - todo
###############################################################################


@disabled
# It is not possible to fully transfer this test form the old framework due to
# the fact that we don't support two IPV4 permit/deny ACLs to the same port.
# The test in its current form causes instability in other ACL tests.
# SWI-4847
class SonicACLTest(SaiHelper):
    """
    Create an ACL group per port
    Create an ACL group member per table and per group
    Add entries in each of the tables and test ACLs work as expected
    """

    def setUp(self):
        super(SonicACLTest, self).setUp()

        rif_id1 = self.port10_rif

        ip_addr_subnet = '192.168.0.0'
        ip_addr = '192.168.0.1'
        self.dmac = '00:22:22:22:22:22'

        print("Create neighbor with %s ip address, %d router interface"
              " id and %s destination mac" % (
                  ip_addr, rif_id1, self.dmac))
        self.nbr_entry = sai_thrift_neighbor_entry_t(
            rif_id=rif_id1,
            ip_address=sai_ipaddress(ip_addr))
        sai_thrift_create_neighbor_entry(
            self.client, self.nbr_entry, dst_mac_address=self.dmac)

        print("Create nhop with %s ip address and %d router"
              " interface id" % (ip_addr, rif_id1))
        self.nhop = sai_thrift_create_next_hop(
            self.client,
            ip=sai_ipaddress(ip_addr),
            router_interface_id=rif_id1,
            type=SAI_NEXT_HOP_TYPE_IP)

        print("Create route with %s ip prefix and %d router"
              " interface id" % (ip_addr_subnet, rif_id1))
        self.route_entry = sai_thrift_route_entry_t(
            vr_id=self.default_vrf, destination=sai_ipprefix(
                ip_addr_subnet))
        sai_thrift_create_route_entry(self.client, self.route_entry,
                                      next_hop_id=rif_id1)

    def runTest(self):
        # setup ACL table group
        acl_ingress_groups_list = []
        acl_ingress_group_members_list = []
        counters = []
        action_counters = []
        acl_entries = []
        acl_rules = []
        ip_mask = '255.255.255.0'
        ipv4_addr = '192.168.0.1'

        group_stage_ingress = SAI_ACL_STAGE_INGRESS
        group_bind_point_list = [SAI_ACL_BIND_POINT_TYPE_PORT]
        group_type = SAI_ACL_TABLE_GROUP_TYPE_PARALLEL

        group_bind_point_type_list = sai_thrift_s32_list_t(
            count=len(group_bind_point_list), int32list=group_bind_point_list)

        ports_list = [self.port0, self.port1, self.port2, self.port3,
                      self.port4, self.port5, self.port6, self.port7,
                      self.port8, self.port9, self.port10, self.port11,
                      self.port12, self.port13, self.port14, self.port15,
                      self.port16, self.port17, self.port18, self.port19,
                      self.port20, self.port21, self.port22, self.port23,
                      self.port24, self.port25, self.port26, self.port27,
                      self.port28, self.port29, self.port30, self.port31]

        for index, port in enumerate(ports_list):
            # create ACL table group
            acl_table_group_ingress = sai_thrift_create_acl_table_group(
                self.client,
                acl_stage=group_stage_ingress,
                acl_bind_point_type_list=group_bind_point_type_list,
                type=group_type)

            print(index, port)
            acl_ingress_groups_list.append(acl_table_group_ingress)
            # bind this ACL group to ports object id
            print("Bind ACL ingress group 0x % lx to port 0x % lx" % (
                acl_ingress_groups_list[index], port))
            sai_thrift_set_port_attribute(
                self.client, port,
                ingress_acl=acl_ingress_groups_list[index])

        table_stage_ingress = SAI_ACL_STAGE_INGRESS
        table_bind_point_list = [SAI_ACL_BIND_POINT_TYPE_PORT]
        table_bind_point_type_list = sai_thrift_s32_list_t(
            count=len(table_bind_point_list), int32list=table_bind_point_list)

        packet_action = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                s32=SAI_PACKET_ACTION_DROP))

        print("Create ACL field data")
        src_ip_t_ipv4 = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(ip4=ipv4_addr),
            mask=sai_thrift_acl_field_data_mask_t(ip4=ip_mask))

        # create ACL tables
        print("Create ACL tables")
        acl_ingress_ipv4_table_id = sai_thrift_create_acl_table(
            self.client,
            acl_stage=table_stage_ingress,
            acl_bind_point_type_list=table_bind_point_type_list,
            field_src_ip=True)

        # create ACL ingress table group members
        for acl_group in acl_ingress_groups_list:
            # create ACL table group member 1 - v4 tables
            acl_group_ingress_ip_member_id = \
                sai_thrift_create_acl_table_group_member(
                    self.client,
                    acl_table_group_id=acl_group,
                    acl_table_id=acl_ingress_ipv4_table_id,
                    priority=1)

            acl_ingress_group_members_list.append(
                acl_group_ingress_ip_member_id)

        # create ACL entries in secondary ipv4 ACL

        # "ACL_RULE|DATAACL|DEFAULT_RULE": {
        #     "type": "hash",
        #     "value": {
        #         "ETHER_TYPE": "2048",
        #         "PACKET_ACTION": "DROP",
        #         "PRIORITY": "1"
        #     }
        # },
        ether_type = sai_thrift_acl_field_data_t(
            enable=True,
            data=sai_thrift_acl_field_data_data_t(u16=2048),
            mask=sai_thrift_acl_field_data_mask_t(u16=32767))

        acl_ingress_entry_id_default = sai_thrift_create_acl_entry(
            self.client,
            table_id=acl_ingress_ipv4_table_id,
            priority=1,
            field_ether_type=ether_type,
            action_packet_action=packet_action)

        # "ACL_RULE|DATAACL|RULE_1": {
        #     "type": "hash",
        #     "value": {
        #         "PACKET_ACTION": "FORWARD",
        #         "PRIORITY": "9999",
        #         "SRC_IP": "20.0.0.2/32"
        #     }
        # },
        print("Create ACL field data")
        src_ip_t_ipv4 = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(ip4="20.0.0.2"),
            mask=sai_thrift_acl_field_data_mask_t(ip4="255.255.255.255"))

        packet_action = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                s32=SAI_PACKET_ACTION_FORWARD))\

        acl_ingress_entry_id1 = sai_thrift_create_acl_entry(
            self.client,
            table_id=acl_ingress_ipv4_table_id,
            priority=9999,
            field_src_ip=src_ip_t_ipv4,
            action_packet_action=packet_action)

        # remove the entries just created in a secondary table
        # to simulate behaviour of SONiC CT
        sai_thrift_remove_acl_entry(self.client, acl_ingress_entry_id1)
        sai_thrift_remove_acl_entry(self.client, acl_ingress_entry_id_default)

        # create acl entries in ipv4 acl
        # catch all drop rule
        # "ACL_RULE|DATAINGRESS|DEFAULT_RULE": {
        #     "type": "hash",
        #     "value": {
        #         "ETHER_TYPE": "2048",
        #         "PACKET_ACTION": "DROP",
        #         "PRIORITY": "1"
        #     }
        # },
        packet_action = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                s32=SAI_PACKET_ACTION_DROP))

        acl_ingress_entry_id_default = sai_thrift_create_acl_entry(
            self.client,
            table_id=acl_ingress_ipv4_table_id,
            priority=1,
            field_ether_type=ether_type,
            action_packet_action=packet_action)

        # create ACL counter
        acl_counter_default = sai_thrift_create_acl_counter(
            self.client, table_id=acl_ingress_ipv4_table_id)

        # attach ACL counter to ACL entry
        action_counter_default = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=acl_counter_default),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, acl_ingress_entry_id_default,
            action_counter=action_counter_default)

        counters.append(acl_counter_default)
        action_counters.append(action_counter_default)
        acl_entries.append(acl_ingress_entry_id_default)
        acl_rules.append("DEFAULT_RULE")

        # "ACL_RULE|DATAINGRESS|RULE_1": {
        #     "type": "hash",
        #     "value": {
        #         "PACKET_ACTION": "FORWARD",
        #         "PRIORITY": "9999",
        #         "SRC_IP": "20.0.0.2/32"
        #     }
        # },
        packet_action = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                s32=SAI_PACKET_ACTION_FORWARD))

        acl_ingress_entry_id1 = sai_thrift_create_acl_entry(
            self.client,
            table_id=acl_ingress_ipv4_table_id,
            priority=9999,
            field_src_ip=src_ip_t_ipv4,
            action_packet_action=packet_action)

        # create ACL counter
        acl_counter_id1 = sai_thrift_create_acl_counter(
            self.client, table_id=acl_ingress_ipv4_table_id)

        # attach ACL counter to ACL entry
        action_counter_id1 = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=acl_counter_id1),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, acl_ingress_entry_id1,
            action_counter=action_counter_id1)

        counters.append(acl_counter_id1)
        action_counters.append(action_counter_id1)
        acl_entries.append(acl_ingress_entry_id1)
        acl_rules.append("RULE_1")

        # "ACL_RULE|DATAINGRESS|RULE_10": {
        #     "type": "hash",
        #     "value": {
        #         "L4_SRC_PORT_RANGE": "4656-4671",
        #         "PACKET_ACTION": "FORWARD",
        #         "PRIORITY": "9990"
        #     }
        # },
        u32range = sai_thrift_u32_range_t(min=4656, max=4671)
        acl_range_id1 = sai_thrift_create_acl_range(
            self.client,
            type=SAI_ACL_RANGE_TYPE_L4_SRC_PORT_RANGE,
            limit=u32range)
        range_list = [acl_range_id1]
        print("ACL range created 0x%lx" % (acl_range_id1))

        range_list_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(
                objlist=sai_thrift_object_list_t(
                    count=len(range_list),
                    idlist=range_list)))

        acl_ingress_entry_id10 = sai_thrift_create_acl_entry(
            self.client,
            table_id=acl_ingress_ipv4_table_id,
            priority=9990,
            action_packet_action=packet_action,
            field_acl_range_type=range_list_t)

        # create ACL counter
        acl_counter_id10 = sai_thrift_create_acl_counter(
            self.client, table_id=acl_ingress_ipv4_table_id)

        # attach ACL counter to ACL entry
        action_counter_id10 = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=acl_counter_id10),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, acl_ingress_entry_id10,
            action_counter=action_counter_id10)

        counters.append(acl_counter_id10)
        action_counters.append(action_counter_id10)
        acl_entries.append(acl_ingress_entry_id10)
        acl_rules.append("RULE_10")

        # "ACL_RULE|DATAINGRESS|RULE_11": {
        #     "type": "hash",
        #     "value": {
        #         "L4_DST_PORT_RANGE": "4640-4687",
        #         "PACKET_ACTION": "FORWARD",
        #         "PRIORITY": "9989"
        #     }
        # },
        u32range = sai_thrift_u32_range_t(min=4640, max=4687)
        acl_range_id2 = sai_thrift_create_acl_range(
            self.client,
            type=SAI_ACL_RANGE_TYPE_L4_DST_PORT_RANGE,
            limit=u32range)
        range_list = [acl_range_id2]
        print("ACL range created 0x%lx" % (acl_range_id2))

        range_list_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(
                objlist=sai_thrift_object_list_t(
                    count=len(range_list),
                    idlist=range_list)))

        acl_ingress_entry_id11 = sai_thrift_create_acl_entry(
            self.client,
            table_id=acl_ingress_ipv4_table_id,
            priority=9989,
            action_packet_action=packet_action,
            field_acl_range_type=range_list_t)

        # create ACL counter
        acl_counter_id11 = sai_thrift_create_acl_counter(
            self.client, table_id=acl_ingress_ipv4_table_id)

        # attach ACL counter to ACL entry
        action_counter_id11 = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=acl_counter_id11),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, acl_ingress_entry_id11,
            action_counter=action_counter_id11)

        counters.append(acl_counter_id11)
        action_counters.append(action_counter_id11)
        acl_entries.append(acl_ingress_entry_id11)
        acl_rules.append("RULE_11")

        # "ACL_RULE|DATAINGRESS|RULE_12": {
        #     "type": "hash",
        #     "value": {
        #         "IP_PROTOCOL": "1",
        #         "PACKET_ACTION": "FORWARD",
        #         "PRIORITY": "9988",
        #         "SRC_IP": "20.0.0.4/32"
        #     }
        # },
        src_ip_t_ipv4 = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(ip4="20.0.0.4"),
            mask=sai_thrift_acl_field_data_mask_t(ip4="255.255.255.255"))

        ip_protocol = sai_thrift_acl_field_data_t(
            enable=True,
            data=sai_thrift_acl_field_data_data_t(u8=1),
            mask=sai_thrift_acl_field_data_mask_t(u8=127))

        acl_ingress_entry_id12 = sai_thrift_create_acl_entry(
            self.client,
            table_id=acl_ingress_ipv4_table_id,
            priority=9988,
            action_packet_action=packet_action,
            field_src_ip=src_ip_t_ipv4,
            field_ip_protocol=ip_protocol)

        # create ACL counter
        acl_counter_id12 = sai_thrift_create_acl_counter(
            self.client, table_id=acl_ingress_ipv4_table_id)

        # attach ACL counter to ACL entry
        action_counter_id12 = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=acl_counter_id12),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, acl_ingress_entry_id12,
            action_counter=action_counter_id12)

        counters.append(acl_counter_id12)
        action_counters.append(action_counter_id12)
        acl_entries.append(acl_ingress_entry_id12)
        acl_rules.append("RULE_12")

        # "ACL_RULE|DATAINGRESS|RULE_13": {
        #     "type": "hash",
        #     "value": {
        #         "IP_PROTOCOL": "17",
        #         "PACKET_ACTION": "FORWARD",
        #         "PRIORITY": "9987",
        #         "SRC_IP": "20.0.0.4/32"
        #     }
        # }
        ip_protocol = sai_thrift_acl_field_data_t(
            enable=True,
            data=sai_thrift_acl_field_data_data_t(u8=17),
            mask=sai_thrift_acl_field_data_mask_t(u8=127))

        acl_ingress_entry_id13 = sai_thrift_create_acl_entry(
            self.client,
            table_id=acl_ingress_ipv4_table_id,
            priority=9987,
            action_packet_action=packet_action,
            field_src_ip=src_ip_t_ipv4,
            field_ip_protocol=ip_protocol)

        # create ACL counter
        acl_counter_id13 = sai_thrift_create_acl_counter(
            self.client, table_id=acl_ingress_ipv4_table_id)

        # attach ACL counter to ACL entry
        action_counter_id13 = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=acl_counter_id13),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, acl_ingress_entry_id13,
            action_counter=action_counter_id13)

        counters.append(acl_counter_id13)
        action_counters.append(action_counter_id13)
        acl_entries.append(acl_ingress_entry_id13)
        acl_rules.append("RULE_13")

        # "ACL_RULE|DATAINGRESS|RULE_14": {
        #     "type": "hash",
        #     "value": {
        #         "PACKET_ACTION": "DROP",
        #         "PRIORITY": "9986",
        #         "SRC_IP": "20.0.0.6/32"
        #     }
        # },
        src_ip_t_ipv4 = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(ip4="20.0.0.6"),
            mask=sai_thrift_acl_field_data_mask_t(ip4="255.255.255.255"))

        packet_action = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                s32=SAI_PACKET_ACTION_DROP))

        acl_ingress_entry_id14 = sai_thrift_create_acl_entry(
            self.client,
            table_id=acl_ingress_ipv4_table_id,
            priority=9986,
            action_packet_action=packet_action,
            field_src_ip=src_ip_t_ipv4)

        # create ACL counter
        acl_counter_id14 = sai_thrift_create_acl_counter(
            self.client, table_id=acl_ingress_ipv4_table_id)

        # attach ACL counter to ACL entry
        action_counter_id14 = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=acl_counter_id14),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, acl_ingress_entry_id14,
            action_counter=action_counter_id14)

        counters.append(acl_counter_id14)
        action_counters.append(action_counter_id14)
        acl_entries.append(acl_ingress_entry_id14)
        acl_rules.append("RULE_14")

        # "ACL_RULE|DATAINGRESS|RULE_15": {
        #     "type": "hash",
        #     "value": {
        #         "DST_IP": "192.168.0.17/32",
        #         "PACKET_ACTION": "DROP",
        #         "PRIORITY": "9985"
        #     }
        # },
        dst_ip_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(ip4="192.168.0.17"),
            mask=sai_thrift_acl_field_data_mask_t(ip4="255.255.255.255"))

        acl_ingress_entry_id15 = sai_thrift_create_acl_entry(
            self.client,
            table_id=acl_ingress_ipv4_table_id,
            priority=9985,
            action_packet_action=packet_action,
            field_dst_ip=dst_ip_t)

        # create ACL counter
        acl_counter_id15 = sai_thrift_create_acl_counter(
            self.client, table_id=acl_ingress_ipv4_table_id)

        # attach ACL counter to ACL entry
        action_counter_id15 = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=acl_counter_id15),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, acl_ingress_entry_id15,
            action_counter=action_counter_id15)

        counters.append(acl_counter_id15)
        action_counters.append(action_counter_id15)
        acl_entries.append(acl_ingress_entry_id15)
        acl_rules.append("RULE_15")

        # "ACL_RULE|DATAINGRESS|RULE_16": {
        #     "type": "hash",
        #     "value": {
        #         "DST_IP": "172.16.3.0/32",
        #         "PACKET_ACTION": "DROP",
        #         "PRIORITY": "9984"
        #     }
        # },
        dst_ip_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(ip4="172.16.3.0"),
            mask=sai_thrift_acl_field_data_mask_t(ip4="255.255.255.255"))

        acl_ingress_entry_id16 = sai_thrift_create_acl_entry(
            self.client,
            table_id=acl_ingress_ipv4_table_id,
            priority=9984,
            action_packet_action=packet_action,
            field_dst_ip=dst_ip_t)

        # create ACL counter
        acl_counter_id16 = sai_thrift_create_acl_counter(
            self.client, table_id=acl_ingress_ipv4_table_id)

        # attach ACL counter to ACL entry
        action_counter_id16 = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=acl_counter_id16),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, acl_ingress_entry_id16,
            action_counter=action_counter_id16)

        counters.append(acl_counter_id16)
        action_counters.append(action_counter_id16)
        acl_entries.append(acl_ingress_entry_id16)
        acl_rules.append("RULE_16")

        # "ACL_RULE|DATAINGRESS|RULE_17": {
        #     "type": "hash",
        #     "value": {
        #         "L4_SRC_PORT": "4721",
        #         "PACKET_ACTION": "DROP",
        #         "PRIORITY": "9983"
        #     }
        # },
        src_l4_port = sai_thrift_acl_field_data_t(
            enable=True,
            data=sai_thrift_acl_field_data_data_t(u16=4721),
            mask=sai_thrift_acl_field_data_mask_t(u16=32767))

        acl_ingress_entry_id17 = sai_thrift_create_acl_entry(
            self.client,
            table_id=acl_ingress_ipv4_table_id,
            priority=9983,
            action_packet_action=packet_action,
            field_l4_src_port=src_l4_port)

        # create ACL counter
        acl_counter_id17 = sai_thrift_create_acl_counter(
            self.client, table_id=acl_ingress_ipv4_table_id)

        # attach ACL counter to ACL entry
        action_counter_id17 = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=acl_counter_id17),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, acl_ingress_entry_id17,
            action_counter=action_counter_id17)

        counters.append(acl_counter_id17)
        action_counters.append(action_counter_id17)
        acl_entries.append(acl_ingress_entry_id17)
        acl_rules.append("RULE_17")

        # "ACL_RULE|DATAINGRESS|RULE_18": {
        #     "type": "hash",
        #     "value": {
        #         "IP_PROTOCOL": "127",
        #         "PACKET_ACTION": "DROP",
        #         "PRIORITY": "9982"
        #     }
        # },
        ip_protocol = sai_thrift_acl_field_data_t(
            enable=True,
            data=sai_thrift_acl_field_data_data_t(u8=127),
            mask=sai_thrift_acl_field_data_mask_t(u8=127))

        acl_ingress_entry_id18 = sai_thrift_create_acl_entry(
            self.client,
            table_id=acl_ingress_ipv4_table_id,
            priority=9982,
            action_packet_action=packet_action,
            field_ip_protocol=ip_protocol)

        # create ACL counter
        acl_counter_id18 = sai_thrift_create_acl_counter(
            self.client, table_id=acl_ingress_ipv4_table_id)

        # attach ACL counter to ACL entry
        action_counter_id18 = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=acl_counter_id18),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, acl_ingress_entry_id18,
            action_counter=action_counter_id18)

        counters.append(acl_counter_id18)
        action_counters.append(action_counter_id18)
        acl_entries.append(acl_ingress_entry_id18)
        acl_rules.append("RULE_18")

        # "ACL_RULE|DATAINGRESS|RULE_19": {
        #     "type": "hash",
        #     "value": {
        #         "PACKET_ACTION": "DROP",
        #         "PRIORITY": "9981",
        #         "TCP_FLAGS": "0x24/0x24"
        #     }
        # },
        tcp_flags = sai_thrift_acl_field_data_t(
            enable=True,
            mask=sai_thrift_acl_field_data_mask_t(u8=127),
            data=sai_thrift_acl_field_data_data_t(u8=36))

        acl_ingress_entry_id19 = sai_thrift_create_acl_entry(
            self.client,
            table_id=acl_ingress_ipv4_table_id,
            priority=9981,
            action_packet_action=packet_action,
            field_tcp_flags=tcp_flags)

        # create ACL counter
        acl_counter_id19 = sai_thrift_create_acl_counter(
            self.client, table_id=acl_ingress_ipv4_table_id)

        # attach ACL counter to ACL entry
        action_counter_id19 = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=acl_counter_id19),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, acl_ingress_entry_id19,
            action_counter=action_counter_id19)

        counters.append(acl_counter_id19)
        action_counters.append(action_counter_id19)
        acl_entries.append(acl_ingress_entry_id19)
        acl_rules.append("RULE_19")

        # "ACL_RULE|DATAINGRESS|RULE_2": {
        #     "type": "hash",
        #     "value": {
        #         "DST_IP": "192.168.0.16/32",
        #         "PACKET_ACTION": "FORWARD",
        #         "PRIORITY": "9998"
        #     }
        # },
        packet_action = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                s32=SAI_PACKET_ACTION_FORWARD))

        dst_ip_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(ip4="192.168.0.16"),
            mask=sai_thrift_acl_field_data_mask_t(ip4="255.255.255.255"))

        acl_ingress_entry_id2 = sai_thrift_create_acl_entry(
            self.client,
            table_id=acl_ingress_ipv4_table_id,
            priority=9998,
            action_packet_action=packet_action,
            field_dst_ip=dst_ip_t)

        # create ACL counter
        acl_counter_id2 = sai_thrift_create_acl_counter(
            self.client, table_id=acl_ingress_ipv4_table_id)

        # attach ACL counter to ACL entry
        action_counter_id2 = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=acl_counter_id2),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, acl_ingress_entry_id2,
            action_counter=action_counter_id2)

        counters.append(acl_counter_id2)
        action_counters.append(action_counter_id2)
        acl_entries.append(acl_ingress_entry_id2)
        acl_rules.append("RULE_2")

        # "ACL_RULE|DATAINGRESS|RULE_20": {
        #     "type": "hash",
        #     "value": {
        #         "PACKET_ACTION": "FORWARD",
        #         "PRIORITY": "9980",
        #         "SRC_IP": "20.0.0.7/32"
        #     }
        # },
        src_ip_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(ip4="20.0.0.7"),
            mask=sai_thrift_acl_field_data_mask_t(ip4="255.255.255.255"))

        acl_ingress_entry_id20 = sai_thrift_create_acl_entry(
            self.client,
            table_id=acl_ingress_ipv4_table_id,
            priority=9980,
            action_packet_action=packet_action,
            field_src_ip=src_ip_t)

        # create ACL counter
        acl_counter_id20 = sai_thrift_create_acl_counter(
            self.client, table_id=acl_ingress_ipv4_table_id)

        # attach ACL counter to ACL entry
        action_counter_id20 = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=acl_counter_id20),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, acl_ingress_entry_id20,
            action_counter=action_counter_id20)

        counters.append(acl_counter_id20)
        action_counters.append(action_counter_id20)
        acl_entries.append(acl_ingress_entry_id20)
        acl_rules.append("RULE_20")

        # "ACL_RULE|DATAINGRESS|RULE_21": {
        #     "type": "hash",
        #     "value": {
        #         "PACKET_ACTION": "DROP",
        #         "PRIORITY": "9979",
        #         "SRC_IP": "20.0.0.7/32"
        #     }
        # },
        packet_action = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                s32=SAI_PACKET_ACTION_DROP))

        acl_ingress_entry_id21 = sai_thrift_create_acl_entry(
            self.client,
            table_id=acl_ingress_ipv4_table_id,
            priority=9979,
            action_packet_action=packet_action,
            field_src_ip=src_ip_t)

        # create ACL counter
        acl_counter_id21 = sai_thrift_create_acl_counter(
            self.client, table_id=acl_ingress_ipv4_table_id)

        # attach ACL counter to ACL entry
        action_counter_id21 = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=acl_counter_id21),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, acl_ingress_entry_id21,
            action_counter=action_counter_id21)

        counters.append(acl_counter_id21)
        action_counters.append(action_counter_id21)
        acl_entries.append(acl_ingress_entry_id21)
        acl_rules.append("RULE_21")

        # "ACL_RULE|DATAINGRESS|RULE_22": {
        #     "type": "hash",
        #     "value": {
        #         "L4_DST_PORT": "4731",
        #         "PACKET_ACTION": "DROP",
        #         "PRIORITY": "9978"
        #     }
        # },
        dst_l4_port = sai_thrift_acl_field_data_t(
            enable=True,
            data=sai_thrift_acl_field_data_data_t(u16=4731),
            mask=sai_thrift_acl_field_data_mask_t(u16=32767))

        acl_ingress_entry_id22 = sai_thrift_create_acl_entry(
            self.client,
            table_id=acl_ingress_ipv4_table_id,
            priority=9978,
            action_packet_action=packet_action,
            field_l4_dst_port=dst_l4_port)

        # create ACL counter
        acl_counter_id22 = sai_thrift_create_acl_counter(
            self.client, table_id=acl_ingress_ipv4_table_id)

        # attach ACL counter to ACL entry
        action_counter_id22 = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=acl_counter_id22),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, acl_ingress_entry_id22,
            action_counter=action_counter_id22)

        counters.append(acl_counter_id22)
        action_counters.append(action_counter_id22)
        acl_entries.append(acl_ingress_entry_id22)
        acl_rules.append("RULE_22")

        # "ACL_RULE|DATAINGRESS|RULE_23": {
        #     "type": "hash",
        #     "value": {
        #         "L4_SRC_PORT_RANGE": "4756-4771",
        #         "PACKET_ACTION": "DROP",
        #         "PRIORITY": "9977"
        #     }
        # },
        u32range = sai_thrift_u32_range_t(min=4756, max=4771)
        acl_range_id3 = sai_thrift_create_acl_range(
            self.client,
            type=SAI_ACL_RANGE_TYPE_L4_SRC_PORT_RANGE,
            limit=u32range)
        range_list = [acl_range_id3]
        print("ACL range created 0x%lx" % (acl_range_id3))

        range_list_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(
                objlist=sai_thrift_object_list_t(
                    count=len(range_list),
                    idlist=range_list)))

        acl_ingress_entry_id23 = sai_thrift_create_acl_entry(
            self.client,
            table_id=acl_ingress_ipv4_table_id,
            priority=9977,
            action_packet_action=packet_action,
            field_acl_range_type=range_list_t)

        # create ACL counter
        acl_counter_id23 = sai_thrift_create_acl_counter(
            self.client, table_id=acl_ingress_ipv4_table_id)

        # attach ACL counter to ACL entry
        action_counter_id23 = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=acl_counter_id23),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, acl_ingress_entry_id23,
            action_counter=action_counter_id23)

        counters.append(acl_counter_id23)
        action_counters.append(action_counter_id23)
        acl_entries.append(acl_ingress_entry_id23)
        acl_rules.append("RULE_23")

        # "ACL_RULE|DATAINGRESS|RULE_24": {
        #     "type": "hash",
        #     "value": {
        #         "L4_DST_PORT_RANGE": "4740-4787",
        #         "PACKET_ACTION": "DROP",
        #         "PRIORITY": "9976"
        #     }
        # },
        u32range = sai_thrift_u32_range_t(min=4740, max=4787)
        acl_range_id4 = sai_thrift_create_acl_range(
            self.client,
            type=SAI_ACL_RANGE_TYPE_L4_SRC_PORT_RANGE,
            limit=u32range)
        range_list = [acl_range_id4]
        print("ACL range created 0x%lx" % (acl_range_id4))

        range_list_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(
                objlist=sai_thrift_object_list_t(
                    count=len(range_list),
                    idlist=range_list)))

        acl_ingress_entry_id24 = sai_thrift_create_acl_entry(
            self.client,
            table_id=acl_ingress_ipv4_table_id,
            priority=9976,
            action_packet_action=packet_action,
            field_acl_range_type=range_list_t)

        # create ACL counter
        acl_counter_id24 = sai_thrift_create_acl_counter(
            self.client, table_id=acl_ingress_ipv4_table_id)

        # attach ACL counter to ACL entry
        action_counter_id24 = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=acl_counter_id24),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, acl_ingress_entry_id24,
            action_counter=action_counter_id24)

        counters.append(acl_counter_id24)
        action_counters.append(action_counter_id24)
        acl_entries.append(acl_ingress_entry_id24)
        acl_rules.append("RULE_24")

        # "ACL_RULE|DATAINGRESS|RULE_25": {
        #     "type": "hash",
        #     "value": {
        #         "IP_PROTOCOL": "1",
        #         "PACKET_ACTION": "DROP",
        #         "PRIORITY": "9975",
        #         "SRC_IP": "20.0.0.8/32"
        #     }
        # },
        src_ip_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(ip4="20.0.0.8"),
            mask=sai_thrift_acl_field_data_mask_t(ip4="255.255.255.255"))

        ip_protocol = sai_thrift_acl_field_data_t(
            enable=True,
            data=sai_thrift_acl_field_data_data_t(u8=1),
            mask=sai_thrift_acl_field_data_mask_t(u8=127))

        acl_ingress_entry_id25 = sai_thrift_create_acl_entry(
            self.client,
            table_id=acl_ingress_ipv4_table_id,
            priority=9975,
            action_packet_action=packet_action,
            field_src_ip=src_ip_t,
            field_ip_protocol=ip_protocol)

        # create ACL counter
        acl_counter_id25 = sai_thrift_create_acl_counter(
            self.client, table_id=acl_ingress_ipv4_table_id)

        # attach ACL counter to ACL entry
        action_counter_id25 = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=acl_counter_id25),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, acl_ingress_entry_id25,
            action_counter=action_counter_id25)

        counters.append(acl_counter_id25)
        action_counters.append(action_counter_id25)
        acl_entries.append(acl_ingress_entry_id25)
        acl_rules.append("RULE_25")

        # "ACL_RULE|DATAINGRESS|RULE_26": {
        #     "type": "hash",
        #     "value": {
        #         "IP_PROTOCOL": "17",
        #         "PACKET_ACTION": "DROP",
        #         "PRIORITY": "9974",
        #         "SRC_IP": "20.0.0.8/32"
        #     }
        # },
        src_ip_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(ip4="20.0.0.8"),
            mask=sai_thrift_acl_field_data_mask_t(ip4="255.255.255.255"))

        ip_protocol = sai_thrift_acl_field_data_t(
            enable=True,
            data=sai_thrift_acl_field_data_data_t(u8=17),
            mask=sai_thrift_acl_field_data_mask_t(u8=127))

        acl_ingress_entry_id26 = sai_thrift_create_acl_entry(
            self.client,
            table_id=acl_ingress_ipv4_table_id,
            priority=9974,
            action_packet_action=packet_action,
            field_src_ip=src_ip_t,
            field_ip_protocol=ip_protocol)

        # create ACL counter
        acl_counter_id26 = sai_thrift_create_acl_counter(
            self.client, table_id=acl_ingress_ipv4_table_id)

        # attach ACL counter to ACL entry
        action_counter_id26 = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=acl_counter_id26),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, acl_ingress_entry_id26,
            action_counter=action_counter_id26)

        counters.append(acl_counter_id26)
        action_counters.append(action_counter_id26)
        acl_entries.append(acl_ingress_entry_id26)
        acl_rules.append("RULE_26")

        # "ACL_RULE|DATAINGRESS|RULE_27": {
        #     "type": "hash",
        #     "value": {
        #         "L4_SRC_PORT": "179",
        #         "PACKET_ACTION": "FORWARD",
        #         "PRIORITY": "9973"
        #     }
        # },
        packet_action = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                s32=SAI_PACKET_ACTION_FORWARD))

        src_l4_port = sai_thrift_acl_field_data_t(
            enable=True,
            data=sai_thrift_acl_field_data_data_t(u16=179),
            mask=sai_thrift_acl_field_data_mask_t(u16=32767))

        acl_ingress_entry_id27 = sai_thrift_create_acl_entry(
            self.client,
            table_id=acl_ingress_ipv4_table_id,
            priority=9973,
            action_packet_action=packet_action,
            field_l4_src_port=src_l4_port)

        # create ACL counter
        acl_counter_id27 = sai_thrift_create_acl_counter(
            self.client, table_id=acl_ingress_ipv4_table_id)

        # attach ACL counter to ACL entry
        action_counter_id27 = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=acl_counter_id27),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, acl_ingress_entry_id27,
            action_counter=action_counter_id27)

        counters.append(acl_counter_id27)
        action_counters.append(action_counter_id27)
        acl_entries.append(acl_ingress_entry_id27)
        acl_rules.append("RULE_27")

        # "ACL_RULE|DATAINGRESS|RULE_28": {
        #     "type": "hash",
        #     "value": {
        #         "L4_DST_PORT": "179",
        #         "PACKET_ACTION": "FORWARD",
        #         "PRIORITY": "9972"
        #     }
        # },
        dst_l4_port = sai_thrift_acl_field_data_t(
            enable=True,
            data=sai_thrift_acl_field_data_data_t(u16=179),
            mask=sai_thrift_acl_field_data_mask_t(u16=32767))

        acl_ingress_entry_id28 = sai_thrift_create_acl_entry(
            self.client,
            table_id=acl_ingress_ipv4_table_id,
            priority=9972,
            action_packet_action=packet_action,
            field_l4_dst_port=dst_l4_port)

        # create ACL counter
        acl_counter_id28 = sai_thrift_create_acl_counter(
            self.client, table_id=acl_ingress_ipv4_table_id)

        # attach ACL counter to ACL entry
        action_counter_id28 = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=acl_counter_id28),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, acl_ingress_entry_id28,
            action_counter=action_counter_id28)

        counters.append(acl_counter_id28)
        action_counters.append(action_counter_id28)
        acl_entries.append(acl_ingress_entry_id28)
        acl_rules.append("RULE_28")

        # "ACL_RULE|DATAINGRESS|RULE_3": {
        #     "type": "hash",
        #     "value": {
        #         "DST_IP": "172.16.2.0/32",
        #         "PACKET_ACTION": "FORWARD",
        #         "PRIORITY": "9997"
        #     }
        # },
        dst_ip_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(ip4="172.16.2.0"),
            mask=sai_thrift_acl_field_data_mask_t(ip4="255.255.255.255"))

        acl_ingress_entry_id3 = sai_thrift_create_acl_entry(
            self.client,
            table_id=acl_ingress_ipv4_table_id,
            priority=9997,
            action_packet_action=packet_action,
            field_dst_ip=dst_ip_t)

        # create ACL counter
        acl_counter_id3 = sai_thrift_create_acl_counter(
            self.client, table_id=acl_ingress_ipv4_table_id)

        # attach ACL counter to ACL entry
        action_counter_id3 = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=acl_counter_id3),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, acl_ingress_entry_id3,
            action_counter=action_counter_id3)

        counters.append(acl_counter_id3)
        action_counters.append(action_counter_id3)
        acl_entries.append(acl_ingress_entry_id3)
        acl_rules.append("RULE_3")

        # "ACL_RULE|DATAINGRESS|RULE_4": {
        #     "type": "hash",
        #     "value": {
        #         "L4_SRC_PORT": "4621",
        #         "PACKET_ACTION": "FORWARD",
        #         "PRIORITY": "9996"
        #     }
        # },
        src_l4_port = sai_thrift_acl_field_data_t(
            enable=True,
            data=sai_thrift_acl_field_data_data_t(u16=4621),
            mask=sai_thrift_acl_field_data_mask_t(u16=32767))

        acl_ingress_entry_id4 = sai_thrift_create_acl_entry(
            self.client,
            table_id=acl_ingress_ipv4_table_id,
            priority=9996,
            action_packet_action=packet_action,
            field_l4_src_port=src_l4_port)

        # create ACL counter
        acl_counter_id4 = sai_thrift_create_acl_counter(
            self.client, table_id=acl_ingress_ipv4_table_id)

        # attach ACL counter to ACL entry
        action_counter_id4 = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=acl_counter_id4),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, acl_ingress_entry_id4,
            action_counter=action_counter_id4)

        counters.append(acl_counter_id4)
        action_counters.append(action_counter_id4)
        acl_entries.append(acl_ingress_entry_id4)
        acl_rules.append("RULE_4")

        # "ACL_RULE|DATAINGRESS|RULE_5": {
        #     "type": "hash",
        #     "value": {
        #         "IP_PROTOCOL": "126",
        #         "PACKET_ACTION": "FORWARD",
        #         "PRIORITY": "9995"
        #     }
        # },
        ip_protocol = sai_thrift_acl_field_data_t(
            enable=True,
            data=sai_thrift_acl_field_data_data_t(u8=126),
            mask=sai_thrift_acl_field_data_mask_t(u8=127))

        acl_ingress_entry_id5 = sai_thrift_create_acl_entry(
            self.client,
            table_id=acl_ingress_ipv4_table_id,
            priority=9995,
            action_packet_action=packet_action,
            field_ip_protocol=ip_protocol)

        # create ACL counter
        acl_counter_id5 = sai_thrift_create_acl_counter(
            self.client, table_id=acl_ingress_ipv4_table_id)

        # attach ACL counter to ACL entry
        action_counter_id5 = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=acl_counter_id5),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, acl_ingress_entry_id5,
            action_counter=action_counter_id5)

        counters.append(acl_counter_id5)
        action_counters.append(action_counter_id5)
        acl_entries.append(acl_ingress_entry_id5)
        acl_rules.append("RULE_5")

        # "ACL_RULE|DATAINGRESS|RULE_6": {
        #     "type": "hash",
        #     "value": {
        #         "PACKET_ACTION": "FORWARD",
        #         "PRIORITY": "9994",
        #         "TCP_FLAGS": "0x1b/0x1b"
        #     }
        # },
        tcp_flags = sai_thrift_acl_field_data_t(
            enable=True,
            mask=sai_thrift_acl_field_data_mask_t(u8=127),
            data=sai_thrift_acl_field_data_data_t(u8=27))

        acl_ingress_entry_id6 = sai_thrift_create_acl_entry(
            self.client,
            table_id=acl_ingress_ipv4_table_id,
            priority=9994,
            action_packet_action=packet_action,
            field_tcp_flags=tcp_flags)

        # create ACL counter
        acl_counter_id6 = sai_thrift_create_acl_counter(
            self.client, table_id=acl_ingress_ipv4_table_id)

        # attach ACL counter to ACL entry
        action_counter_id6 = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=acl_counter_id6),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, acl_ingress_entry_id6,
            action_counter=action_counter_id6)

        counters.append(acl_counter_id6)
        action_counters.append(action_counter_id6)
        acl_entries.append(acl_ingress_entry_id6)
        acl_rules.append("RULE_6")

        # "ACL_RULE|DATAINGRESS|RULE_7": {
        #     "type": "hash",
        #     "value": {
        #         "PACKET_ACTION": "DROP",
        #         "PRIORITY": "9993",
        #         "SRC_IP": "20.0.0.3/32"
        #     }
        # },
        packet_action = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                s32=SAI_PACKET_ACTION_DROP))

        src_ip_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(ip4="20.0.0.3"),
            mask=sai_thrift_acl_field_data_mask_t(ip4="255.255.255.255"))

        acl_ingress_entry_id7 = sai_thrift_create_acl_entry(
            self.client,
            table_id=acl_ingress_ipv4_table_id,
            priority=9993,
            action_packet_action=packet_action,
            field_src_ip=src_ip_t)

        # create ACL counter
        acl_counter_id7 = sai_thrift_create_acl_counter(
            self.client, table_id=acl_ingress_ipv4_table_id)

        # attach ACL counter to ACL entry
        action_counter_id7 = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=acl_counter_id7),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, acl_ingress_entry_id7,
            action_counter=action_counter_id7)

        counters.append(acl_counter_id7)
        action_counters.append(action_counter_id7)
        acl_entries.append(acl_ingress_entry_id7)
        acl_rules.append("RULE_7")

        # "ACL_RULE|DATAINGRESS|RULE_8": {
        #     "type": "hash",
        #     "value": {
        #         "PACKET_ACTION": "FORWARD",
        #         "PRIORITY": "9992",
        #         "SRC_IP": "20.0.0.3/32"
        #     }
        # },
        packet_action = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                s32=SAI_PACKET_ACTION_FORWARD))

        acl_ingress_entry_id8 = sai_thrift_create_acl_entry(
            self.client,
            table_id=acl_ingress_ipv4_table_id,
            priority=9992,
            action_packet_action=packet_action,
            field_src_ip=src_ip_t)

        # create ACL counter
        acl_counter_id8 = sai_thrift_create_acl_counter(
            self.client, table_id=acl_ingress_ipv4_table_id)

        # attach ACL counter to ACL entry
        action_counter_id8 = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=acl_counter_id8),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, acl_ingress_entry_id8,
            action_counter=action_counter_id8)

        counters.append(acl_counter_id8)
        action_counters.append(action_counter_id8)
        acl_entries.append(acl_ingress_entry_id8)
        acl_rules.append("RULE_8")

        # "ACL_RULE|DATAINGRESS|RULE_9": {
        #     "type": "hash",
        #     "value": {
        #         "L4_DST_PORT": "4631",
        #         "PACKET_ACTION": "FORWARD",
        #         "PRIORITY": "9991"
        #     }
        # },
        dst_l4_port = sai_thrift_acl_field_data_t(
            enable=True,
            data=sai_thrift_acl_field_data_data_t(u16=4631),
            mask=sai_thrift_acl_field_data_mask_t(u16=32767))

        acl_ingress_entry_id9 = sai_thrift_create_acl_entry(
            self.client,
            table_id=acl_ingress_ipv4_table_id,
            priority=9991,
            action_packet_action=packet_action,
            field_l4_dst_port=dst_l4_port)

        # create ACL counter
        acl_counter_id9 = sai_thrift_create_acl_counter(
            self.client, table_id=acl_ingress_ipv4_table_id)

        # attach ACL counter to ACL entry
        action_counter_id9 = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=acl_counter_id9),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, acl_ingress_entry_id9,
            action_counter=action_counter_id9)

        counters.append(acl_counter_id9)
        action_counters.append(action_counter_id9)
        acl_entries.append(acl_ingress_entry_id9)
        acl_rules.append("RULE_9")

        try:
            pkt = simple_tcp_packet(
                eth_dst=ROUTER_MAC,
                eth_src=self.dmac,
                ip_src="20.0.0.1",
                ip_dst=ipv4_addr,
                tcp_sport=0x4321,
                tcp_dport=0x51,
                ip_ttl=64)
            send_packet(self, self.dev_port11, pkt)
            verify_no_other_packets(self, timeout=2)

            print("Entries counters after sending the first packet:")
            for i, acl_counter in enumerate(counters):
                packets = sai_thrift_get_acl_counter_attribute(
                    self.client, acl_counter, packets=True)
                print(acl_rules[i], " : ", packets['packets'])

            pkt = simple_tcp_packet(
                eth_dst=ROUTER_MAC,
                eth_src=self.dmac,
                ip_src="20.0.0.2",
                ip_dst=ipv4_addr,
                tcp_sport=0x4321,
                tcp_dport=0x51,
                ip_ttl=64)
            exp_pkt = simple_tcp_packet(
                eth_dst=self.dmac,
                eth_src=ROUTER_MAC,
                ip_src="20.0.0.2",
                ip_dst=ipv4_addr,
                tcp_sport=0x4321,
                tcp_dport=0x51,
                ip_ttl=63)
            send_packet(self, self.dev_port11, pkt)
            verify_packets(self, exp_pkt, [self.dev_port10])

            print("Entries counters after sending the second packet:")
            for i, acl_counter in enumerate(counters):
                packets = sai_thrift_get_acl_counter_attribute(
                    self.client, acl_counter, packets=True)
                print(acl_rules[i], " : ", packets['packets'])

        finally:
            print("Unbind ACL groups from ports object id:")
            for i, ports in enumerate(ports_list):
                print(i, ports)
                sai_thrift_set_port_attribute(
                    self.client, ports,
                    ingress_acl=int(SAI_NULL_OBJECT_ID))

            for acl_group_member in acl_ingress_group_members_list:
                sai_thrift_remove_acl_table_group_member(self.client,
                                                         acl_group_member)

            for acl_group in acl_ingress_groups_list:
                sai_thrift_remove_acl_table_group(self.client, acl_group)

            for i, acl_action_counter in enumerate(action_counters):
                acl_action_counter = sai_thrift_acl_action_data_t(
                    parameter=sai_thrift_acl_action_parameter_t(
                        oid=0),
                    enable=True)
                sai_thrift_set_acl_entry_attribute(
                    self.client, acl_entries[i],
                    action_counter=acl_action_counter)

            for acl_counter in counters:
                sai_thrift_set_acl_counter_attribute(
                    self.client, acl_counter, packets=None)
                packets = sai_thrift_get_acl_counter_attribute(
                    self.client, acl_counter, packets=True)
                self.assertEqual(packets['packets'], 0)
                sai_thrift_remove_acl_counter(self.client, acl_counter)

            # cleanup ACL
            sai_thrift_remove_acl_entry(self.client, acl_ingress_entry_id28)
            sai_thrift_remove_acl_entry(self.client, acl_ingress_entry_id27)
            sai_thrift_remove_acl_entry(self.client, acl_ingress_entry_id26)
            sai_thrift_remove_acl_entry(self.client, acl_ingress_entry_id25)
            sai_thrift_remove_acl_entry(self.client, acl_ingress_entry_id24)
            sai_thrift_remove_acl_range(self.client, acl_range_id4)
            sai_thrift_remove_acl_entry(self.client, acl_ingress_entry_id23)
            sai_thrift_remove_acl_range(self.client, acl_range_id3)
            sai_thrift_remove_acl_entry(self.client, acl_ingress_entry_id22)
            sai_thrift_remove_acl_entry(self.client, acl_ingress_entry_id21)
            sai_thrift_remove_acl_entry(self.client, acl_ingress_entry_id20)
            sai_thrift_remove_acl_entry(self.client, acl_ingress_entry_id19)
            sai_thrift_remove_acl_entry(self.client, acl_ingress_entry_id18)
            sai_thrift_remove_acl_entry(self.client, acl_ingress_entry_id17)
            sai_thrift_remove_acl_entry(self.client, acl_ingress_entry_id16)
            sai_thrift_remove_acl_entry(self.client, acl_ingress_entry_id15)
            sai_thrift_remove_acl_entry(self.client, acl_ingress_entry_id14)
            sai_thrift_remove_acl_entry(self.client, acl_ingress_entry_id13)
            sai_thrift_remove_acl_entry(self.client, acl_ingress_entry_id12)
            sai_thrift_remove_acl_entry(self.client, acl_ingress_entry_id11)
            sai_thrift_remove_acl_range(self.client, acl_range_id2)
            sai_thrift_remove_acl_entry(self.client, acl_ingress_entry_id10)
            sai_thrift_remove_acl_range(self.client, acl_range_id1)
            sai_thrift_remove_acl_entry(self.client, acl_ingress_entry_id9)
            sai_thrift_remove_acl_entry(self.client, acl_ingress_entry_id8)
            sai_thrift_remove_acl_entry(self.client, acl_ingress_entry_id7)
            sai_thrift_remove_acl_entry(self.client, acl_ingress_entry_id6)
            sai_thrift_remove_acl_entry(self.client, acl_ingress_entry_id5)
            sai_thrift_remove_acl_entry(self.client, acl_ingress_entry_id4)
            sai_thrift_remove_acl_entry(self.client, acl_ingress_entry_id3)
            sai_thrift_remove_acl_entry(self.client, acl_ingress_entry_id2)
            sai_thrift_remove_acl_entry(self.client, acl_ingress_entry_id1)
            sai_thrift_remove_acl_entry(self.client,
                                        acl_ingress_entry_id_default)

            sai_thrift_remove_acl_table(self.client,
                                        acl_ingress_ipv4_table_id)

    def tearDown(self):
        sai_thrift_remove_route_entry(self.client, self.route_entry)
        sai_thrift_remove_next_hop(self.client, self.nhop)
        sai_thrift_remove_neighbor_entry(self.client, self.nbr_entry)
        super(SonicACLTest, self).tearDown()


@disabled
@group('acl2-mirror-inout')
class AclTableMirrorInOutTest(SaiHelper):
    '''
    Ingress/Egress ACL Mirror In/out action combinations
    '''
    acl_range_type = sai_thrift_s32_list_t(count=0, int32list=[])

    def setUp(self):
        super(AclTableMirrorInOutTest, self).setUp()

        self.dmac = '00:11:22:33:44:55'
        self.src_mac = '00:22:22:22:22:22'
        self.ip_addr1 = '10.0.0.1'
        self.ip_addr2 = '10.10.10.2'

        self.port24_rif = sai_thrift_create_router_interface(
            self.client,
            type=SAI_ROUTER_INTERFACE_TYPE_PORT,
            virtual_router_id=self.default_vrf,
            port_id=self.port24)

        self.port25_rif = sai_thrift_create_router_interface(
            self.client,
            type=SAI_ROUTER_INTERFACE_TYPE_PORT,
            virtual_router_id=self.default_vrf,
            port_id=self.port25)

        self.nhop1 = sai_thrift_create_next_hop(
            self.client,
            ip=sai_ipaddress(self.ip_addr2),
            router_interface_id=self.port25_rif,
            type=SAI_NEXT_HOP_TYPE_IP)
        self.neighbor_entry1 = sai_thrift_neighbor_entry_t(
            rif_id=self.port25_rif, ip_address=sai_ipaddress(self.ip_addr2))
        sai_thrift_create_neighbor_entry(
            self.client, self.neighbor_entry1, dst_mac_address=self.dmac)

        self.route_entry1 = sai_thrift_route_entry_t(
            vr_id=self.default_vrf,
            destination=sai_ipprefix(
                '1234:5678:9abc:def0:4422:1133:5577:99aa/128'))
        sai_thrift_create_route_entry(
            self.client, self.route_entry1, next_hop_id=self.nhop1)

        self.vlan_oid = sai_thrift_create_vlan(self.client, 100)
        mac_action = SAI_PACKET_ACTION_FORWARD

        self.port26_bp = sai_thrift_create_bridge_port(
            self.client,
            bridge_id=self.default_1q_bridge,
            port_id=self.port26,
            type=SAI_BRIDGE_PORT_TYPE_PORT,
            admin_state=True)

        self.vlan_member1 = sai_thrift_create_vlan_member(
            self.client,
            vlan_id=self.vlan_oid,
            bridge_port_id=self.port26_bp,
            vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_TAGGED)

        self.port27_bp = sai_thrift_create_bridge_port(
            self.client,
            bridge_id=self.default_1q_bridge,
            port_id=self.port27,
            type=SAI_BRIDGE_PORT_TYPE_PORT,
            admin_state=True)

        self.vlan_member2 = sai_thrift_create_vlan_member(
            self.client,
            vlan_id=self.vlan_oid,
            bridge_port_id=self.port27_bp,
            vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_TAGGED)

        self.fdb_entry1 = sai_thrift_fdb_entry_t(
            switch_id=self.switch_id,
            mac_address=self.src_mac,
            bv_id=self.vlan_oid)
        sai_thrift_create_fdb_entry(
            self.client,
            self.fdb_entry1,
            type=SAI_FDB_ENTRY_TYPE_STATIC,
            bridge_port_id=self.port26_bp,
            packet_action=mac_action)

        self.fdb_entry2 = sai_thrift_fdb_entry_t(
            switch_id=self.switch_id,
            mac_address=self.dmac,
            bv_id=self.vlan_oid)
        sai_thrift_create_fdb_entry(
            self.client,
            self.fdb_entry2,
            type=SAI_FDB_ENTRY_TYPE_STATIC,
            bridge_port_id=self.port27_bp,
            packet_action=mac_action)

    def runTest(self):
        self.testIngressIPAclMirrorIn()
        self.testIngressIPAclMirrorOut()
        self.testEgressIPAclMirrorIn()
        self.testEgressIPAclMirrorOut()

    def tearDown(self):
        sai_thrift_remove_fdb_entry(self.client, self.fdb_entry1)
        sai_thrift_remove_fdb_entry(self.client, self.fdb_entry2)
        sai_thrift_remove_vlan_member(self.client, self.vlan_member1)
        sai_thrift_remove_vlan_member(self.client, self.vlan_member2)
        sai_thrift_remove_bridge_port(self.client, self.port26_bp)
        sai_thrift_remove_bridge_port(self.client, self.port27_bp)
        sai_thrift_remove_vlan(self.client, self.vlan_oid)

        sai_thrift_remove_route_entry(self.client, self.route_entry1)
        sai_thrift_remove_next_hop(self.client, self.nhop1)
        sai_thrift_remove_neighbor_entry(self.client, self.neighbor_entry1)
        sai_thrift_remove_router_interface(self.client, self.port25_rif)
        sai_thrift_remove_router_interface(self.client, self.port24_rif)
        super(AclTableMirrorInOutTest, self).tearDown()

    def testIngressIPAclMirrorIn(self):
        '''
        Test Ingress IP mirror Acl Mirror In functionality
        '''
        print("testIngressIPAclMirrorIn")
        pkt1 = simple_tcpv6_packet(
            eth_dst=ROUTER_MAC,
            ipv6_dst='1234:5678:9abc:def0:4422:1133:5577:99aa',
            ipv6_hlim=64)
        e_pkt1 = simple_tcpv6_packet(
            eth_dst=self.dmac,
            eth_src=ROUTER_MAC,
            ipv6_dst='1234:5678:9abc:def0:4422:1133:5577:99aa',
            ipv6_hlim=63)

        pkt2 = simple_tcpv6_packet(
            eth_dst=self.dmac,
            eth_src=self.src_mac,
            dl_vlan_enable=True,
            vlan_vid=100,
            ipv6_dst='1234:5678:9abc:def0:4422:1133:5577:99aa',
            ipv6_src='2000::1',
            ipv6_hlim=64)
        e_pkt2 = simple_tcpv6_packet(
            eth_dst=self.dmac,
            eth_src=self.src_mac,
            dl_vlan_enable=True,
            vlan_vid=100,
            ipv6_dst='1234:5678:9abc:def0:4422:1133:5577:99aa',
            ipv6_src='2000::1',
            ipv6_hlim=64)

        try:
            #  verify packet forwarding without ACL
            send_packet(self, self.dev_port24, pkt1)
            verify_packet(self, e_pkt1, self.dev_port25)

            send_packet(self, self.dev_port26, pkt2)
            verify_packet(self, e_pkt2, self.dev_port27)

            mirror_session = sai_thrift_create_mirror_session(
                self.client,
                monitor_port=self.port28,
                type=SAI_MIRROR_SESSION_TYPE_LOCAL)

            #  ACL table
            table_stage = SAI_ACL_STAGE_INGRESS
            table_bind_points = [SAI_ACL_BIND_POINT_TYPE_PORT,
                                 SAI_ACL_BIND_POINT_TYPE_LAG]
            table_bind_point_type_list = sai_thrift_s32_list_t(
                count=len(table_bind_points), int32list=table_bind_points)
            actions = [SAI_ACL_ACTION_TYPE_MIRROR_INGRESS]
            action_type_list = sai_thrift_s32_list_t(
                count=len(actions), int32list=actions)
            acl_table = sai_thrift_create_acl_table(
                self.client,
                acl_stage=table_stage,
                acl_bind_point_type_list=table_bind_point_type_list,
                acl_action_type_list=action_type_list,
                field_src_ipv6=True,
                field_dst_ipv6=True,
                field_ip_protocol=True,
                field_ipv6_next_header=True,
                field_dscp=True,
                field_l4_src_port=True,
                field_l4_dst_port=True,
                field_ttl=True,
                field_tcp_flags=True,
                field_ether_type=True,
                field_acl_range_type=self.acl_range_type,
                field_icmpv6_code=True,
                field_icmpv6_type=True,
                field_acl_ip_frag=True,
                field_acl_ip_type=True,
                field_outer_vlan_id=True)

            #  ACL table entry
            dst_ip = '1234:5678:9abc:def0:4422:1133:5577:99aa'
            dst_ip_mask = 'FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF'
            dst_ip_t = sai_thrift_acl_field_data_t(
                data=sai_thrift_acl_field_data_data_t(ip6=dst_ip),
                mask=sai_thrift_acl_field_data_mask_t(ip6=dst_ip_mask))

            mirror_session_list = sai_thrift_object_list_t(
                count=1, idlist=[mirror_session])
            mirror_action = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    objlist=mirror_session_list))
            acl_entry = sai_thrift_create_acl_entry(
                self.client,
                table_id=acl_table,
                priority=10,
                field_dst_ipv6=dst_ip_t,
                action_mirror_ingress=mirror_action)

            #  ACL counter
            acl_counter_ingress = sai_thrift_create_acl_counter(
                self.client, table_id=acl_table)

            #  attach ACL counter to ACL entry
            action_counter_ingress = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=acl_counter_ingress),
                enable=True)
            sai_thrift_set_acl_entry_attribute(
                self.client, acl_entry,
                action_counter=action_counter_ingress)

            #  attach ACL table to ingress port 24, 26
            sai_thrift_set_port_attribute(self.client, self.port24,
                                          ingress_acl=acl_table)
            sai_thrift_set_port_attribute(self.client, self.port26,
                                          ingress_acl=acl_table)

            #  verify route-pkt egress out of port 25
            #  verify if the mirror packet [out of port 28] is incoming pkt
            send_packet(self, self.dev_port24, pkt1)
            verify_each_packet_on_each_port(self, [e_pkt1, pkt1],
                                            [self.dev_port25, self.dev_port28])

            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter_ingress, packets=True)
            self.assertEqual(packets['packets'], 1)

            #  verify switch-pkt egress out of port 27
            #  verify if the mirror packet [out of port 28] is incoming pkt
            send_packet(self, self.dev_port26, pkt2)
            verify_each_packet_on_each_port(self, [e_pkt2, pkt2],
                                            [self.dev_port27, self.dev_port28])

            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter_ingress, packets=True)
            self.assertEqual(packets['packets'], 2)

        finally:
            #  cleanup ACL
            action_counter_ingress = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=0),
                enable=True)
            sai_thrift_set_acl_entry_attribute(
                self.client, acl_entry,
                action_counter=action_counter_ingress)
            sai_thrift_set_acl_counter_attribute(
                self.client, acl_counter_ingress, packets=None)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter_ingress, packets=True)
            self.assertEqual(packets['packets'], 0)
            sai_thrift_remove_acl_counter(self.client, acl_counter_ingress)
            sai_thrift_set_port_attribute(self.client, self.port24,
                                          ingress_acl=0)
            sai_thrift_set_port_attribute(self.client, self.port26,
                                          ingress_acl=0)
            sai_thrift_remove_acl_entry(self.client, acl_entry)
            sai_thrift_remove_acl_table(self.client, acl_table)
            sai_thrift_remove_mirror_session(self.client, mirror_session)

    def testIngressIPAclMirrorOut(self):
        '''
        Test Ingress IP mirror Acl Mirror Out functionality
        '''
        print("testIngressIPAclMirrorOut")
        pkt1 = simple_tcpv6_packet(
            eth_dst=ROUTER_MAC,
            ipv6_dst='1234:5678:9abc:def0:4422:1133:5577:99aa',
            ipv6_hlim=64)
        e_pkt1 = simple_tcpv6_packet(
            eth_dst=self.dmac,
            eth_src=ROUTER_MAC,
            ipv6_dst='1234:5678:9abc:def0:4422:1133:5577:99aa',
            ipv6_hlim=63)

        pkt2 = simple_tcpv6_packet(
            eth_dst=self.dmac,
            eth_src=self.src_mac,
            dl_vlan_enable=True,
            vlan_vid=100,
            ipv6_dst='1234:5678:9abc:def0:4422:1133:5577:99aa',
            ipv6_src='2000::1',
            ipv6_hlim=64)
        e_pkt2 = simple_tcpv6_packet(
            eth_dst=self.dmac,
            eth_src=self.src_mac,
            dl_vlan_enable=True,
            vlan_vid=100,
            ipv6_dst='1234:5678:9abc:def0:4422:1133:5577:99aa',
            ipv6_src='2000::1',
            ipv6_hlim=64)

        try:
            #  verify packet forwarding without ACL
            send_packet(self, self.dev_port24, pkt1)
            verify_packet(self, e_pkt1, self.dev_port25)

            send_packet(self, self.dev_port26, pkt2)
            verify_packet(self, e_pkt2, self.dev_port27)

            mirror_session = sai_thrift_create_mirror_session(
                self.client,
                monitor_port=self.port28,
                type=SAI_MIRROR_SESSION_TYPE_LOCAL)

            #  ACL table
            table_stage = SAI_ACL_STAGE_INGRESS
            table_bind_points = [SAI_ACL_BIND_POINT_TYPE_PORT,
                                 SAI_ACL_BIND_POINT_TYPE_LAG]
            table_bind_point_type_list = sai_thrift_s32_list_t(
                count=len(table_bind_points), int32list=table_bind_points)
            actions = [SAI_ACL_ACTION_TYPE_MIRROR_EGRESS]
            action_type_list = sai_thrift_s32_list_t(
                count=len(actions), int32list=actions)
            acl_table = sai_thrift_create_acl_table(
                self.client,
                acl_stage=table_stage,
                acl_bind_point_type_list=table_bind_point_type_list,
                acl_action_type_list=action_type_list,
                field_src_ipv6=True,
                field_dst_ipv6=True,
                field_ip_protocol=True,
                field_ipv6_next_header=True,
                field_dscp=True,
                field_l4_src_port=True,
                field_l4_dst_port=True,
                field_ttl=True,
                field_tcp_flags=True,
                field_ether_type=True,
                field_acl_range_type=self.acl_range_type,
                field_icmpv6_code=True,
                field_icmpv6_type=True,
                field_acl_ip_frag=True,
                field_acl_ip_type=True,
                field_outer_vlan_id=True)

            #  ACL table entry
            dst_ip = '1234:5678:9abc:def0:4422:1133:5577:99aa'
            dst_ip_mask = 'FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF'
            dst_ip_t = sai_thrift_acl_field_data_t(
                data=sai_thrift_acl_field_data_data_t(ip6=dst_ip),
                mask=sai_thrift_acl_field_data_mask_t(ip6=dst_ip_mask))

            mirror_session_list = sai_thrift_object_list_t(
                count=1, idlist=[mirror_session])
            mirror_action = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    objlist=mirror_session_list))
            acl_entry = sai_thrift_create_acl_entry(
                self.client,
                table_id=acl_table,
                priority=10,
                field_dst_ipv6=dst_ip_t,
                action_mirror_egress=mirror_action)

            #  ACL counter
            acl_counter_ingress = sai_thrift_create_acl_counter(
                self.client, table_id=acl_table)

            #  attach ACL counter to ACL entry
            action_counter_ingress = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=acl_counter_ingress),
                enable=True)
            sai_thrift_set_acl_entry_attribute(
                self.client, acl_entry,
                action_counter=action_counter_ingress)

            #  attach ACL table to ingress port 24, 26
            sai_thrift_set_port_attribute(self.client, self.port24,
                                          ingress_acl=acl_table)
            sai_thrift_set_port_attribute(self.client, self.port26,
                                          ingress_acl=acl_table)

            #  verify route-pkt egress out of port 25
            #  verify if the mirror packet [out of port 28] is route-pkt
            send_packet(self, self.dev_port24, pkt1)
            verify_each_packet_on_each_port(self, [e_pkt1, e_pkt1],
                                            [self.dev_port25, self.dev_port28])

            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter_ingress, packets=True)
            self.assertEqual(packets['packets'], 1)

            #  verify switch-pkt egress out of port 27
            #  verify if the mirror packet [out of port 28] is switch-pkt
            send_packet(self, self.dev_port26, pkt2)
            verify_each_packet_on_each_port(self, [e_pkt2, e_pkt2],
                                            [self.dev_port27, self.dev_port28])

            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter_ingress, packets=True)
            self.assertEqual(packets['packets'], 2)

        finally:
            #  cleanup ACL
            action_counter_ingress = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=0),
                enable=True)
            sai_thrift_set_acl_entry_attribute(
                self.client, acl_entry,
                action_counter=action_counter_ingress)
            sai_thrift_set_acl_counter_attribute(
                self.client, acl_counter_ingress, packets=None)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter_ingress, packets=True)
            self.assertEqual(packets['packets'], 0)
            sai_thrift_remove_acl_counter(self.client, acl_counter_ingress)
            sai_thrift_set_port_attribute(self.client, self.port24,
                                          ingress_acl=0)
            sai_thrift_set_port_attribute(self.client, self.port26,
                                          ingress_acl=0)
            sai_thrift_remove_acl_entry(self.client, acl_entry)
            sai_thrift_remove_acl_table(self.client, acl_table)
            sai_thrift_remove_mirror_session(self.client, mirror_session)

    def testEgressIPAclMirrorIn(self):
        '''
        Test Egress IP mirror Acl Mirror In functionality
        '''
        print("testEgressIPAclMirrorIn")
        pkt1 = simple_tcpv6_packet(
            eth_dst=ROUTER_MAC,
            ipv6_dst='1234:5678:9abc:def0:4422:1133:5577:99aa',
            ipv6_hlim=64)
        e_pkt1 = simple_tcpv6_packet(
            eth_dst=self.dmac,
            eth_src=ROUTER_MAC,
            ipv6_dst='1234:5678:9abc:def0:4422:1133:5577:99aa',
            ipv6_hlim=63)

        pkt2 = simple_tcpv6_packet(
            eth_dst=self.dmac,
            eth_src=self.src_mac,
            dl_vlan_enable=True,
            vlan_vid=100,
            ipv6_dst='1234:5678:9abc:def0:4422:1133:5577:99aa',
            ipv6_src='2000::1',
            ipv6_hlim=64)
        e_pkt2 = simple_tcpv6_packet(
            eth_dst=self.dmac,
            eth_src=self.src_mac,
            dl_vlan_enable=True,
            vlan_vid=100,
            ipv6_dst='1234:5678:9abc:def0:4422:1133:5577:99aa',
            ipv6_src='2000::1',
            ipv6_hlim=64)

        try:
            #  verify packet forwarding without ACL
            send_packet(self, self.dev_port24, pkt1)
            verify_packet(self, e_pkt1, self.dev_port25)

            send_packet(self, self.dev_port26, pkt2)
            verify_packet(self, e_pkt2, self.dev_port27)

            mirror_session = sai_thrift_create_mirror_session(
                self.client,
                monitor_port=self.port28,
                type=SAI_MIRROR_SESSION_TYPE_LOCAL)

            #  ACL table
            table_stage = SAI_ACL_STAGE_EGRESS
            table_bind_points = [SAI_ACL_BIND_POINT_TYPE_PORT,
                                 SAI_ACL_BIND_POINT_TYPE_LAG]
            table_bind_point_type_list = sai_thrift_s32_list_t(
                count=len(table_bind_points), int32list=table_bind_points)
            actions = [SAI_ACL_ACTION_TYPE_MIRROR_INGRESS]
            action_type_list = sai_thrift_s32_list_t(
                count=len(actions), int32list=actions)
            acl_table = sai_thrift_create_acl_table(
                self.client,
                acl_stage=table_stage,
                acl_bind_point_type_list=table_bind_point_type_list,
                acl_action_type_list=action_type_list,
                field_src_ipv6=True,
                field_dst_ipv6=True,
                field_ip_protocol=True,
                field_ipv6_next_header=True,
                field_dscp=True,
                field_l4_src_port=True,
                field_l4_dst_port=True,
                field_ttl=True,
                field_tcp_flags=True,
                field_ether_type=True,
                field_acl_range_type=self.acl_range_type,
                field_icmpv6_code=True,
                field_icmpv6_type=True,
                field_acl_ip_frag=True,
                field_acl_ip_type=True,
                field_outer_vlan_id=True)

            #  ACL table entry
            dst_ip = '1234:5678:9abc:def0:4422:1133:5577:99aa'
            dst_ip_mask = 'FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF'
            dst_ip_t = sai_thrift_acl_field_data_t(
                data=sai_thrift_acl_field_data_data_t(ip6=dst_ip),
                mask=sai_thrift_acl_field_data_mask_t(ip6=dst_ip_mask))

            mirror_session_list = sai_thrift_object_list_t(
                count=1, idlist=[mirror_session])
            mirror_action = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    objlist=mirror_session_list))
            acl_entry = sai_thrift_create_acl_entry(
                self.client,
                table_id=acl_table,
                priority=10,
                field_dst_ipv6=dst_ip_t,
                action_mirror_ingress=mirror_action)

            #  ACL counter
            acl_counter_egress = sai_thrift_create_acl_counter(
                self.client, table_id=acl_table)

            #  attach ACL counter to ACL entry
            action_counter_egress = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=acl_counter_egress),
                enable=True)
            sai_thrift_set_acl_entry_attribute(
                self.client, acl_entry,
                action_counter=action_counter_egress)

            #  attach ACL table to egress port 25, 27
            sai_thrift_set_port_attribute(self.client, self.port25,
                                          egress_acl=acl_table)
            sai_thrift_set_port_attribute(self.client, self.port27,
                                          egress_acl=acl_table)

            #  verify route-pkt egress out of port 25
            #  verify if the mirror packet [out of port 28] is incoming pkt
            send_packet(self, self.dev_port24, pkt1)
            verify_each_packet_on_each_port(self, [e_pkt1, pkt1],
                                            [self.dev_port25, self.dev_port28])

            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter_egress, packets=True)
            self.assertEqual(packets['packets'], 1)

            #  verify switch-pkt egress out of port 27
            #  verify if the mirror packet [out of port 28] is incoming pkt
            send_packet(self, self.dev_port26, pkt2)
            verify_each_packet_on_each_port(self, [e_pkt2, pkt2],
                                            [self.dev_port27, self.dev_port28])

            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter_egress, packets=True)
            self.assertEqual(packets['packets'], 2)

        finally:
            #  cleanup ACL
            action_counter_egress = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=0),
                enable=True)
            sai_thrift_set_acl_entry_attribute(
                self.client, acl_entry,
                action_counter=action_counter_egress)
            sai_thrift_set_acl_counter_attribute(
                self.client, acl_counter_egress, packets=None)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter_egress, packets=True)
            self.assertEqual(packets['packets'], 0)
            sai_thrift_remove_acl_counter(self.client, acl_counter_egress)
            sai_thrift_set_port_attribute(self.client, self.port25,
                                          egress_acl=0)
            sai_thrift_set_port_attribute(self.client, self.port27,
                                          egress_acl=0)
            sai_thrift_remove_acl_entry(self.client, acl_entry)
            sai_thrift_remove_acl_table(self.client, acl_table)
            sai_thrift_remove_mirror_session(self.client, mirror_session)

    def testEgressIPAclMirrorOut(self):
        '''
        Test Egress IP mirror Acl Mirror Out functionality
        '''
        print("testEgressIPAclMirrorOut")
        pkt1 = simple_tcpv6_packet(
            eth_dst=ROUTER_MAC,
            ipv6_dst='1234:5678:9abc:def0:4422:1133:5577:99aa',
            ipv6_hlim=64)
        e_pkt1 = simple_tcpv6_packet(
            eth_dst=self.dmac,
            eth_src=ROUTER_MAC,
            ipv6_dst='1234:5678:9abc:def0:4422:1133:5577:99aa',
            ipv6_hlim=63)

        pkt2 = simple_tcpv6_packet(
            eth_dst=self.dmac,
            eth_src=self.src_mac,
            dl_vlan_enable=True,
            vlan_vid=100,
            ipv6_dst='1234:5678:9abc:def0:4422:1133:5577:99aa',
            ipv6_src='2000::1',
            ipv6_hlim=64)
        e_pkt2 = simple_tcpv6_packet(
            eth_dst=self.dmac,
            eth_src=self.src_mac,
            dl_vlan_enable=True,
            vlan_vid=100,
            ipv6_dst='1234:5678:9abc:def0:4422:1133:5577:99aa',
            ipv6_src='2000::1',
            ipv6_hlim=64)

        try:
            #  verify packet forwarding without ACL
            send_packet(self, self.dev_port24, pkt1)
            verify_packet(self, e_pkt1, self.dev_port25)

            send_packet(self, self.dev_port26, pkt2)
            verify_packet(self, e_pkt2, self.dev_port27)

            mirror_session = sai_thrift_create_mirror_session(
                self.client,
                monitor_port=self.port28,
                type=SAI_MIRROR_SESSION_TYPE_LOCAL)

            #  ACL table
            table_stage = SAI_ACL_STAGE_EGRESS
            table_bind_points = [SAI_ACL_BIND_POINT_TYPE_PORT,
                                 SAI_ACL_BIND_POINT_TYPE_LAG]
            table_bind_point_type_list = sai_thrift_s32_list_t(
                count=len(table_bind_points), int32list=table_bind_points)
            actions = [SAI_ACL_ACTION_TYPE_MIRROR_EGRESS]
            action_type_list = sai_thrift_s32_list_t(
                count=len(actions), int32list=actions)
            acl_table = sai_thrift_create_acl_table(
                self.client,
                acl_stage=table_stage,
                acl_bind_point_type_list=table_bind_point_type_list,
                acl_action_type_list=action_type_list,
                field_src_ipv6=True,
                field_dst_ipv6=True,
                field_ip_protocol=True,
                field_ipv6_next_header=True,
                field_dscp=True,
                field_l4_src_port=True,
                field_l4_dst_port=True,
                field_ttl=True,
                field_tcp_flags=True,
                field_ether_type=True,
                field_acl_range_type=self.acl_range_type,
                field_icmpv6_code=True,
                field_icmpv6_type=True,
                field_acl_ip_frag=True,
                field_acl_ip_type=True,
                field_outer_vlan_id=True)

            #  ACL table entry
            dst_ip = '1234:5678:9abc:def0:4422:1133:5577:99aa'
            dst_ip_mask = 'FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF'
            dst_ip_t = sai_thrift_acl_field_data_t(
                data=sai_thrift_acl_field_data_data_t(ip6=dst_ip),
                mask=sai_thrift_acl_field_data_mask_t(ip6=dst_ip_mask))

            mirror_session_list = sai_thrift_object_list_t(
                count=1, idlist=[mirror_session])
            mirror_action = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    objlist=mirror_session_list))
            acl_entry = sai_thrift_create_acl_entry(
                self.client,
                table_id=acl_table,
                priority=10,
                field_dst_ipv6=dst_ip_t,
                action_mirror_egress=mirror_action)

            #  ACL counter
            acl_counter_egress = sai_thrift_create_acl_counter(
                self.client, table_id=acl_table)

            #  attach ACL counter to ACL entry
            action_counter_egress = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=acl_counter_egress),
                enable=True)
            sai_thrift_set_acl_entry_attribute(
                self.client, acl_entry,
                action_counter=action_counter_egress)

            #  attach ACL table to egress port 25, 27
            sai_thrift_set_port_attribute(self.client, self.port25,
                                          egress_acl=acl_table)
            sai_thrift_set_port_attribute(self.client, self.port27,
                                          egress_acl=acl_table)

            #  verify route-pkt egress out of port 25
            #  verify if the mirror packet [out of port 28] is route-pkt
            send_packet(self, self.dev_port24, pkt1)
            verify_each_packet_on_each_port(self, [e_pkt1, e_pkt1],
                                            [self.dev_port25, self.dev_port28])

            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter_egress, packets=True)
            self.assertEqual(packets['packets'], 1)

            #  verify switch-pkt egress out of port 27
            #  verify if the mirror packet [out of port 28] is switch-pkt
            send_packet(self, self.dev_port26, pkt2)
            verify_each_packet_on_each_port(self, [e_pkt2, e_pkt2],
                                            [self.dev_port27, self.dev_port28])

            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter_egress, packets=True)
            self.assertEqual(packets['packets'], 2)

        finally:
            #  cleanup ACL
            action_counter_egress = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=0),
                enable=True)
            sai_thrift_set_acl_entry_attribute(
                self.client, acl_entry,
                action_counter=action_counter_egress)
            sai_thrift_set_acl_counter_attribute(
                self.client, acl_counter_egress, packets=None)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter_egress, packets=True)
            self.assertEqual(packets['packets'], 0)
            sai_thrift_remove_acl_counter(self.client, acl_counter_egress)
            sai_thrift_set_port_attribute(self.client, self.port25,
                                          egress_acl=0)
            sai_thrift_set_port_attribute(self.client, self.port27,
                                          egress_acl=0)
            sai_thrift_remove_acl_entry(self.client, acl_entry)
            sai_thrift_remove_acl_table(self.client, acl_table)
            sai_thrift_remove_mirror_session(self.client, mirror_session)


@disabled
@group('acl2-redirect')
class AclRedirectPortAndLagTest(SaiHelper):
    """
    Verify ACL redirection for ports and lags test cases
    """
    def setUp(self):
        super(AclRedirectPortAndLagTest, self).setUp()
        self.acl_grp_members = []
        self.acl_grps = []
        self.acl_rules = []
        self.acl_tables = []
        self.vlan_members = []
        self.vlan_ports = []
        self.bridge_ports = []
        self.fdbs = []
        self.lags = []
        self.lag_members = []
        self.action_counters = []
        self.counters = []

        self.mac = '00:11:11:11:11:11'
        mac_action = SAI_PACKET_ACTION_FORWARD

        # Add port 24, 25, 26 to Vlan100
        vlan_id = 100
        self.vlan_oid = sai_thrift_create_vlan(self.client, vlan_id)

        port24_bp = sai_thrift_create_bridge_port(
            self.client,
            bridge_id=self.default_1q_bridge,
            port_id=self.port24,
            type=SAI_BRIDGE_PORT_TYPE_PORT,
            admin_state=True)

        self.bridge_ports.append(port24_bp)

        vlan_member1 = sai_thrift_create_vlan_member(
            self.client,
            vlan_id=self.vlan_oid,
            bridge_port_id=port24_bp,
            vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_UNTAGGED)
        self.vlan_members.append(vlan_member1)
        self.vlan_ports.append(self.port24)

        port25_bp = sai_thrift_create_bridge_port(
            self.client,
            bridge_id=self.default_1q_bridge,
            port_id=self.port25,
            type=SAI_BRIDGE_PORT_TYPE_PORT,
            admin_state=True)

        self.bridge_ports.append(port25_bp)

        vlan_member2 = sai_thrift_create_vlan_member(
            self.client,
            vlan_id=self.vlan_oid,
            bridge_port_id=port25_bp,
            vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_UNTAGGED)
        self.vlan_members.append(vlan_member2)
        self.vlan_ports.append(self.port25)

        port26_bp = sai_thrift_create_bridge_port(
            self.client,
            bridge_id=self.default_1q_bridge,
            port_id=self.port26,
            type=SAI_BRIDGE_PORT_TYPE_PORT,
            admin_state=True)

        self.bridge_ports.append(port26_bp)

        vlan_member3 = sai_thrift_create_vlan_member(
            self.client,
            vlan_id=self.vlan_oid,
            bridge_port_id=port26_bp,
            vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_UNTAGGED)
        self.vlan_members.append(vlan_member3)
        self.vlan_ports.append(self.port26)

        sai_thrift_set_port_attribute(
            self.client, self.port24, port_vlan_id=vlan_id)
        sai_thrift_set_port_attribute(
            self.client, self.port25, port_vlan_id=vlan_id)
        sai_thrift_set_port_attribute(
            self.client, self.port26, port_vlan_id=vlan_id)

        # Create Lag (port 27, 28) and add it to Vlan100
        self.lag_id = sai_thrift_create_lag(self.client)
        self.lags.append(self.lag_id)
        lag1_bp = sai_thrift_create_bridge_port(
            self.client,
            bridge_id=self.default_1q_bridge,
            port_id=self.lag_id,
            type=SAI_BRIDGE_PORT_TYPE_PORT,
            admin_state=True)
        self.bridge_ports.append(lag1_bp)
        lag_member_id1 = sai_thrift_create_lag_member(
            self.client, lag_id=self.lag_id, port_id=self.port27)
        self.lag_members.append(lag_member_id1)

        lag_member_id2 = sai_thrift_create_lag_member(
            self.client, lag_id=self.lag_id, port_id=self.port28)
        self.lag_members.append(lag_member_id2)

        vlan_member4 = sai_thrift_create_vlan_member(
            self.client,
            vlan_id=self.vlan_oid,
            bridge_port_id=lag1_bp,
            vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_UNTAGGED)

        self.vlan_members.append(vlan_member4)
        self.vlan_ports.append(self.port27)
        self.vlan_ports.append(self.port28)

        fdb_entry = sai_thrift_fdb_entry_t(
            switch_id=self.switch_id,
            mac_address=self.mac,
            bv_id=self.vlan_oid)
        sai_thrift_create_fdb_entry(
            self.client,
            fdb_entry,
            type=SAI_FDB_ENTRY_TYPE_STATIC,
            bridge_port_id=port24_bp,
            packet_action=mac_action)
        self.fdbs.append(fdb_entry)

    def runTest(self):
        print("Testing AclRedirectPortAndLagTest")
        print('-------------------------------------------------------------')

        eth_pkt1 = simple_eth_packet(pktlen=100,
                                     eth_dst=self.mac,
                                     eth_src='00:06:07:08:09:0a',
                                     eth_type=0x8137)
        eth_pkt2 = simple_eth_packet(pktlen=100,
                                     eth_dst=self.mac,
                                     eth_src='00:06:07:08:09:0a',
                                     eth_type=0x8136)
        eth_pkt3 = simple_eth_packet(pktlen=100,
                                     eth_dst=self.mac,
                                     eth_src='00:06:07:08:09:0a',
                                     eth_type=0x8135)
        eth_pkt4 = simple_eth_packet(pktlen=100,
                                     eth_dst=self.mac,
                                     eth_src='00:06:07:08:09:0a',
                                     eth_type=0x8134)
        neg_test_pkt = simple_eth_packet(pktlen=100,
                                         eth_dst=self.mac,
                                         eth_src='00:06:07:08:09:0a',
                                         eth_type=0x1111)

        print('#### NO ACL Applied ####')
        # send the test packet(s)
        print("Sending Test packet EthType:0x%lx port 25 -> port 24" % (
            eth_pkt1[Ether].type))
        send_packet(self, self.dev_port25, eth_pkt1)
        verify_packets(self, eth_pkt1, [self.dev_port24])

        print("Sending Test packet EthType:0x%lx port 25 -> port 24" % (
            eth_pkt2[Ether].type))
        send_packet(self, self.dev_port25, eth_pkt2)
        verify_packets(self, eth_pkt2, [self.dev_port24])

        print("Sending Test packet EthType:0x%lx port 25 -> port 24" % (
            eth_pkt3[Ether].type))
        send_packet(self, self.dev_port25, eth_pkt3)
        verify_packets(self, eth_pkt3, [self.dev_port24])

        print("Sending Test packet EthType:0x%lx port 25 -> port 24" % (
            eth_pkt4[Ether].type))
        send_packet(self, self.dev_port25, eth_pkt4)
        verify_packets(self, eth_pkt4, [self.dev_port24])

        print("Sending Test(negative test) packet EthType:0x%lx port 25 -> "
              "port 24" % (neg_test_pkt[Ether].type))
        send_packet(self, self.dev_port25, neg_test_pkt)
        verify_packets(self, neg_test_pkt, [self.dev_port24])
        print("Sending Test(negative test) packet EthType:0x%lx port 25 -> "
              "port 24" % (neg_test_pkt[Ether].type))

        # setup ACL to redirect based on Ether type
        entry_priority = 1
        acl_action = SAI_ACL_ENTRY_ATTR_ACTION_REDIRECT

        # setup ACL table group
        group_bind_point_list = [SAI_ACL_BIND_POINT_TYPE_PORT]
        group_type = SAI_ACL_TABLE_GROUP_TYPE_PARALLEL
        group_stage_ingress = SAI_ACL_STAGE_INGRESS
        group_member_priority = 100

        # setup ACL table
        table_stage_ingress = SAI_ACL_STAGE_INGRESS
        table_bind_point_list = [SAI_ACL_BIND_POINT_TYPE_PORT]

        group_bind_point_type_list = sai_thrift_s32_list_t(
            count=len(group_bind_point_list),
            int32list=group_bind_point_list)

        table_bind_point_type_list = sai_thrift_s32_list_t(
            count=len(table_bind_point_list),
            int32list=table_bind_point_list)

        # create ACL table group
        acl_table_group_ingress = sai_thrift_create_acl_table_group(
            self.client,
            acl_stage=group_stage_ingress,
            acl_bind_point_type_list=group_bind_point_type_list,
            type=group_type)
        self.acl_grps.append(acl_table_group_ingress)

        # create ACL tables
        print("Create ACL tables")
        acl_table_id_ingress = sai_thrift_create_acl_table(
            self.client,
            acl_stage=table_stage_ingress,
            acl_bind_point_type_list=table_bind_point_type_list)

        self.acl_tables.append(acl_table_id_ingress)
        self.assertTrue((acl_table_id_ingress != 0),
                        "ACL table create failed")
        print("IPV4 ACL Table created 0x%lx" % (acl_table_id_ingress))

        # create ACL table group members
        acl_group_member_id_ingress = \
            sai_thrift_create_acl_table_group_member(
                self.client,
                acl_table_group_id=acl_table_group_ingress,
                acl_table_id=acl_table_id_ingress,
                priority=group_member_priority)

        self.assertTrue(acl_group_member_id_ingress != 0,
                        "ACL group member add failed for ACL table 0x%lx, "
                        "acl group 0x%lx" % (
                            acl_table_id_ingress, acl_table_group_ingress))
        self.acl_grp_members.append(acl_group_member_id_ingress)

        eth_type = 0x8137 - 0x10000

        ether_type = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(u16=eth_type),
            mask=sai_thrift_acl_field_data_mask_t(u16=32767))

        redirect_action = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                s32=acl_action,
                oid=self.port26))

        # create ACL entries
        print("Create ACL entries")
        acl_ip_entry_id_ingress1 = sai_thrift_create_acl_entry(
            self.client,
            table_id=acl_table_id_ingress,
            priority=entry_priority,
            field_ether_type=ether_type,
            action_redirect=redirect_action)

        # create ACL counter
        acl_counter_ingress1 = sai_thrift_create_acl_counter(
            self.client, table_id=acl_table_id_ingress)

        # attach ACL counter to ACL entry
        action_counter_ingress1 = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=acl_counter_ingress1),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, acl_ip_entry_id_ingress1,
            action_counter=action_counter_ingress1)

        self.counters.append(acl_counter_ingress1)
        self.action_counters.append(action_counter_ingress1)

        self.acl_rules.append(acl_ip_entry_id_ingress1)
        self.assertTrue((acl_ip_entry_id_ingress1 != 0), 'ACL entry Match: '
                        'EthType-0x%lx Action: Redirect-0x%lx, create '
                        'failed for ACL table 0x%lx' % (
                            eth_type, self.port26, acl_table_id_ingress))
        print("ACL entry Match: EthType-0x%lx Action: Redirect-0x%lx "
              "created 0x%lx" % (eth_pkt1[Ether].type, self.port26,
                                 acl_ip_entry_id_ingress1))

        entry_priority += 1
        eth_type = 0x8136 - 0x10000

        ether_type = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(u16=eth_type),
            mask=sai_thrift_acl_field_data_mask_t(u16=32767))

        redirect_action = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                s32=acl_action,
                oid=self.lag_id))

        acl_ip_entry_id_ingress2 = sai_thrift_create_acl_entry(
            self.client,
            table_id=acl_table_id_ingress,
            priority=entry_priority,
            field_ether_type=ether_type,
            action_redirect=redirect_action)

        # create ACL counter
        acl_counter_ingress2 = sai_thrift_create_acl_counter(
            self.client, table_id=acl_table_id_ingress)

        # attach ACL counter to ACL entry
        action_counter_ingress2 = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=acl_counter_ingress2),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, acl_ip_entry_id_ingress2,
            action_counter=action_counter_ingress2)

        self.counters.append(acl_counter_ingress2)
        self.action_counters.append(action_counter_ingress2)

        self.acl_rules.append(acl_ip_entry_id_ingress2)
        self.assertTrue((acl_ip_entry_id_ingress2 != 0), 'ACL entry Match: '
                        'EthType-0x%lx Action: Redirect-0x%lx, create '
                        'failed for ACL table 0x%lx' % (
                            eth_type, self.lag_id, acl_table_id_ingress))
        print("ACL entry Match: EthType-0x%lx Action: Redirect-0x%lx "
              "created 0x%lx" % (eth_pkt2[Ether].type, self.lag_id,
                                 acl_ip_entry_id_ingress2))

        # create ACL table group members
        acl_group_member_id_ingress = \
            sai_thrift_create_acl_table_group_member(
                self.client,
                acl_table_group_id=acl_table_group_ingress,
                acl_table_id=acl_table_id_ingress,
                priority=200)

        self.assertTrue(acl_group_member_id_ingress != 0,
                        "ACL group member add failed for ACL table 0x%lx, "
                        "ACL group 0x%lx" % (
                            acl_table_id_ingress, acl_table_group_ingress))
        self.acl_grp_members.append(acl_group_member_id_ingress)

        eth_type = 0x8135 - 0x10000

        ether_type = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(u16=eth_type),
            mask=sai_thrift_acl_field_data_mask_t(u16=32767))

        redirect_action = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                s32=acl_action,
                oid=self.port26))

        print("Create ACL entries")
        acl_ip_entry_id_ingress3 = sai_thrift_create_acl_entry(
            self.client,
            table_id=acl_table_id_ingress,
            priority=entry_priority,
            field_ether_type=ether_type,
            action_redirect=redirect_action)

        # create ACL counter
        acl_counter_ingress3 = sai_thrift_create_acl_counter(
            self.client, table_id=acl_table_id_ingress)

        # attach ACL counter to ACL entry
        action_counter_ingress3 = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=acl_counter_ingress3),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, acl_ip_entry_id_ingress3,
            action_counter=action_counter_ingress3)

        self.counters.append(acl_counter_ingress3)
        self.action_counters.append(action_counter_ingress3)

        self.acl_rules.append(acl_ip_entry_id_ingress3)
        self.assertTrue((acl_ip_entry_id_ingress3 != 0), 'ACL entry Match: '
                        'EthType-0x%lx Action: Redirect-0x%lx, create '
                        'failed for acl table 0x%lx' % (
                            eth_type, self.port26, acl_table_id_ingress))
        print("ACL entry Match: EthType-0x%lx Action: Redirect-0x%lx "
              "created 0x%lx" % (eth_pkt3[Ether].type, self.port26,
                                 acl_ip_entry_id_ingress3))

        eth_type = 0x8134 - 0x10000

        ether_type = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(u16=eth_type),
            mask=sai_thrift_acl_field_data_mask_t(u16=32767))

        redirect_action = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                s32=acl_action,
                oid=self.lag_id))

        print("Create ACL entries")
        acl_ip_entry_id_ingress4 = sai_thrift_create_acl_entry(
            self.client,
            table_id=acl_table_id_ingress,
            priority=entry_priority,
            field_ether_type=ether_type,
            action_redirect=redirect_action)

        # create ACL counter
        acl_counter_ingress4 = sai_thrift_create_acl_counter(
            self.client, table_id=acl_table_id_ingress)

        # attach ACL counter to ACL entry
        action_counter_ingress4 = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=acl_counter_ingress4),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, acl_ip_entry_id_ingress4,
            action_counter=action_counter_ingress4)

        self.counters.append(acl_counter_ingress4)
        self.action_counters.append(action_counter_ingress4)

        self.acl_rules.append(acl_ip_entry_id_ingress4)
        self.assertTrue((acl_ip_entry_id_ingress4 != 0), 'ACL entry Match: '
                        'EthType-0x%lx Action: Redirect-0x%lx, create '
                        'failed for ACL table 0x%lx' % (
                            eth_type, self.lag_id, acl_table_id_ingress))
        print("ACL entry Match: EthType-0x%lx Action: Redirect-0x%lx "
              "created 0x%lx" % (eth_pkt3[Ether].type, self.lag_id,
                                 acl_ip_entry_id_ingress4))

        print("Binding ACL grp 0x%lx to Port25" % (acl_table_group_ingress))
        # bind ACL GRP to Port25
        sai_thrift_set_port_attribute(
            self.client, self.port25, ingress_acl=acl_table_group_ingress)

        print("Sending Test packet EthType:0x%lx port 25 -> [ACL REDIRECT] "
              "-> port 26" % (eth_pkt1[Ether].type))
        # ensure packet is redirected!
        send_packet(self, self.dev_port25, eth_pkt1)
        verify_packets(self, eth_pkt1, [self.dev_port26])

        packets1 = sai_thrift_get_acl_counter_attribute(
            self.client, acl_counter_ingress1, packets=True)
        self.assertEqual(packets1['packets'], 1)
        packets2 = sai_thrift_get_acl_counter_attribute(
            self.client, acl_counter_ingress2, packets=True)
        self.assertEqual(packets2['packets'], 0)
        packets3 = sai_thrift_get_acl_counter_attribute(
            self.client, acl_counter_ingress3, packets=True)
        self.assertEqual(packets3['packets'], 0)
        packets4 = sai_thrift_get_acl_counter_attribute(
            self.client, acl_counter_ingress4, packets=True)
        self.assertEqual(packets4['packets'], 0)

        # ensure packet is redirected!
        print("Sending Test packet EthType:0x%lx port 25 -> [ACL REDIRECT] "
              "-> Lag1 (Port 26/Port 27)" % (eth_pkt2[Ether].type))
        send_packet(self, self.dev_port25, eth_pkt2)
        verify_packets_any(self, eth_pkt2, [self.dev_port27,
                                            self.dev_port28])

        packets1 = sai_thrift_get_acl_counter_attribute(
            self.client, acl_counter_ingress1, packets=True)
        self.assertEqual(packets1['packets'], 1)
        packets2 = sai_thrift_get_acl_counter_attribute(
            self.client, acl_counter_ingress2, packets=True)
        self.assertEqual(packets2['packets'], 1)
        packets3 = sai_thrift_get_acl_counter_attribute(
            self.client, acl_counter_ingress3, packets=True)
        self.assertEqual(packets3['packets'], 0)
        packets4 = sai_thrift_get_acl_counter_attribute(
            self.client, acl_counter_ingress4, packets=True)
        self.assertEqual(packets4['packets'], 0)

        # ensure packet is redirected!
        print("Sending Test packet EthType:0x%lx port 25 -> [ACL REDIRECT] "
              "-> port 26" % (eth_pkt3[Ether].type))
        send_packet(self, self.dev_port25, eth_pkt3)
        verify_packets(self, eth_pkt3, [self.dev_port26])

        packets1 = sai_thrift_get_acl_counter_attribute(
            self.client, acl_counter_ingress1, packets=True)
        self.assertEqual(packets1['packets'], 1)
        packets2 = sai_thrift_get_acl_counter_attribute(
            self.client, acl_counter_ingress2, packets=True)
        self.assertEqual(packets2['packets'], 1)
        packets3 = sai_thrift_get_acl_counter_attribute(
            self.client, acl_counter_ingress3, packets=True)
        self.assertEqual(packets3['packets'], 1)
        packets4 = sai_thrift_get_acl_counter_attribute(
            self.client, acl_counter_ingress4, packets=True)
        self.assertEqual(packets4['packets'], 0)

        # ensure packet is redirected!
        print("Sending Test packet EthType:0x%lx port 25 -> [ACL REDIRECT] "
              "-> Lag1 (Port 27/Port 28)" % (eth_pkt4[Ether].type))
        send_packet(self, self.dev_port25, eth_pkt4)
        verify_packets_any(self, eth_pkt4, [self.dev_port27,
                                            self.dev_port28])

        packets1 = sai_thrift_get_acl_counter_attribute(
            self.client, acl_counter_ingress1, packets=True)
        self.assertEqual(packets1['packets'], 1)
        packets2 = sai_thrift_get_acl_counter_attribute(
            self.client, acl_counter_ingress2, packets=True)
        self.assertEqual(packets2['packets'], 1)
        packets3 = sai_thrift_get_acl_counter_attribute(
            self.client, acl_counter_ingress3, packets=True)
        self.assertEqual(packets3['packets'], 1)
        packets4 = sai_thrift_get_acl_counter_attribute(
            self.client, acl_counter_ingress4, packets=True)
        self.assertEqual(packets4['packets'], 1)

        # ensure packet is not redirected!
        print("Sending Test(negative test) packet EthType:0x%lx port 25 -> "
              "port 24" % (neg_test_pkt[Ether].type))
        send_packet(self, self.dev_port25, neg_test_pkt)
        verify_packets(self, neg_test_pkt, [self.dev_port24])

        packets1 = sai_thrift_get_acl_counter_attribute(
            self.client, acl_counter_ingress1, packets=True)
        self.assertEqual(packets1['packets'], 1)
        packets2 = sai_thrift_get_acl_counter_attribute(
            self.client, acl_counter_ingress2, packets=True)
        self.assertEqual(packets2['packets'], 1)
        packets3 = sai_thrift_get_acl_counter_attribute(
            self.client, acl_counter_ingress3, packets=True)
        self.assertEqual(packets3['packets'], 1)
        packets4 = sai_thrift_get_acl_counter_attribute(
            self.client, acl_counter_ingress4, packets=True)
        self.assertEqual(packets4['packets'], 1)

    def tearDown(self):
        # Clean up ACL configuration
        sai_thrift_set_port_attribute(
            self.client, self.port25, ingress_acl=int(SAI_NULL_OBJECT_ID))
        for acl_grp_member in list(self.acl_grp_members):
            sai_thrift_remove_acl_table_group_member(self.client,
                                                     acl_grp_member)
            self.acl_grp_members.remove(acl_grp_member)
        for acl_grp in list(self.acl_grps):
            sai_thrift_remove_acl_table_group(self.client, acl_grp)
            self.acl_grps.remove(acl_grp)

        for i, acl_action_counter in enumerate(self.action_counters):
            acl_action_counter = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=0),
                enable=True)
            sai_thrift_set_acl_entry_attribute(
                self.client, self.acl_rules[i],
                action_counter=acl_action_counter)

        for acl_counter in self.counters:
            sai_thrift_set_acl_counter_attribute(
                self.client, acl_counter, packets=None)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter, packets=True)
            self.assertEqual(packets['packets'], 0)
            sai_thrift_remove_acl_counter(self.client, acl_counter)

        for acl_rule in list(self.acl_rules):
            sai_thrift_remove_acl_entry(self.client, acl_rule)
            self.acl_rules.remove(acl_rule)

        for acl_table in list(self.acl_tables):
            sai_thrift_remove_acl_table(self.client, acl_table)
            self.acl_tables.remove(acl_table)

        for fdb in list(self.fdbs):
            sai_thrift_remove_fdb_entry(self.client, fdb)
            self.fdbs.remove(fdb)

        # Clean up network configuration
        sai_thrift_set_port_attribute(
            self.client, self.port24, port_vlan_id=int(SAI_NULL_OBJECT_ID))
        sai_thrift_set_port_attribute(
            self.client, self.port25, port_vlan_id=int(SAI_NULL_OBJECT_ID))
        sai_thrift_set_port_attribute(
            self.client, self.port26, port_vlan_id=int(SAI_NULL_OBJECT_ID))

        for vlan_member in list(self.vlan_members):
            sai_thrift_remove_vlan_member(self.client, vlan_member)
            self.vlan_members.remove(vlan_member)
        sai_thrift_remove_vlan(self.client, self.vlan_oid)
        for lag_member in list(self.lag_members):
            sai_thrift_remove_lag_member(self.client, lag_member)
            self.lag_members.remove(lag_member)
        for port in list(self.bridge_ports):
            sai_thrift_remove_bridge_port(self.client, port)
            self.bridge_ports.remove(port)
        for lag in list(self.lags):
            sai_thrift_remove_lag(self.client, lag)
            self.lags.remove(lag)
        for vlan_port in list(self.vlan_ports):
            self.vlan_ports.remove(vlan_port)

        super(AclRedirectPortAndLagTest, self).tearDown()


@disabled
class IPv6NextHdrTest(SaiHelper):
    """
    Verify ACL blocking TCP traffic
    """
    def setUp(self):
        super(IPv6NextHdrTest, self).setUp()
        self.ip_addr1 = '1234:5678:9abc:def0:4422:1133:5577:99aa'
        self.ip_addr2 = '2000::1'
        self.mac1 = '00:11:22:33:44:55'
        self.mac2 = '00:22:22:22:22:22'
        mask = '/112'
        self.table_stage_ingress = SAI_ACL_STAGE_INGRESS
        self.table_stage_egress = SAI_ACL_STAGE_EGRESS

        self.neighbor_entry1 = sai_thrift_neighbor_entry_t(
            rif_id=self.port10_rif, ip_address=sai_ipaddress(self.ip_addr1))
        sai_thrift_create_neighbor_entry(
            self.client,
            self.neighbor_entry1,
            dst_mac_address=self.mac1)

        self.nhop1 = sai_thrift_create_next_hop(
            self.client,
            ip=sai_ipaddress(self.ip_addr1),
            router_interface_id=self.port10_rif,
            type=SAI_NEXT_HOP_TYPE_IP)

        self.route_entry1 = sai_thrift_route_entry_t(
            vr_id=self.default_vrf, destination=sai_ipprefix(
                self.ip_addr1 + mask))
        sai_thrift_create_route_entry(
            self.client,
            self.route_entry1,
            next_hop_id=self.nhop1)

        self.neighbor_entry2 = sai_thrift_neighbor_entry_t(
            rif_id=self.port11_rif, ip_address=sai_ipaddress(self.ip_addr2))
        sai_thrift_create_neighbor_entry(
            self.client,
            self.neighbor_entry2,
            dst_mac_address=self.mac2)

        self.nhop2 = sai_thrift_create_next_hop(
            self.client,
            ip=sai_ipaddress(self.ip_addr2),
            router_interface_id=self.port11_rif,
            type=SAI_NEXT_HOP_TYPE_IP)

        self.route_entry2 = sai_thrift_route_entry_t(
            vr_id=self.default_vrf, destination=sai_ipprefix(
                self.ip_addr2 + mask))
        sai_thrift_create_route_entry(
            self.client,
            self.route_entry2,
            next_hop_id=self.nhop2)

        self.tcpv6_1 = simple_tcpv6_packet(eth_dst=ROUTER_MAC,
                                           eth_src=self.mac2,
                                           ipv6_dst=self.ip_addr1,
                                           ipv6_src=self.ip_addr2,
                                           ipv6_hlim=64)
        self.exp_tcpv6_1 = simple_tcpv6_packet(eth_dst=self.mac1,
                                               eth_src=ROUTER_MAC,
                                               ipv6_dst=self.ip_addr1,
                                               ipv6_src=self.ip_addr2,
                                               ipv6_hlim=63)

        self.udpv6_1 = simple_udpv6_packet(eth_dst=ROUTER_MAC,
                                           eth_src=self.mac2,
                                           ipv6_dst=self.ip_addr1,
                                           ipv6_src=self.ip_addr2,
                                           ipv6_hlim=64)
        self.exp_udpv6_1 = simple_udpv6_packet(eth_dst=self.mac1,
                                               eth_src=ROUTER_MAC,
                                               ipv6_dst=self.ip_addr1,
                                               ipv6_src=self.ip_addr2,
                                               ipv6_hlim=63)

        self.tcpv6_2 = simple_tcpv6_packet(eth_dst=ROUTER_MAC,
                                           eth_src=self.mac1,
                                           ipv6_dst=self.ip_addr2,
                                           ipv6_src=self.ip_addr1,
                                           ipv6_hlim=64)
        self.exp_tcpv6_2 = simple_tcpv6_packet(eth_dst=self.mac2,
                                               eth_src=ROUTER_MAC,
                                               ipv6_dst=self.ip_addr2,
                                               ipv6_src=self.ip_addr1,
                                               ipv6_hlim=63)

        self.udpv6_2 = simple_udpv6_packet(eth_dst=ROUTER_MAC,
                                           eth_src=self.mac1,
                                           ipv6_dst=self.ip_addr2,
                                           ipv6_src=self.ip_addr1,
                                           ipv6_hlim=64)
        self.exp_udpv6_2 = simple_udpv6_packet(eth_dst=self.mac2,
                                               eth_src=ROUTER_MAC,
                                               ipv6_dst=self.ip_addr2,
                                               ipv6_src=self.ip_addr1,
                                               ipv6_hlim=63)

    def runTest(self):
        self.aclRoutingTest()
        self.aclIPv6NextHdrTest(self.table_stage_ingress)
        self.aclIPv6NextHdrTest(self.table_stage_egress)

    def tearDown(self):
        sai_thrift_remove_route_entry(self.client, self.route_entry1)
        sai_thrift_remove_next_hop(self.client, self.nhop1)
        sai_thrift_remove_neighbor_entry(self.client, self.neighbor_entry1)
        sai_thrift_remove_route_entry(self.client, self.route_entry2)
        sai_thrift_remove_next_hop(self.client, self.nhop2)
        sai_thrift_remove_neighbor_entry(self.client, self.neighbor_entry2)
        super(IPv6NextHdrTest, self).tearDown()

    def aclRoutingTest(self):
        """
        Verify routing without ACL
        """
        try:
            print('----------------------------------------------------------')
            print("Sending packet ptf_intf 2 -> ptf_intf 1 (", self.ip_addr2,
                  " ---> ", self.ip_addr1, ")")
            print('#### NO ACL Applied: sending TCP packets ####')
            print('#### Sending  ', ROUTER_MAC, ' | ', self.mac2, ' | ',
                  self.ip_addr2, ' | ', self.ip_addr1, ' | @ ptf_intf 2')
            send_packet(self, self.dev_port11, self.tcpv6_1)
            print('#### Expecting ', self.mac1, ' | ', ROUTER_MAC, ' | ',
                  self.ip_addr2, ' | ', self.ip_addr1, ' | @ ptf_intf 1')
            verify_packets(self, self.exp_tcpv6_1, [self.dev_port10])
            print('#### NO ACL Applied: sending UDP packets ####')
            send_packet(self, self.dev_port11, self.udpv6_1)
            verify_packets(self, self.exp_udpv6_1, [self.dev_port10])

            print('----------------------------------------------------------')
            print("Sending packet ptf_intf 2 -> ptf_intf 1 (", self.ip_addr1,
                  " ---> ", self.ip_addr2, ")")
            print('#### NO ACL Applied: sending TCP packets ####')
            print('#### Sending  ', ROUTER_MAC, ' | ', self.mac1, ' | ',
                  self.ip_addr1, ' | ', self.ip_addr2, ' | @ ptf_intf 2')
            send_packet(self, self.dev_port10, self.tcpv6_2)
            print('#### Expecting ', self.mac2, ' | ', ROUTER_MAC, ' | ',
                  self.ip_addr1, ' | ', self.ip_addr2, ' | @ ptf_intf 1')
            verify_packets(self, self.exp_tcpv6_2, [self.dev_port11])
            print('#### NO ACL Applied: sending UDP packets ####')
            send_packet(self, self.dev_port10, self.udpv6_2)
            verify_packets(self, self.exp_udpv6_2, [self.dev_port11])
        finally:
            print('----------------------------------------------------------')

    def aclIPv6NextHdrTest(self, table_stage):
        """
        Verify ACL with next header field
        Args:
            table_stage (int): specifies ingress or egress type of ACL
        """
        # setup ACL to block based on Source IP
        acl_mask = 'ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff'
        table_bind_point_list = [SAI_ACL_BIND_POINT_TYPE_PORT]
        # next level protocol is TCP
        ipv6_next_header = 0x06

        if table_stage == SAI_ACL_STAGE_INGRESS:
            src_ip = self.ip_addr2
            dst_ip = self.ip_addr1
        elif table_stage == SAI_ACL_STAGE_EGRESS:
            src_ip = self.ip_addr1
            dst_ip = self.ip_addr2

        table_bind_point_type_list = sai_thrift_s32_list_t(
            count=len(table_bind_point_list), int32list=table_bind_point_list)

        acl_table_id = sai_thrift_create_acl_table(
            self.client,
            acl_stage=table_stage,
            acl_bind_point_type_list=table_bind_point_type_list,
            field_src_ipv6=True,
            field_ipv6_next_header=True)

        src_ip_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(ip6=src_ip),
            mask=sai_thrift_acl_field_data_mask_t(
                ip6=acl_mask))

        packet_action = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                s32=SAI_PACKET_ACTION_DROP))

        field_ipv6_next_header = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(u8=ipv6_next_header),
            mask=sai_thrift_acl_field_data_mask_t(u8=0x0F))

        # Add drop ACL entry to IPv6 ACL Table
        acl_entry_id = sai_thrift_create_acl_entry(
            self.client,
            priority=9999,
            table_id=acl_table_id,
            field_src_ipv6=src_ip_t,
            action_packet_action=packet_action,
            field_ipv6_next_header=field_ipv6_next_header)

        # create ACL counter
        acl_counter = sai_thrift_create_acl_counter(
            self.client, table_id=acl_table_id)

        # attach ACL counter to ACL entry
        action_counter = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=acl_counter),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, acl_entry_id,
            action_counter=action_counter)

        if table_stage == SAI_ACL_STAGE_INGRESS:
            # bind this ACL table to ports object id
            sai_thrift_set_port_attribute(
                self.client, self.port11, ingress_acl=acl_table_id)
            sport = self.dev_port11
            dport = self.dev_port10
            pkt_udp = self.udpv6_1
            exp_pkt_udp = self.exp_udpv6_1
            pkt_tcp = self.tcpv6_1
            exp_pkt_tcp = self.exp_tcpv6_1
            dmac = self.mac1
            smac = self.mac2
        elif table_stage == SAI_ACL_STAGE_EGRESS:
            # bind this ACL table to ports object id
            sai_thrift_set_port_attribute(
                self.client, self.port11, egress_acl=acl_table_id)
            sport = self.dev_port10
            dport = self.dev_port11
            pkt_udp = self.udpv6_2
            exp_pkt_udp = self.exp_udpv6_2
            pkt_tcp = self.tcpv6_2
            exp_pkt_tcp = self.exp_tcpv6_2
            dmac = self.mac2
            smac = self.mac1

        try:
            self.assertNotEqual(acl_table_id, 0)
            self.assertNotEqual(acl_entry_id, 0)

            print("Sending packet ptf_intf 2-[ACL]-> ptf_intf 1 (", src_ip,
                  " -[ACL]-> ", dst_ip, ")")
            print('#### Sending   TCP', ROUTER_MAC, ' | ', smac, ' | ',
                  src_ip, ' | ', dst_ip, ' | @ ptf_intf 2')
            send_packet(self, sport, pkt_tcp)
            # ensure the TCP packet is dropped and check for absence
            # of packet here
            print('#### NOT Expecting TCP ', dmac, ' | ', ROUTER_MAC, ' | ',
                  src_ip, ' | ', dst_ip, ' | @ ptf_intf 1')
            verify_no_other_packets(self, timeout=2)

            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter, packets=True)
            self.assertEqual(packets['packets'], 1)

            print('#### Sending   UDP', ROUTER_MAC, ' | ', smac, ' | ',
                  src_ip, ' | ', dst_ip, ' | @ ptf_intf 2')
            send_packet(self, sport, pkt_udp)
            # ensure the UDP packet is forwarded
            print('#### Expecting UDP ', dmac, ' | ', ROUTER_MAC, ' | ',
                  src_ip, ' | ', dst_ip, ' | @ ptf_intf 1')
            verify_packets(self, exp_pkt_udp, [dport])

            # change action_type of ACL entry from ACL_DROP to ACL_PERMIT
            aclaction_data = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    s32=SAI_PACKET_ACTION_FORWARD), enable=True)
            sai_thrift_set_acl_entry_attribute(
                client=self.client,
                acl_entry_oid=acl_entry_id,
                action_packet_action=aclaction_data)

            print('#### Sending      ', ROUTER_MAC, ' | ', smac, ' | ', src_ip,
                  ' | ', dst_ip, ' | @ ptf_intf 2')
            # send the same packet
            send_packet(self, sport, pkt_tcp)
            print('#### Expecting ', dmac, ' | ', ROUTER_MAC, ' | ', src_ip,
                  ' | ', dst_ip, ' | @ ptf_intf 1')
            # check that TCP packet is forwarded
            verify_packets(self, exp_pkt_tcp, [dport])

            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter, packets=True)
            self.assertEqual(packets['packets'], 1)

        finally:
            # cleanup ACL
            action_counter = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=0),
                enable=True)
            sai_thrift_set_acl_entry_attribute(
                self.client, acl_entry_id,
                action_counter=action_counter)
            sai_thrift_set_acl_counter_attribute(
                self.client, acl_counter, packets=None)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter, packets=True)
            self.assertEqual(packets['packets'], 0)
            sai_thrift_remove_acl_counter(self.client, acl_counter)

            # unbind this ACL table from ports object id
            if table_stage == SAI_ACL_STAGE_INGRESS:
                sai_thrift_set_port_attribute(
                    self.client, self.port11, ingress_acl=0)
            elif table_stage == SAI_ACL_STAGE_EGRESS:
                sai_thrift_set_port_attribute(
                    self.client, self.port11, egress_acl=0)

            sai_thrift_remove_acl_entry(self.client, acl_entry_id)
            sai_thrift_remove_acl_table(self.client, acl_table_id)


@disabled
@group('acl2')
class OuterVlanIdAclTest(SaiHelper):
    """
    Verify ACL outer vlan id test case
    """

    def setUp(self):
        super(OuterVlanIdAclTest, self).setUp()
        print("Sending L2 packet - port 24 <-> port 25 [trunk vlan=101])")
        vlan_id = 101
        mac1 = '00:11:11:11:11:11'
        mac2 = '00:22:22:22:22:22'
        mac3 = '00:33:33:33:33:33'
        mac_action = SAI_PACKET_ACTION_FORWARD
        self.table_stage_ingress = SAI_ACL_STAGE_INGRESS
        self.group_stage_ingress = SAI_ACL_STAGE_INGRESS

        self.vlan_oid = sai_thrift_create_vlan(self.client, vlan_id)

        self.port24_bp = sai_thrift_create_bridge_port(
            self.client,
            bridge_id=self.default_1q_bridge,
            port_id=self.port24,
            type=SAI_BRIDGE_PORT_TYPE_PORT,
            admin_state=True)

        self.vlan_member1 = sai_thrift_create_vlan_member(
            self.client,
            vlan_id=self.vlan_oid,
            bridge_port_id=self.port24_bp,
            vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_TAGGED)

        self.port25_bp = sai_thrift_create_bridge_port(
            self.client,
            bridge_id=self.default_1q_bridge,
            port_id=self.port25,
            type=SAI_BRIDGE_PORT_TYPE_PORT,
            admin_state=True)

        self.vlan_member2 = sai_thrift_create_vlan_member(
            self.client,
            vlan_id=self.vlan_oid,
            bridge_port_id=self.port25_bp,
            vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_TAGGED)

        self.port26_bp = sai_thrift_create_bridge_port(
            self.client,
            bridge_id=self.default_1q_bridge,
            port_id=self.port26,
            type=SAI_BRIDGE_PORT_TYPE_PORT,
            admin_state=True)

        self.vlan_member3 = sai_thrift_create_vlan_member(
            self.client,
            vlan_id=self.vlan_oid,
            bridge_port_id=self.port26_bp,
            vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_UNTAGGED)

        self.fdb_entry1 = sai_thrift_fdb_entry_t(
            switch_id=self.switch_id, mac_address=mac1, bv_id=self.vlan_oid)
        sai_thrift_create_fdb_entry(
            self.client,
            self.fdb_entry1,
            type=SAI_FDB_ENTRY_TYPE_STATIC,
            bridge_port_id=self.port24_bp,
            packet_action=mac_action)

        self.fdb_entry2 = sai_thrift_fdb_entry_t(
            switch_id=self.switch_id, mac_address=mac2, bv_id=self.vlan_oid)
        sai_thrift_create_fdb_entry(
            self.client,
            self.fdb_entry2,
            type=SAI_FDB_ENTRY_TYPE_STATIC,
            bridge_port_id=self.port25_bp,
            packet_action=mac_action)

        self.fdb_entry3 = sai_thrift_fdb_entry_t(
            switch_id=self.switch_id, mac_address=mac3, bv_id=self.vlan_oid)
        sai_thrift_create_fdb_entry(
            self.client,
            self.fdb_entry3,
            type=SAI_FDB_ENTRY_TYPE_STATIC,
            bridge_port_id=self.port26_bp,
            packet_action=mac_action)

        self.pkt1 = simple_tcp_packet(
            eth_dst='00:22:22:22:22:22',
            eth_src='00:11:11:11:11:11',
            dl_vlan_enable=True,
            vlan_vid=101,
            ip_src='192.168.100.1',
            ip_dst='172.16.0.1',
            ip_id=102,
            ip_ttl=64)

        self.pkt2 = simple_tcp_packet(
            eth_dst='00:22:22:22:22:22',
            eth_src='00:33:33:33:33:33',
            dl_vlan_enable=True,
            vlan_vid=101,
            ip_src='192.168.100.1',
            ip_dst='172.16.0.1',
            ip_id=102,
            ip_ttl=64)

    def runTest(self):
        self.aclOuterVlanTest(
            self.table_stage_ingress, self.group_stage_ingress)

    def tearDown(self):
        sai_thrift_remove_fdb_entry(
            self.client, self.fdb_entry1)
        sai_thrift_remove_fdb_entry(self.client, self.fdb_entry2)
        sai_thrift_remove_fdb_entry(self.client, self.fdb_entry3)
        sai_thrift_remove_vlan_member(self.client, self.vlan_member1)
        sai_thrift_remove_vlan_member(self.client, self.vlan_member2)
        sai_thrift_remove_vlan_member(self.client, self.vlan_member3)
        sai_thrift_remove_bridge_port(self.client, self.port24_bp)
        sai_thrift_remove_bridge_port(self.client, self.port25_bp)
        sai_thrift_remove_bridge_port(self.client, self.port26_bp)
        sai_thrift_remove_vlan(self.client, self.vlan_oid)
        super(OuterVlanIdAclTest, self).tearDown()

    def aclOuterVlanTest(self, table_stage, group_stage):
        """
        Verify Outer Vlan ID Test
        Args:
            table_stage (int): specifies the type of ACL table stage
            group_stage (int): specifies the type of ACL group stage
        """
        table_bind_point_list = [
            SAI_ACL_BIND_POINT_TYPE_PORT]
        entry_priority = 1

        group_bind_point_list = [SAI_ACL_BIND_POINT_TYPE_PORT]
        group_type = SAI_ACL_TABLE_GROUP_TYPE_PARALLEL
        group_member_priority = 100

        acl_action = SAI_PACKET_ACTION_DROP
        outer_vlan_id = 101

        group_bind_point_type_list = sai_thrift_s32_list_t(
            count=len(group_bind_point_list),
            int32list=group_bind_point_list)

        table_bind_point_type_list = sai_thrift_s32_list_t(
            count=len(table_bind_point_list),
            int32list=table_bind_point_list)

        packet_action = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                s32=acl_action))

        outer_vlan_id = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(u16=101),
            mask=sai_thrift_acl_field_data_mask_t(u16=4095))

        acl_table_group_id = sai_thrift_create_acl_table_group(
            self.client,
            acl_stage=group_stage,
            acl_bind_point_type_list=group_bind_point_type_list,
            type=group_type)

        acl_table_id = sai_thrift_create_acl_table(
            self.client,
            acl_stage=table_stage,
            acl_bind_point_type_list=table_bind_point_type_list,
            field_outer_vlan_id=101)

        acl_table_group_member_id = sai_thrift_create_acl_table_group_member(
            self.client,
            acl_table_group_id=acl_table_group_id,
            acl_table_id=acl_table_id,
            priority=group_member_priority)

        acl_entry_id = sai_thrift_create_acl_entry(
            self.client,
            table_id=acl_table_id,
            priority=entry_priority,
            action_packet_action=packet_action,
            field_outer_vlan_id=outer_vlan_id)

        acl_counter = sai_thrift_create_acl_counter(
            self.client, table_id=acl_table_id)

        # attach ACL counter to ACL entry
        action_counter = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=acl_counter),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, acl_entry_id,
            action_counter=action_counter)

        # bind this ACL table group to ports
        sai_thrift_set_port_attribute(
            self.client, self.port24, ingress_acl=acl_table_group_id)
        sai_thrift_set_port_attribute(
            self.client, self.port25, ingress_acl=acl_table_group_id)
        sai_thrift_set_port_attribute(
            self.client, self.port26, ingress_acl=acl_table_group_id)

        try:
            # Send VLAN tagged packet
            send_packet(
                self, self.dev_port24, self.pkt1)
            verify_no_other_packets(self, timeout=1)
            # Send VLAN untagged packet
            send_packet(self, self.dev_port25, self.pkt2)
            verify_no_other_packets(self, timeout=1)

            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter, packets=True)
            self.assertEqual(packets['packets'], 2)

        finally:
            # cleanup ACL
            action_counter = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=0),
                enable=True)
            sai_thrift_set_acl_entry_attribute(
                self.client, acl_entry_id,
                action_counter=action_counter)
            sai_thrift_set_acl_counter_attribute(
                self.client, acl_counter, packets=None)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter, packets=True)
            self.assertEqual(packets['packets'], 0)
            sai_thrift_remove_acl_counter(
                self.client, acl_counter)

            sai_thrift_set_port_attribute(
                self.client, self.port24, ingress_acl=0)
            sai_thrift_set_port_attribute(
                self.client, self.port25, ingress_acl=0)
            sai_thrift_set_port_attribute(
                self.client, self.port26, ingress_acl=0)

            sai_thrift_remove_acl_table_group_member(
                self.client, acl_table_group_member_id)
            sai_thrift_remove_acl_entry(
                self.client, acl_entry_id)
            sai_thrift_remove_acl_table(
                self.client, acl_table_id)
            sai_thrift_remove_acl_table_group(
                self.client, acl_table_group_id)


@disabled
@group('acl2')
class OuterVlanIdAclTestEgress(SaiHelper):
    """
    Verify matching on outer vlan Id egress L3 routing case
    """
    def setUp(self):
        super(OuterVlanIdAclTestEgress, self).setUp()

        self.vlan100_rif_counter_in = 0
        self.vlan200_rif_counter_out = 0

        self.port24_bridgeport = sai_thrift_create_bridge_port(
            self.client,
            bridge_id=self.default_1q_bridge,
            port_id=self.port24,
            type=SAI_BRIDGE_PORT_TYPE_PORT,
            admin_state=True)
        self.port25_bridgeport = sai_thrift_create_bridge_port(
            self.client,
            bridge_id=self.default_1q_bridge,
            port_id=self.port25,
            type=SAI_BRIDGE_PORT_TYPE_PORT,
            admin_state=True)
        self.port26_bridgeport = sai_thrift_create_bridge_port(
            self.client,
            bridge_id=self.default_1q_bridge,
            port_id=self.port26,
            type=SAI_BRIDGE_PORT_TYPE_PORT,
            admin_state=True)

        # vlan100 with port members 24, 25 and 26
        self.vlan100 = sai_thrift_create_vlan(self.client, vlan_id=100)
        self.vlan_member1 = sai_thrift_create_vlan_member(
            self.client,
            vlan_id=self.vlan100,
            bridge_port_id=self.port24_bridgeport,
            vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_UNTAGGED)
        self.vlan_member2 = sai_thrift_create_vlan_member(
            self.client,
            vlan_id=self.vlan100,
            bridge_port_id=self.port25_bridgeport,
            vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_UNTAGGED)
        self.vlan_member3 = sai_thrift_create_vlan_member(
            self.client,
            vlan_id=self.vlan100,
            bridge_port_id=self.port26_bridgeport,
            vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_UNTAGGED)
        sai_thrift_set_port_attribute(
            self.client, self.port24, port_vlan_id=100)
        sai_thrift_set_port_attribute(
            self.client, self.port25, port_vlan_id=100)
        sai_thrift_set_port_attribute(
            self.client, self.port26, port_vlan_id=100)

        # create vlan100_rif
        self.vlan100_rif = sai_thrift_create_router_interface(
            self.client,
            type=SAI_ROUTER_INTERFACE_TYPE_VLAN,
            virtual_router_id=self.default_vrf,
            vlan_id=self.vlan100)

        self.dmac1 = '00:11:22:33:44:55'  # 10.10.10.1
        self.dmac2 = '00:22:22:33:44:55'  # 10.10.10.2
        self.dmac3 = '00:33:22:33:44:55'  # 10.10.10.3
        self.dmac4 = '00:44:22:33:44:55'  # 11.11.11.1
        self.dmac5 = '00:11:33:33:44:55'  # 20.10.10.1
        self.dmac6 = '00:22:33:33:44:55'  # 20.10.10.2
        self.dmac7 = '00:44:33:33:44:55'  # 20.11.11.1

        # create nexthop1, nexthop2 & nexthop3 on SVI
        self.nexthop1 = sai_thrift_create_next_hop(
            self.client,
            ip=sai_ipaddress('10.10.0.1'),
            router_interface_id=self.vlan100_rif,
            type=SAI_NEXT_HOP_TYPE_IP)
        self.neighbor_entry1 = sai_thrift_neighbor_entry_t(
            rif_id=self.vlan100_rif, ip_address=sai_ipaddress('10.10.0.1'))
        sai_thrift_create_neighbor_entry(
            self.client, self.neighbor_entry1, dst_mac_address=self.dmac1)
        self.route_entry1 = sai_thrift_route_entry_t(
            vr_id=self.default_vrf, destination=sai_ipprefix('10.10.10.1/32'))
        sai_thrift_create_route_entry(
            self.client, self.route_entry1, next_hop_id=self.nexthop1)
        self.route_entry1_v6 = sai_thrift_route_entry_t(
            vr_id=self.default_vrf,
            destination=sai_ipprefix(
                '1234:5678:9abc:def0:4422:1133:5577:0000/128'))
        sai_thrift_create_route_entry(
            self.client, self.route_entry1_v6, next_hop_id=self.nexthop1)

        self.neighbor_entry2 = sai_thrift_neighbor_entry_t(
            rif_id=self.vlan100_rif, ip_address=sai_ipaddress('10.10.0.2'))
        sai_thrift_create_neighbor_entry(
            self.client, self.neighbor_entry2, dst_mac_address=self.dmac2)
        self.nexthop2 = sai_thrift_create_next_hop(
            self.client,
            ip=sai_ipaddress('10.10.0.2'),
            router_interface_id=self.vlan100_rif,
            type=SAI_NEXT_HOP_TYPE_IP)
        self.route_entry2 = sai_thrift_route_entry_t(
            vr_id=self.default_vrf, destination=sai_ipprefix('10.10.10.2/32'))
        sai_thrift_create_route_entry(
            self.client, self.route_entry2, next_hop_id=self.nexthop2)
        self.route_entry2_v6 = sai_thrift_route_entry_t(
            vr_id=self.default_vrf,
            destination=sai_ipprefix(
                '1234:5678:9abc:def0:4422:1133:5577:2222/128'))
        sai_thrift_create_route_entry(
            self.client, self.route_entry2_v6, next_hop_id=self.nexthop2)

        self.nexthop3 = sai_thrift_create_next_hop(
            self.client,
            ip=sai_ipaddress('10.10.0.3'),
            router_interface_id=self.vlan100_rif,
            type=SAI_NEXT_HOP_TYPE_IP)
        self.neighbor_entry3 = sai_thrift_neighbor_entry_t(
            rif_id=self.vlan100_rif, ip_address=sai_ipaddress('10.10.0.3'))
        sai_thrift_create_neighbor_entry(
            self.client, self.neighbor_entry3, dst_mac_address=self.dmac3)
        self.route_entry3 = sai_thrift_route_entry_t(
            vr_id=self.default_vrf, destination=sai_ipprefix('10.10.10.3/32'))
        sai_thrift_create_route_entry(
            self.client, self.route_entry3, next_hop_id=self.nexthop3)

        # create nexthop4 and route to L2 intf
        self.nexthop4 = sai_thrift_create_next_hop(
            self.client,
            ip=sai_ipaddress('11.11.0.2'),
            router_interface_id=self.port10_rif,
            type=SAI_NEXT_HOP_TYPE_IP)
        self.neighbor_entry4 = sai_thrift_neighbor_entry_t(
            rif_id=self.port10_rif, ip_address=sai_ipaddress('11.11.0.2'))
        sai_thrift_create_neighbor_entry(
            self.client, self.neighbor_entry4, dst_mac_address=self.dmac4)
        self.route_entry4 = sai_thrift_route_entry_t(
            vr_id=self.default_vrf, destination=sai_ipprefix('11.11.11.1/32'))
        sai_thrift_create_route_entry(
            self.client, self.route_entry4, next_hop_id=self.nexthop4)
        self.route_entry4_v6 = sai_thrift_route_entry_t(
            vr_id=self.default_vrf,
            destination=sai_ipprefix(
                '1234:5678:9abc:def0:4422:1133:5577:1111/128'))
        sai_thrift_create_route_entry(
            self.client, self.route_entry4_v6, next_hop_id=self.nexthop4)

        # create LAG10 and LAG11
        self.lag10 = sai_thrift_create_lag(self.client)
        self.lag10_bp = sai_thrift_create_bridge_port(
            self.client,
            bridge_id=self.default_1q_bridge,
            port_id=self.lag10,
            type=SAI_BRIDGE_PORT_TYPE_PORT,
            admin_state=True)
        self.lag10_member1 = sai_thrift_create_lag_member(
            self.client, lag_id=self.lag10, port_id=self.port30)
        self.lag10_member2 = sai_thrift_create_lag_member(
            self.client, lag_id=self.lag10, port_id=self.port31)

        self.lag11 = sai_thrift_create_lag(self.client)
        self.lag11_bp = sai_thrift_create_bridge_port(
            self.client,
            bridge_id=self.default_1q_bridge,
            port_id=self.lag11,
            type=SAI_BRIDGE_PORT_TYPE_PORT,
            admin_state=True)
        self.lag11_member1 = sai_thrift_create_lag_member(
            self.client, lag_id=self.lag11, port_id=self.port28)
        self.lag11_member2 = sai_thrift_create_lag_member(
            self.client, lag_id=self.lag11, port_id=self.port29)

        # vlan200 with members LAG10(UNTAGGED) and LAG11(TAGGED)
        self.vlan200 = sai_thrift_create_vlan(self.client, vlan_id=200)
        self.vlan_member4 = sai_thrift_create_vlan_member(
            self.client,
            vlan_id=self.vlan200,
            bridge_port_id=self.lag10_bp,
            vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_UNTAGGED)
        self.vlan_member5 = sai_thrift_create_vlan_member(
            self.client,
            vlan_id=self.vlan200,
            bridge_port_id=self.lag11_bp,
            vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_TAGGED)
        sai_thrift_set_lag_attribute(self.client, self.lag10, port_vlan_id=200)
        sai_thrift_set_lag_attribute(self.client, self.lag11, port_vlan_id=200)

        self.vlan200_rif = sai_thrift_create_router_interface(
            self.client,
            type=SAI_ROUTER_INTERFACE_TYPE_VLAN,
            virtual_router_id=self.default_vrf,
            vlan_id=self.vlan200)

        # Create nexthop5 and nexthop6 on SVI
        self.nexthop5 = sai_thrift_create_next_hop(
            self.client,
            ip=sai_ipaddress('20.10.0.1'),
            router_interface_id=self.vlan200_rif,
            type=SAI_NEXT_HOP_TYPE_IP)
        self.neighbor_entry5 = sai_thrift_neighbor_entry_t(
            rif_id=self.vlan200_rif, ip_address=sai_ipaddress('20.10.0.1'))
        sai_thrift_create_neighbor_entry(
            self.client, self.neighbor_entry5, dst_mac_address=self.dmac5)
        self.route_entry5 = sai_thrift_route_entry_t(
            vr_id=self.default_vrf, destination=sai_ipprefix('20.10.10.1/32'))
        sai_thrift_create_route_entry(
            self.client, self.route_entry5, next_hop_id=self.nexthop5)
        self.route_entry5_v6 = sai_thrift_route_entry_t(
            vr_id=self.default_vrf,
            destination=sai_ipprefix(
                '1234:5678:9abc:def0:4422:1133:5577:99aa/128'))
        sai_thrift_create_route_entry(
            self.client, self.route_entry5_v6, next_hop_id=self.nexthop5)

        self.nexthop6 = sai_thrift_create_next_hop(
            self.client,
            ip=sai_ipaddress('20.10.0.2'),
            router_interface_id=self.vlan200_rif,
            type=SAI_NEXT_HOP_TYPE_IP)
        self.neighbor_entry6 = sai_thrift_neighbor_entry_t(
            rif_id=self.vlan200_rif, ip_address=sai_ipaddress('20.10.0.2'))
        sai_thrift_create_neighbor_entry(
            self.client, self.neighbor_entry6, dst_mac_address=self.dmac6)
        self.route_entry6 = sai_thrift_route_entry_t(
            vr_id=self.default_vrf, destination=sai_ipprefix('20.10.10.2/32'))
        sai_thrift_create_route_entry(
            self.client, self.route_entry6, next_hop_id=self.nexthop6)
        self.route_entry6_v6 = sai_thrift_route_entry_t(
            vr_id=self.default_vrf,
            destination=sai_ipprefix(
                '1234:5678:9abc:def0:1122:3344:5566:7788/128'))
        sai_thrift_create_route_entry(
            self.client, self.route_entry6_v6, next_hop_id=self.nexthop6)

        # create nexthop7 and route to L2 intf
        self.nexthop7 = sai_thrift_create_next_hop(
            self.client,
            ip=sai_ipaddress('21.11.0.2'),
            router_interface_id=self.port11_rif,
            type=SAI_NEXT_HOP_TYPE_IP)
        self.neighbor_entry7 = sai_thrift_neighbor_entry_t(
            rif_id=self.port11_rif, ip_address=sai_ipaddress('21.11.0.2'))
        sai_thrift_create_neighbor_entry(
            self.client, self.neighbor_entry7, dst_mac_address=self.dmac7)
        self.route_entry7 = sai_thrift_route_entry_t(
            vr_id=self.default_vrf, destination=sai_ipprefix('21.11.11.1/32'))
        sai_thrift_create_route_entry(
            self.client, self.route_entry7, next_hop_id=self.nexthop7)
        self.route_entry7_v6 = sai_thrift_route_entry_t(
            vr_id=self.default_vrf,
            destination=sai_ipprefix(
                '1234:5678:9abc:def0:1122:3344:5566:6677/128'))
        sai_thrift_create_route_entry(
            self.client, self.route_entry7_v6, next_hop_id=self.nexthop7)

    def runTest(self):
        group_stage_egress = SAI_ACL_STAGE_EGRESS
        group_bind_point_list = [SAI_ACL_BIND_POINT_TYPE_PORT]
        group_type = SAI_ACL_TABLE_GROUP_TYPE_PARALLEL
        table_stage_egress = SAI_ACL_STAGE_EGRESS

        group_bind_point_type_list = sai_thrift_s32_list_t(
            count=len(group_bind_point_list), int32list=group_bind_point_list)

        table_bind_point_list = [SAI_ACL_BIND_POINT_TYPE_PORT]
        table_bind_point_type_list = sai_thrift_s32_list_t(
            count=len(table_bind_point_list), int32list=table_bind_point_list)

        packet_action = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                s32=SAI_PACKET_ACTION_DROP))

        outer_vlan_id_200 = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(u16=200),
            mask=sai_thrift_acl_field_data_mask_t(u16=4095))

        # create Egress ACL Group
        print("Create Egress ACL tables group")
        acl_group_egress = sai_thrift_create_acl_table_group(
            self.client,
            acl_stage=group_stage_egress,
            acl_bind_point_type_list=group_bind_point_type_list,
            type=group_type)

        # create Egress IPv4 ACL table
        print("Create Egress IPv4 ACL table")
        acl_egress_ipv4_table_id = sai_thrift_create_acl_table(
            self.client,
            acl_stage=table_stage_egress,
            acl_bind_point_type_list=table_bind_point_type_list,
            field_src_ip=True)

        # create Egress ACL table group member
        print("Create Egress ACL group member")
        acl_group_egress_ipv4_member_id = \
            sai_thrift_create_acl_table_group_member(
                self.client,
                acl_table_group_id=acl_group_egress,
                acl_table_id=acl_egress_ipv4_table_id)

        # create Egress IPv4 ACL entry
        print("Create Egress IPv4 ACL entry")
        ipv4_acl_egress_entry_id = sai_thrift_create_acl_entry(
            self.client,
            table_id=acl_egress_ipv4_table_id,
            action_packet_action=packet_action,
            field_outer_vlan_id=outer_vlan_id_200)
        # create IPv4 ACL counter
        acl_counter_egress_ipv4 = sai_thrift_create_acl_counter(
            self.client, table_id=acl_egress_ipv4_table_id)
        # attach IPv4 ACL counter to ACL entry
        action_counter_egress_ipv4 = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=acl_counter_egress_ipv4), enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, ipv4_acl_egress_entry_id,
            action_counter=action_counter_egress_ipv4)

        mac_action = SAI_PACKET_ACTION_FORWARD
        port27_bp = sai_thrift_create_bridge_port(
            self.client,
            bridge_id=self.default_1q_bridge,
            port_id=self.port27,
            type=SAI_BRIDGE_PORT_TYPE_PORT,
            admin_state=True)

        vlan_member6 = sai_thrift_create_vlan_member(
            self.client,
            vlan_id=self.vlan100,
            bridge_port_id=port27_bp,
            vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_TAGGED)

        fdb_entry27 = sai_thrift_fdb_entry_t(switch_id=self.switch_id,
                                             mac_address=self.dmac2,
                                             bv_id=self.vlan100)
        sai_thrift_create_fdb_entry(self.client,
                                    fdb_entry27,
                                    type=SAI_FDB_ENTRY_TYPE_STATIC,
                                    bridge_port_id=port27_bp,
                                    packet_action=mac_action)

        # Create FDB entries for LAG10
        fdb_entry_lag10 = sai_thrift_fdb_entry_t(switch_id=self.switch_id,
                                                 mac_address=self.dmac5,
                                                 bv_id=self.vlan200)
        sai_thrift_create_fdb_entry(self.client,
                                    fdb_entry_lag10,
                                    type=SAI_FDB_ENTRY_TYPE_STATIC,
                                    bridge_port_id=self.lag10_bp,
                                    packet_action=mac_action)

        # Create FDB entries for LAG11
        fdb_entry_lag11 = sai_thrift_fdb_entry_t(switch_id=self.switch_id,
                                                 mac_address=self.dmac6,
                                                 bv_id=self.vlan200)
        sai_thrift_create_fdb_entry(self.client,
                                    fdb_entry_lag11,
                                    type=SAI_FDB_ENTRY_TYPE_STATIC,
                                    bridge_port_id=self.lag11_bp,
                                    packet_action=mac_action)

        tagged_pkt = simple_tcp_packet(eth_dst=ROUTER_MAC,
                                       eth_src=self.dmac2,
                                       ip_dst='20.10.10.1',
                                       ip_src='192.168.0.1',
                                       dl_vlan_enable=True,
                                       vlan_vid=100,
                                       ip_ttl=64,
                                       pktlen=104)
        tagged_pkt_tolag11 = simple_tcp_packet(eth_dst=ROUTER_MAC,
                                               eth_src=self.dmac2,
                                               ip_dst='20.10.10.2',
                                               ip_src='192.168.0.1',
                                               dl_vlan_enable=True,
                                               vlan_vid=100,
                                               ip_ttl=64,
                                               pktlen=104)
        exp_pkt = simple_tcp_packet(eth_dst=self.dmac5,
                                    eth_src=ROUTER_MAC,
                                    ip_dst='20.10.10.1',
                                    ip_src='192.168.0.1',
                                    ip_ttl=63)
        tagged_exp_pkt_tolag11 = simple_tcp_packet(eth_dst=self.dmac6,
                                                   eth_src=ROUTER_MAC,
                                                   ip_dst='20.10.10.2',
                                                   ip_src='192.168.0.1',
                                                   dl_vlan_enable=True,
                                                   vlan_vid=200,
                                                   ip_ttl=63,
                                                   pktlen=104)

        try:

            print("Sending packet port %d to LAG, (192.168.0.1 -> 20.10.10.1)"
                  % (self.dev_port27))
            send_packet(self, self.dev_port27, tagged_pkt)
            verify_packet_any_port(self, exp_pkt,
                                   [self.dev_port30, self.dev_port31])
            self.vlan100_rif_counter_in += 1
            self.vlan200_rif_counter_out += 1

            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter_egress_ipv4, packets=True)
            self.assertEqual(packets['packets'], 0)

            # bind ACL group to LAG10 and verify ACL work
            sai_thrift_set_lag_attribute(
                self.client, self.lag10, egress_acl=acl_group_egress)
            send_packet(self, self.dev_port27, tagged_pkt)
            verify_no_other_packets(self, timeout=1)

            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter_egress_ipv4, packets=True)
            self.assertEqual(packets['packets'], 1)

            print("Sending packet port %d to LAG, (192.168.0.1 -> 20.10.10.2)"
                  % (self.dev_port27))
            send_packet(self, self.dev_port27, tagged_pkt_tolag11)
            verify_packet_any_port(self, tagged_exp_pkt_tolag11,
                                   [self.dev_port28, self.dev_port29])

            # bind ACL group to LAG11 and verify ACL work
            sai_thrift_set_lag_attribute(
                self.client, self.lag11, egress_acl=acl_group_egress)
            send_packet(self, self.dev_port27, tagged_pkt_tolag11)
            verify_no_other_packets(self, timeout=1)

            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter_egress_ipv4, packets=True)
            self.assertEqual(packets['packets'], 2)

        finally:
            action_counter_egress_ipv4 = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=0),
                enable=True)
            sai_thrift_set_acl_entry_attribute(
                self.client, ipv4_acl_egress_entry_id,
                action_counter=action_counter_egress_ipv4)
            sai_thrift_set_acl_counter_attribute(
                self.client, acl_counter_egress_ipv4, packets=None)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter_egress_ipv4, packets=True)
            self.assertEqual(packets['packets'], 0)
            sai_thrift_remove_acl_counter(self.client, acl_counter_egress_ipv4)

            sai_thrift_remove_acl_table_group_member(
                self.client, acl_group_egress_ipv4_member_id)
            sai_thrift_remove_acl_table_group(self.client, acl_group_egress)
            sai_thrift_remove_acl_entry(self.client, ipv4_acl_egress_entry_id)
            sai_thrift_remove_acl_table(self.client, acl_egress_ipv4_table_id)
            sai_thrift_remove_fdb_entry(self.client, fdb_entry_lag10)
            sai_thrift_remove_fdb_entry(self.client, fdb_entry_lag11)
            sai_thrift_remove_fdb_entry(self.client, fdb_entry27)
            sai_thrift_remove_vlan_member(self.client, vlan_member6)
            sai_thrift_remove_bridge_port(self.client, port27_bp)
            sai_thrift_flush_fdb_entries(self.client)

    def tearDown(self):
        sai_thrift_remove_route_entry(self.client, self.route_entry5)
        sai_thrift_remove_route_entry(self.client, self.route_entry5_v6)
        sai_thrift_remove_route_entry(self.client, self.route_entry6)
        sai_thrift_remove_route_entry(self.client, self.route_entry6_v6)
        sai_thrift_remove_route_entry(self.client, self.route_entry7)
        sai_thrift_remove_route_entry(self.client, self.route_entry7_v6)

        sai_thrift_remove_neighbor_entry(self.client, self.neighbor_entry5)
        sai_thrift_remove_neighbor_entry(self.client, self.neighbor_entry6)
        sai_thrift_remove_neighbor_entry(self.client, self.neighbor_entry7)

        sai_thrift_remove_next_hop(self.client, self.nexthop5)
        sai_thrift_remove_next_hop(self.client, self.nexthop6)
        sai_thrift_remove_next_hop(self.client, self.nexthop7)

        sai_thrift_set_lag_attribute(self.client, self.lag10, port_vlan_id=0)
        sai_thrift_set_lag_attribute(self.client, self.lag11, port_vlan_id=0)

        sai_thrift_remove_router_interface(self.client, self.vlan200_rif)

        sai_thrift_remove_vlan_member(self.client, self.vlan_member4)
        sai_thrift_remove_vlan_member(self.client, self.vlan_member5)

        sai_thrift_remove_vlan(self.client, self.vlan200)

        sai_thrift_remove_lag_member(self.client, self.lag10_member1)
        sai_thrift_remove_lag_member(self.client, self.lag10_member2)
        sai_thrift_remove_lag_member(self.client, self.lag11_member1)
        sai_thrift_remove_lag_member(self.client, self.lag11_member2)
        sai_thrift_remove_bridge_port(self.client, self.lag10_bp)
        sai_thrift_remove_bridge_port(self.client, self.lag11_bp)
        sai_thrift_remove_lag(self.client, self.lag10)
        sai_thrift_remove_lag(self.client, self.lag11)

        sai_thrift_remove_route_entry(self.client, self.route_entry1)
        sai_thrift_remove_route_entry(self.client, self.route_entry1_v6)
        sai_thrift_remove_route_entry(self.client, self.route_entry2)
        sai_thrift_remove_route_entry(self.client, self.route_entry2_v6)
        sai_thrift_remove_route_entry(self.client, self.route_entry3)
        sai_thrift_remove_route_entry(self.client, self.route_entry4)
        sai_thrift_remove_route_entry(self.client, self.route_entry4_v6)

        sai_thrift_remove_neighbor_entry(self.client, self.neighbor_entry1)
        sai_thrift_remove_neighbor_entry(self.client, self.neighbor_entry2)
        sai_thrift_remove_neighbor_entry(self.client, self.neighbor_entry3)
        sai_thrift_remove_neighbor_entry(self.client, self.neighbor_entry4)

        sai_thrift_remove_next_hop(self.client, self.nexthop1)
        sai_thrift_remove_next_hop(self.client, self.nexthop2)
        sai_thrift_remove_next_hop(self.client, self.nexthop3)
        sai_thrift_remove_next_hop(self.client, self.nexthop4)

        sai_thrift_remove_router_interface(self.client, self.vlan100_rif)

        sai_thrift_set_port_attribute(self.client, self.port24, port_vlan_id=0)
        sai_thrift_set_port_attribute(self.client, self.port25, port_vlan_id=0)
        sai_thrift_set_port_attribute(self.client, self.port26, port_vlan_id=0)

        sai_thrift_remove_vlan_member(self.client, self.vlan_member1)
        sai_thrift_remove_vlan_member(self.client, self.vlan_member2)
        sai_thrift_remove_vlan_member(self.client, self.vlan_member3)

        sai_thrift_remove_vlan(self.client, self.vlan100)

        sai_thrift_remove_bridge_port(self.client, self.port24_bridgeport)
        sai_thrift_remove_bridge_port(self.client, self.port25_bridgeport)
        sai_thrift_remove_bridge_port(self.client, self.port26_bridgeport)
        super(OuterVlanIdAclTestEgress, self).tearDown()


# WIP
@disabled
class IPEthAclTest(SaiHelper):
    """
    This test mimics SONiC/SAI ACL behavior. SONiC does not have notion
    of MAC ACL. It programs entries with non ip eth type match entries
    into IP ACL. This is different than the SDE behavior which expects
    this entries to be programmed into MAC ACL. This test verifies
    the SDE behavior to be able to identify such acl rules and program
    it correctly in the corresponding H/W ACL tables.
    """
    def setUp(self):
        super(IPEthAclTest, self).setUp()
        self.traps = []
        self.acl_grp_members = []
        self.acl_grps = []
        self.acl_rules = []
        self.acl_tables = []
        self.acl_counters = []
        self.vlans = []
        self.vlan_members = []
        self.bridge_ports = []
        self.vlan_ports = []
        self.bp_list = []

        self.rif_id = sai_thrift_create_router_interface(
            self.client,
            type=SAI_ROUTER_INTERFACE_TYPE_PORT,
            virtual_router_id=self.default_vrf,
            port_id=self.port28)

        # Add port 24, 25 to Vlan100
        vlan_id1 = 100
        vlan_oid1 = sai_thrift_create_vlan(self.client, vlan_id1)
        self.vlans.append(vlan_oid1)

        port1_bp = sai_thrift_create_bridge_port(
            self.client,
            bridge_id=self.default_1q_bridge,
            port_id=self.port24,
            type=SAI_BRIDGE_PORT_TYPE_PORT,
            admin_state=True)
        self.bridge_ports.append(port1_bp)
        vlan_member1 = sai_thrift_create_vlan_member(
            self.client,
            vlan_id=vlan_oid1,
            bridge_port_id=port1_bp,
            vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_UNTAGGED)
        self.vlan_members.append(vlan_member1)
        self.vlan_ports.append(self.port24)

        port2_bp = sai_thrift_create_bridge_port(
            self.client,
            bridge_id=self.default_1q_bridge,
            port_id=self.port25,
            type=SAI_BRIDGE_PORT_TYPE_PORT,
            admin_state=True)
        self.bridge_ports.append(port2_bp)
        vlan_member2 = sai_thrift_create_vlan_member(
            self.client,
            vlan_id=vlan_oid1,
            bridge_port_id=port2_bp,
            vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_UNTAGGED)
        self.vlan_members.append(vlan_member2)
        self.vlan_ports.append(self.port25)

        sai_thrift_set_port_attribute(
            self.client, self.port24, port_vlan_id=vlan_id1)
        sai_thrift_set_port_attribute(
            self.client, self.port25, port_vlan_id=vlan_id1)

        # Add port 26, 27 to Vlan200
        vlan_id2 = 200
        vlan_oid2 = sai_thrift_create_vlan(self.client, vlan_id2)
        self.vlans.append(vlan_oid2)

        port3_bp = sai_thrift_create_bridge_port(
            self.client,
            bridge_id=self.default_1q_bridge,
            port_id=self.port26,
            type=SAI_BRIDGE_PORT_TYPE_PORT,
            admin_state=True)
        self.bridge_ports.append(port3_bp)
        vlan_member3 = sai_thrift_create_vlan_member(
            self.client,
            vlan_id=vlan_oid2,
            bridge_port_id=port3_bp,
            vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_UNTAGGED)
        self.vlan_members.append(vlan_member3)
        self.vlan_ports.append(self.port26)

        port4_bp = sai_thrift_create_bridge_port(
            self.client,
            bridge_id=self.default_1q_bridge,
            port_id=self.port27,
            type=SAI_BRIDGE_PORT_TYPE_PORT,
            admin_state=True)
        self.bridge_ports.append(port4_bp)
        vlan_member4 = sai_thrift_create_vlan_member(
            self.client,
            vlan_id=vlan_oid2,
            bridge_port_id=port4_bp,
            vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_UNTAGGED)
        self.vlan_members.append(vlan_member4)
        self.vlan_ports.append(self.port27)

        sai_thrift_set_port_attribute(
            self.client, self.port26, port_vlan_id=vlan_id2)
        sai_thrift_set_port_attribute(
            self.client, self.port27, port_vlan_id=vlan_id2)

        self.arp_pkt = simple_arp_packet(arp_op=1, pktlen=100)
        self.exp_arp_pkt = self.arp_pkt

        # Setup Mirror ACL
        monitor_port = self.port28
        mirror_type = SAI_MIRROR_SESSION_TYPE_LOCAL
        self.spanid = sai_thrift_create_mirror_session(
            self.client,
            type=mirror_type,
            monitor_port=monitor_port)
        print(self.spanid)
        print('Mirror session created 0x%lx' % self.spanid)
        mirror_session_list = sai_thrift_object_list_t(
            count=1, idlist=[self.spanid])

        self.mirror_action = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                objlist=mirror_session_list))

        self.ipx_pkt = simple_eth_packet(pktlen=100,
                                         eth_dst='00:01:02:03:04:05',
                                         eth_src='00:06:07:08:09:0a',
                                         eth_type=0x8137)
        self.exp_ipx_pkt = self.ipx_pkt

        self.ipv4_pkt = simple_ip_packet(pktlen=100,
                                         eth_dst='00:1B:19:00:00:00')
        self.exp_ipv4_pkt = self.ipv4_pkt

        self.lldp_pkt = simple_eth_packet(pktlen=100,
                                          eth_dst='01:80:C2:00:00:0E',
                                          eth_type=0x88cc)
        self.exp_lldp_pkt = self.lldp_pkt

        self.tcpv6_pkt = simple_tcpv6_packet(pktlen=100, ipv6_src='2000::4')
        self.exp_tcpv6_pkt = self.tcpv6_pkt

        self.tcpv4_pkt = simple_tcp_packet(pktlen=100, ip_src='172.0.0.17')
        self.exp_tcpv4_pkt = self.tcpv4_pkt

        self.tcpv6_pkt2 = simple_tcpv6_packet(pktlen=100, ipv6_src='3000::1')
        self.exp_tcpv6_pkt2 = self.tcpv6_pkt2

        self.udpv6_pkt = simple_udpv6_packet(pktlen=100, ipv6_src='5000::1')
        self.exp_udpv6_pkt = self.udpv6_pkt

        self.udpv4_pkt = simple_udp_packet(pktlen=100, ip_src='10.0.0.1')
        self.exp_udpv4_pkt = self.udpv4_pkt

        self.mac_pkt = simple_eth_packet(pktlen=100,
                                         eth_dst='00:01:02:03:04:05',
                                         eth_src='00:06:07:08:09:0a',
                                         eth_type=0x1234)
        self.exp_mac_pkt = self.mac_pkt

        self.mac_pkt2 = simple_eth_packet(pktlen=100,
                                          eth_dst='00:01:02:03:04:05',
                                          eth_src='00:06:07:08:09:0a',
                                          eth_type=0x4321)
        self.exp_mac_pkt2 = self.mac_pkt2

        self.exp_counters = {"arp": 0, "ipx": 0, "ipv4": 0, "lldp": 0,
                             "ipv6": 0, "mirror_ip4": 0, "mirror_ip6": 0,
                             "mirror_udp": 0, "mirror_mac": 0}

    def runTest(self):
        self.noAclTest()
        self.arpAclTest()
        self.ipxAclTest()
        self.ipv4AclTest()
        self.lldpAclTest()
        self.ipv4MirrorAclTest()
        self.ipv6MirrorAclTest()
        self.udpMirrorAclTest()
        self.macMirrorAclTest()

    def tearDown(self):
        sai_thrift_remove_mirror_session(self.client, self.spanid)
        for vlan_port in list(self.vlan_ports):
            sai_thrift_set_port_attribute(
                self.client, vlan_port, port_vlan_id=int(SAI_NULL_OBJECT_ID))
            self.vlan_ports.remove(vlan_port)
        for vlan_member in list(self.vlan_members):
            sai_thrift_remove_vlan_member(self.client, vlan_member)
            self.vlan_members.remove(vlan_member)
        for vlan in list(self.vlans):
            sai_thrift_remove_vlan(self.client, vlan)
            self.vlans.remove(vlan)
        for bridge_port in self.bridge_ports:
            sai_thrift_remove_bridge_port(self.client, bridge_port)
            self.bridge_ports.remove(bridge_port)
        sai_thrift_remove_router_interface(self.client, self.rif_id)
        super(IPEthAclTest, self).tearDown()

    def noAclTest(self):
        """Tests routing without ACL"""
        print("Sending ARP packet - port 24 -> port 25 [access vlan=100])")
        print("Sending ARP packet - port 26 -> port 27 [access vlan=200])")
        # send & verify test packet(s) : ARP, IPX, IPv4, LLDP,
        # IPv6 without any ACL entries
        send_packet(self, self.dev_port24, self.arp_pkt)
        verify_packets(self, self.exp_arp_pkt, [self.dev_port25])
        send_packet(self, self.dev_port26, self.arp_pkt)
        verify_packets(self, self.exp_arp_pkt, [self.dev_port27])

        print("Sending IPX packet - port 24 -> port 25 [access vlan=100])")
        print("Sending IPX packet - port 26 -> port 27 [access vlan=200])")
        send_packet(self, self.dev_port24, self.ipx_pkt)
        verify_packets(self, self.exp_ipx_pkt, [self.dev_port25])
        send_packet(self, self.dev_port26, self.ipx_pkt)
        verify_packets(self, self.exp_ipx_pkt, [self.dev_port27])

        print("Sending IPv4 packet - port 24 -> port 25 [access vlan=100])")
        print("Sending IPv4 packet - port 26 -> port 27 [access vlan=200])")
        send_packet(self, self.dev_port24, self.ipv4_pkt)
        verify_packets(self, self.exp_ipv4_pkt, [self.dev_port25])
        send_packet(self, self.dev_port26, self.ipv4_pkt)
        verify_packets(self, self.exp_ipv4_pkt, [self.dev_port27])

        print("Sending LLDP packet - port 24 -> port 25 [access vlan=100])")
        print("Sending LLDP packet - port 26 -> port 27 [access vlan=200])")
        send_packet(self, self.dev_port24, self.lldp_pkt)
        verify_packets(self, self.exp_lldp_pkt, [self.dev_port25])
        send_packet(self, self.dev_port26, self.lldp_pkt)
        verify_packets(self, self.exp_lldp_pkt, [self.dev_port27])

        print("Sending IPv6/TCP(SRC_IP 2000::4) packet - port 24 -> "
              "port 25 [access vlan=100])")
        print("Sending IPv6/TCP(SRC_IP 2000::4) packet - port 26 -> "
              "port 27 [access vlan=200])")
        send_packet(self, self.dev_port24, self.tcpv6_pkt)
        verify_packets(self, self.exp_tcpv6_pkt, [self.dev_port25])
        send_packet(self, self.dev_port26, self.tcpv6_pkt)
        verify_packets(self, self.exp_tcpv6_pkt, [self.dev_port27])

        print("Sending IPv4/TCP packet(SRC_IP 172.0.0.17) - port 24 -> "
              "port 25 [access vlan=100])")
        print("Sending IPv4/TCP packet(SRC_IP 172.0.0.17) - port 26 -> "
              "port 27 [access vlan=200])")
        send_packet(self, self.dev_port24, self.tcpv4_pkt)
        verify_packets(self, self.exp_tcpv4_pkt, [self.dev_port25])
        send_packet(self, self.dev_port26, self.tcpv4_pkt)
        verify_packets(self, self.exp_tcpv4_pkt, [self.dev_port27])

        print("Sending IPv6/TCP packet(SRC_IP 3000::1) - port 24 -> "
              "port 25 [access vlan=100])")
        print("Sending IPv6/TCP packet(SRC_IP 3000::1) - port 26 -> "
              "port 27 [access vlan=200])")
        send_packet(self, self.dev_port24, self.tcpv6_pkt2)
        verify_packets(self, self.exp_tcpv6_pkt2, [self.dev_port25])
        send_packet(self, self.dev_port26, self.tcpv6_pkt2)
        verify_packets(self, self.exp_tcpv6_pkt2, [self.dev_port27])

        print("Sending IPv6/UDP packet - port 24 -> "
              "port 25 [access vlan=100])")
        print("Sending IPv6/UDP packet - port 26 -> "
              "port 27 [access vlan=200])")
        send_packet(self, self.dev_port24, self.udpv6_pkt)
        verify_packets(self, self.exp_udpv6_pkt, [self.dev_port25])
        send_packet(self, self.dev_port26, self.udpv6_pkt)
        verify_packets(self, self.exp_udpv6_pkt, [self.dev_port27])

        print("Sending IPv4/UDP packet - port 24 -> "
              "port 25 [access vlan=100])")
        print("Sending IPv4/UDP packet - port 26 -> "
              "port 27 [access vlan=200])")
        send_packet(self, self.dev_port24, self.udpv4_pkt)
        verify_packets(self, self.exp_udpv4_pkt, [self.dev_port25])
        send_packet(self, self.dev_port26, self.udpv4_pkt)
        verify_packets(self, self.exp_udpv4_pkt, [self.dev_port27])

        print("Sending EthType(0x1234) packet - port 24 -> "
              "port 25 [access vlan=100])")
        print("Sending EthType(0x1234) packet - port 26 -> "
              "port 27 [access vlan=200])")
        send_packet(self, self.dev_port24, self.mac_pkt)
        verify_packets(self, self.exp_mac_pkt, [self.dev_port25])
        send_packet(self, self.dev_port26, self.mac_pkt)
        verify_packets(self, self.exp_mac_pkt, [self.dev_port27])

        # Used for negative test cases verification
        print("Sending EthType(0x4321) packet - port 24 -> "
              "port 25 [access vlan=100])")
        print("Sending EthType(0x4321) packet - port 26 -> "
              "port 27 [access vlan=200])")
        send_packet(self, self.dev_port24, self.mac_pkt2)
        verify_packets(self, self.exp_mac_pkt2, [self.dev_port25])
        send_packet(self, self.dev_port26, self.mac_pkt2)
        verify_packets(self, self.exp_mac_pkt2, [self.dev_port27])

    def arpAclTest(self):
        """Tests ACL dropping ARP packets"""
        # Create ACL Table, Group and Rules
        stage = SAI_ACL_STAGE_INGRESS
        entry_priority = 1000
        action = SAI_PACKET_ACTION_DROP
        eth_type = 0x0806
        group_type = SAI_ACL_TABLE_GROUP_TYPE_PARALLEL

        packet_action = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                s32=action))

        table_bind_point_list = [SAI_ACL_BIND_POINT_TYPE_VLAN]
        table_bind_point_type_list = sai_thrift_s32_list_t(
            count=len(table_bind_point_list),
            int32list=table_bind_point_list)

        vlan_acl_table_group_id = sai_thrift_create_acl_table_group(
            self.client,
            acl_stage=stage,
            acl_bind_point_type_list=table_bind_point_type_list,
            type=group_type)
        self.acl_grps.append(vlan_acl_table_group_id)
        print("VLAN ACL Table Group created 0x%lx" % (
            vlan_acl_table_group_id))

        aclv4_table_id = sai_thrift_create_acl_table(
            self.client,
            acl_stage=stage,
            acl_bind_point_type_list=table_bind_point_type_list,
            field_ether_type=True)
        self.acl_tables.append(aclv4_table_id)
        print("IPv4 ACL Table created 0x%lx" % (aclv4_table_id))

        aclv4_table_group_member_id = \
            sai_thrift_create_acl_table_group_member(
                self.client,
                acl_table_group_id=vlan_acl_table_group_id,
                acl_table_id=aclv4_table_id,
                priority=100)
        self.acl_grp_members.append(aclv4_table_group_member_id)

        # Add ARP drop ACL entry to IPv4 ACL Table
        arp_acl_counter = sai_thrift_create_acl_counter(
            client=self.client, table_id=aclv4_table_id)
        action_counter_t = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=arp_acl_counter),
            enable=True)
        self.acl_counters.append(arp_acl_counter)

        ether_type = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(u16=eth_type),
            mask=sai_thrift_acl_field_data_mask_t(u16=32767))

        arp_drop_entry = sai_thrift_create_acl_entry(
            self.client,
            table_id=aclv4_table_id,
            priority=entry_priority,
            action_packet_action=packet_action,
            field_ether_type=ether_type,
            action_counter=action_counter_t)

        sai_thrift_set_acl_entry_attribute(
            self.client, arp_drop_entry,
            action_counter=action_counter_t)

        self.acl_rules.append(arp_drop_entry)
        print("ARP ACL DROP entry created 0x%lx" % (arp_drop_entry))

        print("Binding ACL grp 0x%lx to Vlan100" % (vlan_acl_table_group_id))
        # bind ACL GRP to VLAN 100
        sai_thrift_set_vlan_attribute(self.client,
                                      vlan_oid=self.vlans[0],
                                      ingress_acl=vlan_acl_table_group_id)
        self.bp_list.append(self.vlans[0])

        # Initialize Counters
        counter = sai_thrift_get_acl_counter_attribute(
            client=self.client,
            acl_counter_oid=arp_acl_counter,
            packets=True)
        self.exp_counters["arp"] = counter["packets"]

        print("Sending Packets matching ACL rules on VLAN100. "
              "Packets should be dropped")
        print("Sending ARP packet - port 24 -> port 25 [access vlan=100])")
        send_packet(self, self.dev_port24, self.arp_pkt)
        verify_no_other_packets(self, timeout=1)
        self.exp_counters["arp"] += 1

        # Verifying ACL counters
        print("Verifying ACL counters")
        time.sleep(10)
        counter = sai_thrift_get_acl_counter_attribute(
            client=self.client,
            acl_counter_oid=arp_acl_counter,
            packets=True)
        self.assertTrue(self.exp_counters["arp"] == counter["packets"],
                        "ARP ACL DROP Counter Mismatch")

        print("Sending Packets matching ACL rules on VLAN200. "
              "Packets should not be dropped")
        print("Sending ARP packet - port 26 -> port 27 [access vlan=200])")
        send_packet(self, self.dev_port26, self.arp_pkt)
        verify_packets(self, self.exp_arp_pkt, [self.dev_port27])

        self.trapAclCleanup()

        print("Verifying ACL rules were correctly removed")
        print("Sending Packets matching ACL rules on VLAN100. "
              "Packets should not be dropped")
        print("Sending ARP packet - port 24 -> port 25 [access vlan=100])")
        send_packet(self, self.dev_port24, self.arp_pkt)
        verify_packets(self, self.exp_arp_pkt, [self.dev_port25])

        print("Sending Packets matching ACL rules on VLAN200. "
              "Packets should not be dropped")
        print("Sending ARP packet - port 26 -> port 27 [access vlan=200])")
        send_packet(self, self.dev_port26, self.arp_pkt)
        verify_packets(self, self.exp_arp_pkt, [self.dev_port27])

    def ipxAclTest(self):
        """Tests ACL dropping IPX packets"""
        # Create ACL Table, Group and Rules
        stage = SAI_ACL_STAGE_INGRESS
        entry_priority = 1000
        action = SAI_PACKET_ACTION_DROP
        group_type = SAI_ACL_TABLE_GROUP_TYPE_PARALLEL

        packet_action = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                s32=action))

        table_bind_point_list = [SAI_ACL_BIND_POINT_TYPE_VLAN]
        table_bind_point_type_list = sai_thrift_s32_list_t(
            count=len(table_bind_point_list),
            int32list=table_bind_point_list)

        vlan_acl_table_group_id = sai_thrift_create_acl_table_group(
            self.client,
            acl_stage=stage,
            acl_bind_point_type_list=table_bind_point_type_list,
            type=group_type)
        self.acl_grps.append(vlan_acl_table_group_id)
        print("VLAN ACL Table Group created 0x%lx" % (
            vlan_acl_table_group_id))

        aclv4_table_id = sai_thrift_create_acl_table(
            self.client,
            acl_stage=stage,
            acl_bind_point_type_list=table_bind_point_type_list,
            field_ether_type=True)
        self.acl_tables.append(aclv4_table_id)
        print("IPv4 ACL Table created 0x%lx" % (aclv4_table_id))

        aclv4_table_group_member_id = \
            sai_thrift_create_acl_table_group_member(
                self.client,
                acl_table_group_id=vlan_acl_table_group_id,
                acl_table_id=aclv4_table_id,
                priority=100)
        self.acl_grp_members.append(aclv4_table_group_member_id)

        if entry_priority >= 1:
            entry_priority -= 1

        # Add IPX drop ACL entry to IPv4 ACL Table
        ipx_acl_counter = sai_thrift_create_acl_counter(
            client=self.client, table_id=aclv4_table_id)
        action_counter_t = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=ipx_acl_counter),
            enable=True)
        self.acl_counters.append(ipx_acl_counter)

        eth_type = 0x8137
        if eth_type > 0x7fff:
            eth_type -= 0x10000

        ether_type = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(u16=eth_type),
            mask=sai_thrift_acl_field_data_mask_t(u16=32767))

        ipx_drop_entry = sai_thrift_create_acl_entry(
            self.client,
            table_id=aclv4_table_id,
            priority=entry_priority,
            action_packet_action=packet_action,
            field_ether_type=ether_type,
            action_counter=action_counter_t)

        sai_thrift_set_acl_entry_attribute(
            self.client, ipx_drop_entry,
            action_counter=action_counter_t)

        self.acl_rules.append(ipx_drop_entry)
        print("IPX ACL DROP entry created 0x%lx" % (ipx_drop_entry))

        print("Binding ACL grp 0x%lx to Vlan100" % (vlan_acl_table_group_id))
        # bind ACL GRP to VLAN 100
        sai_thrift_set_vlan_attribute(self.client,
                                      vlan_oid=self.vlans[0],
                                      ingress_acl=vlan_acl_table_group_id)
        self.bp_list.append(self.vlans[0])

        # Initialize Counters
        counter = sai_thrift_get_acl_counter_attribute(
            client=self.client,
            acl_counter_oid=ipx_acl_counter,
            packets=True)
        self.exp_counters["ipx"] = counter["packets"]

        print("Sending Packets matching ACL rules on VLAN100. "
              "Packets should be dropped")
        print("Sending IPX packet - port 24 -> port 25 [access vlan=100])")
        send_packet(self, self.dev_port24, self.ipx_pkt)
        verify_no_other_packets(self, timeout=1)
        self.exp_counters["ipx"] += 1

        # Verifying ACL counters
        print("Verifying ACL counters")
        time.sleep(10)
        counter = sai_thrift_get_acl_counter_attribute(
            client=self.client,
            acl_counter_oid=ipx_acl_counter,
            packets=True)
        self.assertTrue(self.exp_counters["ipx"] == counter["packets"],
                        "IPX ACL DROP Counter Mismatch")

        print("Sending Packets matching ACL rules on VLAN200. "
              "Packets should not be dropped")
        print("Sending IPX packet - port 26 -> port 27 [access vlan=200])")
        send_packet(self, self.dev_port26, self.ipx_pkt)
        verify_packets(self, self.exp_ipx_pkt, [self.dev_port27])

        self.trapAclCleanup()

        print("Verifying ACL rules were correctly removed")
        print("Sending Packets matching ACL rules on VLAN100. "
              "Packets should not be dropped")
        print("Sending IPX packet - port 24 -> port 25 [access vlan=100])")
        send_packet(self, self.dev_port24, self.ipx_pkt)
        verify_packets(self, self.exp_ipx_pkt, [self.dev_port25])

        print("Sending Packets matching ACL rules on VLAN200. "
              "Packets should not be dropped")
        print("Sending IPX packet - port 26 -> port 27 [access vlan=200])")
        send_packet(self, self.dev_port26, self.ipx_pkt)
        verify_packets(self, self.exp_ipx_pkt, [self.dev_port27])

    def ipv4AclTest(self):
        """Tests ACL dropping all packets with IPv4 address"""
        # Create ACL Table, Group and Rules
        stage = SAI_ACL_STAGE_INGRESS
        entry_priority = 1000
        action = SAI_PACKET_ACTION_DROP
        group_type = SAI_ACL_TABLE_GROUP_TYPE_PARALLEL

        packet_action = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                s32=action))

        table_bind_point_list = [SAI_ACL_BIND_POINT_TYPE_VLAN]
        table_bind_point_type_list = sai_thrift_s32_list_t(
            count=len(table_bind_point_list),
            int32list=table_bind_point_list)

        vlan_acl_table_group_id = sai_thrift_create_acl_table_group(
            self.client,
            acl_stage=stage,
            acl_bind_point_type_list=table_bind_point_type_list,
            type=group_type)
        self.acl_grps.append(vlan_acl_table_group_id)
        print("VLAN ACL Table Group created 0x%lx" % (
            vlan_acl_table_group_id))

        aclv4_table_id = sai_thrift_create_acl_table(
            self.client,
            acl_stage=stage,
            acl_bind_point_type_list=table_bind_point_type_list,
            field_ether_type=True)
        self.acl_tables.append(aclv4_table_id)
        print("IPv4 ACL Table created 0x%lx" % (aclv4_table_id))

        aclv4_table_group_member_id = \
            sai_thrift_create_acl_table_group_member(
                self.client,
                acl_table_group_id=vlan_acl_table_group_id,
                acl_table_id=aclv4_table_id,
                priority=100)
        self.acl_grp_members.append(aclv4_table_group_member_id)

        if entry_priority >= 1:
            entry_priority -= 1

        ipv4_acl_counter = sai_thrift_create_acl_counter(
            client=self.client, table_id=aclv4_table_id)
        action_counter_t = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=ipv4_acl_counter),
            enable=True)
        self.acl_counters.append(ipv4_acl_counter)

        eth_type = 0x0800
        if eth_type > 0x7fff:
            eth_type -= 0x10000

        ether_type = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(u16=eth_type),
            mask=sai_thrift_acl_field_data_mask_t(u16=32767))

        ipv4_drop_entry = sai_thrift_create_acl_entry(
            self.client,
            table_id=aclv4_table_id,
            priority=entry_priority,
            action_packet_action=packet_action,
            field_ether_type=ether_type,
            action_counter=action_counter_t)

        sai_thrift_set_acl_entry_attribute(
            self.client, ipv4_drop_entry,
            action_counter=action_counter_t)

        self.acl_rules.append(ipv4_drop_entry)
        print("IPv4 ACL DROP (catch all) entry created 0x%lx" % (
            ipv4_drop_entry))

        print("Binding ACL grp 0x%lx to Vlan100" % (vlan_acl_table_group_id))
        # bind ACL GRP to VLAN 100
        sai_thrift_set_vlan_attribute(self.client,
                                      vlan_oid=self.vlans[0],
                                      ingress_acl=vlan_acl_table_group_id)
        self.bp_list.append(self.vlans[0])

        # Initialize Counters
        counter = sai_thrift_get_acl_counter_attribute(
            client=self.client,
            acl_counter_oid=ipv4_acl_counter,
            packets=True)
        self.exp_counters["ipv4"] = counter["packets"]

        print("Sending Packets matching ACL rules on VLAN100. "
              "Packets should be dropped")
        print("Sending IPv4 packet - port 24 -> port 25 [access vlan=100])")
        send_packet(self, self.dev_port24, self.ipv4_pkt)
        verify_no_other_packets(self, timeout=1)
        self.exp_counters["ipv4"] += 1

        # Verifying ACL counters
        print("Verifying ACL counters")
        time.sleep(10)
        counter = sai_thrift_get_acl_counter_attribute(
            client=self.client,
            acl_counter_oid=ipv4_acl_counter,
            packets=True)
        self.assertTrue(self.exp_counters["ipv4"] == counter["packets"],
                        "IPv4 ACL DROP Counter Mismatch")

        print("Sending Packets matching ACL rules on VLAN200. "
              "Packets should not be dropped")
        print("Sending IPv4 packet - port 26 -> port 27 [access vlan=200])")
        send_packet(self, self.dev_port26, self.ipv4_pkt)
        verify_packets(self, self.exp_ipv4_pkt, [self.dev_port27])

        self.trapAclCleanup()

        print("Verifying ACL rules were correctly removed")
        print("Sending Packets matching ACL rules on VLAN100. "
              "Packets should not be dropped")
        print("Sending IPv4 packet - port 24 -> port 25 [access vlan=100])")
        send_packet(self, self.dev_port24, self.ipv4_pkt)
        verify_packets(self, self.exp_ipv4_pkt, [self.dev_port25])

        print("Sending Packets matching ACL rules on VLAN200. "
              "Packets should not be dropped")
        print("Sending IPv4 packet - port 26 -> port 27 [access vlan=200])")
        send_packet(self, self.dev_port26, self.ipv4_pkt)
        verify_packets(self, self.exp_ipv4_pkt, [self.dev_port27])

    def lldpAclTest(self):
        """Tests ACL dropping LLDP packets"""
        # Create ACL Table, Group and Rules
        stage = SAI_ACL_STAGE_INGRESS
        entry_priority = 1000
        action = SAI_PACKET_ACTION_DROP
        group_type = SAI_ACL_TABLE_GROUP_TYPE_PARALLEL

        packet_action = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                s32=action))

        table_bind_point_list = [SAI_ACL_BIND_POINT_TYPE_VLAN]
        table_bind_point_type_list = sai_thrift_s32_list_t(
            count=len(table_bind_point_list),
            int32list=table_bind_point_list)

        vlan_acl_table_group_id = sai_thrift_create_acl_table_group(
            self.client,
            acl_stage=stage,
            acl_bind_point_type_list=table_bind_point_type_list,
            type=group_type)
        self.acl_grps.append(vlan_acl_table_group_id)
        print("VLAN ACL Table Group created 0x%lx" % (
            vlan_acl_table_group_id))

        aclv6_table_id = sai_thrift_create_acl_table(
            self.client,
            acl_stage=stage,
            acl_bind_point_type_list=table_bind_point_type_list,
            field_ether_type=True,)
        self.acl_tables.append(aclv6_table_id)
        print("IPv6 ACL Table created 0x%lx" % (aclv6_table_id))

        aclv6_table_group_member_id = \
            sai_thrift_create_acl_table_group_member(
                self.client,
                acl_table_group_id=vlan_acl_table_group_id,
                acl_table_id=aclv6_table_id,
                priority=200)
        self.acl_grp_members.append(aclv6_table_group_member_id)

        if entry_priority >= 1:
            entry_priority -= 1

        # Add LLDP drop ACL entry to IPv6 ACL Table
        lldp_acl_counter = sai_thrift_create_acl_counter(
            client=self.client, table_id=aclv6_table_id)
        action_counter_t = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=lldp_acl_counter),
            enable=True)
        self.acl_counters.append(lldp_acl_counter)

        eth_type = 0x88cc
        if eth_type > 0x7fff:
            eth_type -= 0x10000

        ether_type = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(u16=eth_type),
            mask=sai_thrift_acl_field_data_mask_t(u16=32767))

        lldp_drop_entry = sai_thrift_create_acl_entry(
            self.client,
            table_id=aclv6_table_id,
            priority=entry_priority,
            action_packet_action=packet_action,
            field_ether_type=ether_type,
            action_counter=action_counter_t)

        sai_thrift_set_acl_entry_attribute(
            self.client, lldp_drop_entry,
            action_counter=action_counter_t)

        self.acl_rules.append(lldp_drop_entry)
        print("Installing user-acl-rule to drop LLDP 0x%lx" % (
            lldp_drop_entry))

        print("Binding ACL grp 0x%lx to Vlan100" % (vlan_acl_table_group_id))
        # bind ACL GRP to VLAN 100
        sai_thrift_set_vlan_attribute(self.client,
                                      vlan_oid=self.vlans[0],
                                      ingress_acl=vlan_acl_table_group_id)
        self.bp_list.append(self.vlans[0])

        # Create LLDP trap entry
        lldp_trap = sai_thrift_create_hostif_trap(
            client=self.client,
            trap_type=SAI_HOSTIF_TRAP_TYPE_LLDP,
            packet_action=SAI_PACKET_ACTION_TRAP)
        self.traps.append(lldp_trap)
        print("Installing LLDP hostif trap rule 0x%lx" % (lldp_trap))

        # Initialize Counters
        counter = sai_thrift_get_acl_counter_attribute(
            client=self.client,
            acl_counter_oid=lldp_acl_counter,
            packets=True)
        self.exp_counters["lldp"] = counter["packets"]

        print("Sending Packets matching ACL rules on VLAN100. "
              "Packets should be dropped")
        # User ACL entries will have higher priority
        # than hostif trap entries
        print("Have Hostif entry to trap LLDP, have User-acl to drop "
              "LLDP ingressing on port 1")
        print("User-acl entry must take priority over hostif entry")
        print("TX LLDP packet - port 24 -> drop")
        send_packet(self, self.dev_port24, self.lldp_pkt)
        verify_no_other_packets(self, timeout=1)
        self.exp_counters["lldp"] += 1

        # Verifying ACL counters
        print("Verifying ACL counters")
        time.sleep(10)
        counter = sai_thrift_get_acl_counter_attribute(
            client=self.client,
            acl_counter_oid=lldp_acl_counter,
            packets=True)
        self.assertTrue(self.exp_counters["lldp"] == counter["packets"],
                        "LLDP ACL DROP Counter Mismatch")

        # This packet will be trapped to the cpu
        pre_stats = sai_thrift_get_queue_stats(
            self.client, self.cpu_queue0)
        print("Sending Packets matching ACL rules on VLAN200. "
              "Packets should not be dropped")
        print("Sending LLDP packet - port 26 -> port 27 [access vlan=200])")
        send_packet(self, self.dev_port26, self.lldp_pkt)
        time.sleep(10)
        post_stats = sai_thrift_get_queue_stats(
            self.client, self.cpu_queue0)
        self.assertEqual(
            post_stats["SAI_QUEUE_STAT_PACKETS"],
            pre_stats["SAI_QUEUE_STAT_PACKETS"] + 1)

        self.trapAclCleanup()

        print("Verifying ACL rules were correctly removed")
        print("Sending Packets matching ACL rules on VLAN100. "
              "Packets should not be dropped")
        print("Sending LLDP packet - port 24 -> port 25 [access vlan=100])")
        send_packet(self, self.dev_port24, self.lldp_pkt)
        verify_packets(self, self.exp_lldp_pkt, [self.dev_port25])

        print("Sending Packets matching ACL rules on VLAN200. "
              "Packets should not be dropped")
        print("Sending LLDP packet - port 26 -> port 27 [access vlan=200])")
        send_packet(self, self.dev_port26, self.lldp_pkt)
        verify_packets(self, self.exp_lldp_pkt, [self.dev_port27])

    def ipv6AclTest(self):
        """Tests ACL dropping all packets with IPv6 address"""
        # Create ACL Table, Group and Rules
        stage = SAI_ACL_STAGE_INGRESS
        entry_priority = 1000
        action = SAI_PACKET_ACTION_DROP
        group_type = SAI_ACL_TABLE_GROUP_TYPE_PARALLEL

        packet_action = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                s32=action))

        table_bind_point_list = [SAI_ACL_BIND_POINT_TYPE_VLAN]
        table_bind_point_type_list = sai_thrift_s32_list_t(
            count=len(table_bind_point_list),
            int32list=table_bind_point_list)

        vlan_acl_table_group_id = sai_thrift_create_acl_table_group(
            self.client,
            acl_stage=stage,
            acl_bind_point_type_list=table_bind_point_type_list,
            type=group_type)
        self.acl_grps.append(vlan_acl_table_group_id)
        print("VLAN ACL Table Group created 0x%lx" % (
            vlan_acl_table_group_id))

        aclv6_table_id = sai_thrift_create_acl_table(
            self.client,
            acl_stage=stage,
            acl_bind_point_type_list=table_bind_point_type_list,
            field_src_ipv6=True,
            field_ether_type=True)
        self.acl_tables.append(aclv6_table_id)
        print("IPv6 ACL Table created 0x%lx" % (aclv6_table_id))

        aclv6_table_group_member_id = \
            sai_thrift_create_acl_table_group_member(
                self.client,
                acl_table_group_id=vlan_acl_table_group_id,
                acl_table_id=aclv6_table_id,
                priority=200)
        self.acl_grp_members.append(aclv6_table_group_member_id)

        if entry_priority >= 1:
            entry_priority -= 1

        # Add IPv6 drop ACL entry based on SRC_IPv6 Addr to IPv6 ACL Table
        ipv6_acl_counter = sai_thrift_create_acl_counter(
            client=self.client, table_id=aclv6_table_id)
        action_counter_t = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=ipv6_acl_counter),
            enable=True)
        self.acl_counters.append(ipv6_acl_counter)

        ip_src = "2000::1"
        ip_src_mask = "ffff:ffff:ffff:ffff:ffff:ffff:ffff:0"
        src_ip_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(ip6=ip_src),
            mask=sai_thrift_acl_field_data_mask_t(ip6=ip_src_mask))

        eth_type = 0x86dd
        if eth_type > 0x7fff:
            eth_type -= 0x10000

        ether_type = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(u16=eth_type),
            mask=sai_thrift_acl_field_data_mask_t(u16=32767))

        ipv6_drop_entry = sai_thrift_create_acl_entry(
            self.client,
            table_id=aclv6_table_id,
            priority=entry_priority,
            field_src_ipv6=src_ip_t,
            action_packet_action=packet_action,
            field_ether_type=ether_type,
            action_counter=action_counter_t)

        sai_thrift_set_acl_entry_attribute(
            self.client, ipv6_drop_entry,
            action_counter=action_counter_t)
        self.acl_rules.append(ipv6_drop_entry)
        print("IPv6 ACL DROP entry created for SRC_IP:2000::0:x 0x%lx" % (
            ipv6_drop_entry))

        print("Binding ACL grp 0x%lx to Vlan100" % (vlan_acl_table_group_id))
        # bind ACL GRP to VLAN 100
        sai_thrift_set_vlan_attribute(self.client,
                                      vlan_oid=self.vlans[0],
                                      ingress_acl=vlan_acl_table_group_id)
        self.bp_list.append(self.vlans[0])

        # Initialize Counters
        counter = sai_thrift_get_acl_counter_attribute(
            client=self.client,
            acl_counter_oid=ipv6_acl_counter,
            packets=True)
        self.exp_counters["ipv6"] = counter["packets"]

        print("Sending Packets matching ACL rules on VLAN100. "
              "Packets should be dropped")
        print("Sending TCPv6 packet - port 24 -> port 25 [access vlan=100])")
        send_packet(self, self.dev_port24, self.tcpv6_pkt)
        verify_no_other_packets(self, timeout=1)
        self.exp_counters["ipv6"] += 1

        # Verifying ACL counters
        print("Verifying ACL counters")
        time.sleep(10)
        counter = sai_thrift_get_acl_counter_attribute(
            client=self.client,
            acl_counter_oid=ipv6_acl_counter,
            packets=True)
        self.assertTrue(self.exp_counters["ipv6"] == counter["packets"],
                        "IPv6 SRC_IP ACL DROP Counter Mismatch")

        print("Sending Packets matching ACL rules on VLAN200. "
              "Packets should not be dropped")
        print("Sending TCPv6 packet - port 26 -> port 27 [access vlan=200])")
        send_packet(self, self.dev_port26, self.tcpv6_pkt)
        verify_packets(self, self.exp_tcpv6_pkt, [self.dev_port27])

        self.trapAclCleanup()

        print("Verifying ACL rules were correctly removed")
        print("Sending TCPv6 packet - port 24 -> port 25 [access vlan=100])")
        send_packet(self, self.dev_port24, self.tcpv6_pkt)
        verify_packets(self, self.exp_tcpv6_pkt, [self.dev_port25])

        print("Sending Packets matching ACL rules on VLAN200. "
              "Packets should not be dropped")
        print("Sending TCPv6 packet - port 26 -> port 27 [access vlan=200])")
        send_packet(self, self.dev_port26, self.tcpv6_pkt)
        verify_packets(self, self.exp_tcpv6_pkt, [self.dev_port27])

    def ipv4MirrorAclTest(self):
        """Tests ACL mirroring based on IPv4 address"""
        # Create ACL Table, Group and Rules
        stage = SAI_ACL_STAGE_INGRESS
        entry_priority = 1000
        group_type = SAI_ACL_TABLE_GROUP_TYPE_PARALLEL

        table_bind_point_list = [SAI_ACL_BIND_POINT_TYPE_PORT]
        table_bind_point_type_list = sai_thrift_s32_list_t(
            count=len(table_bind_point_list),
            int32list=table_bind_point_list)

        port_acl_table_group_id = sai_thrift_create_acl_table_group(
            self.client,
            acl_stage=stage,
            acl_bind_point_type_list=table_bind_point_type_list,
            type=group_type)
        self.acl_grps.append(port_acl_table_group_id)
        print("VLAN ACL Table Group created 0x%lx" % (
            port_acl_table_group_id))

        if entry_priority >= 1:
            entry_priority -= 1

        # Create Mirror ACL table
        ip_src = "172.0.0.17"
        ip_src_mask = "255.255.255.255"
        src_ip_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(ip4=ip_src),
            mask=sai_thrift_acl_field_data_mask_t(ip4=ip_src_mask))

        table_bind_point_list = [SAI_ACL_BIND_POINT_TYPE_PORT]
        table_bind_point_type_list = sai_thrift_s32_list_t(
            count=len(table_bind_point_list),
            int32list=table_bind_point_list)

        field_dscp = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(u8=1))

        mirror_table_id = sai_thrift_create_acl_table(
            self.client,
            acl_stage=stage,
            acl_bind_point_type_list=table_bind_point_type_list,
            field_dscp=True,
            field_src_ip=True)
        self.acl_tables.append(mirror_table_id)

        mirror_table_group_member_id = \
            sai_thrift_create_acl_table_group_member(
                self.client,
                acl_table_group_id=port_acl_table_group_id,
                acl_table_id=mirror_table_id,
                priority=300)
        self.acl_grp_members.append(mirror_table_group_member_id)

        # Add IPV4 SRC IP Mirror ACL entry to Mirror ACL Table
        v4src_mirror_acl_counter = sai_thrift_create_acl_counter(
            client=self.client, table_id=mirror_table_id)
        action_counter_t = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=v4src_mirror_acl_counter),
            enable=True)
        self.acl_counters.append(v4src_mirror_acl_counter)

        v4src_mirror_entry = sai_thrift_create_acl_entry(
            self.client,
            table_id=mirror_table_id,
            priority=entry_priority,
            field_src_ip=src_ip_t,
            action_mirror_ingress=self.mirror_action,
            action_counter=action_counter_t,
            field_dscp=field_dscp)
        self.acl_rules.append(v4src_mirror_entry)
        print("v4src ACL Mirror entry created 0x%lx" % (v4src_mirror_entry))

        print("Binding ACL grp 0x%lx to Port3" % (port_acl_table_group_id))
        # bind ACL GRP to VLAN 100
        sai_thrift_set_port_attribute(
            self.client, self.port26, ingress_acl=port_acl_table_group_id)
        self.bp_list.append(self.port26)

        # Initialize Counters
        counter = sai_thrift_get_acl_counter_attribute(
            client=self.client,
            acl_counter_oid=v4src_mirror_acl_counter,
            packets=True)
        self.exp_counters["mirror_ip4"] = counter["packets"]

        print("Sending Packets matching Mirror ACL rules on Port26. "
              "Packets should be mirrored")
        print("Sending TCPv4 (SRC IP 172.0.0.17) packet - port 26 -> "
              "port 27 [access vlan=200])")
        send_packet(self, self.dev_port26, self.tcpv4_pkt)
        verify_packets(self, self.exp_tcpv4_pkt, [self.dev_port27,
                                                  self.dev_port28])
        self.exp_counters["mirror_ip4"] += 1

        # Verifying ACL counters
        print("Verifying ACL counters")
        time.sleep(10)
        counter = sai_thrift_get_acl_counter_attribute(
            client=self.client,
            acl_counter_oid=v4src_mirror_acl_counter,
            packets=True)
        self.assertTrue(self.exp_counters["mirror_ip4"] == counter["packets"],
                        "IPv4 SRC_IP ACL Mirror Counter Mismatch")

        self.trapAclCleanup()

        print("Sending Packets matching Mirror ACL rules on Port26. "
              "Packets should not be mirrored")
        print("Sending TCPv4 (SRC IP 172.0.0.17) packet - port 26 -> "
              "port 4 [access vlan=200])")
        send_packet(self, self.dev_port26, self.tcpv4_pkt)
        verify_packets(self, self.exp_tcpv4_pkt, [self.dev_port27])

    def ipv6MirrorAclTest(self):
        """Tests ACL mirroring based on IPv6 address"""
        # Create ACL Table, Group and Rules
        stage = SAI_ACL_STAGE_INGRESS
        entry_priority = 1000
        group_type = SAI_ACL_TABLE_GROUP_TYPE_PARALLEL

        table_bind_point_list = [SAI_ACL_BIND_POINT_TYPE_PORT]
        table_bind_point_type_list = sai_thrift_s32_list_t(
            count=len(table_bind_point_list),
            int32list=table_bind_point_list)

        port_acl_table_group_id = sai_thrift_create_acl_table_group(
            self.client,
            acl_stage=stage,
            acl_bind_point_type_list=table_bind_point_type_list,
            type=group_type)
        self.acl_grps.append(port_acl_table_group_id)
        print("VLAN ACL Table Group created 0x%lx" % (
            port_acl_table_group_id))

        # Create Mirror ACL table
        field_dscp = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(u8=1))

        mirror_table_id = sai_thrift_create_acl_table(
            self.client,
            acl_stage=stage,
            acl_bind_point_type_list=table_bind_point_type_list,
            field_dscp=True,
            field_src_ipv6=True)
        self.acl_tables.append(mirror_table_id)

        mirror_table_group_member_id = \
            sai_thrift_create_acl_table_group_member(
                self.client,
                acl_table_group_id=port_acl_table_group_id,
                acl_table_id=mirror_table_id,
                priority=300)
        self.acl_grp_members.append(mirror_table_group_member_id)

        if entry_priority >= 1:
            entry_priority -= 1

        # Add IPV6 SRC IP Mirror ACL entry to Mirror ACL Table
        v6src_mirror_acl_counter = sai_thrift_create_acl_counter(
            client=self.client, table_id=mirror_table_id)
        action_counter_t = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=v6src_mirror_acl_counter),
            enable=True)
        self.acl_counters.append(v6src_mirror_acl_counter)

        ip_src = "3000::1"
        ip_src_mask = "ffff:ffff:ffff:ffff:ffff:ffff:ffff:0"
        src_ip_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(ip6=ip_src),
            mask=sai_thrift_acl_field_data_mask_t(ip6=ip_src_mask))

        v6src_mirror_entry = sai_thrift_create_acl_entry(
            self.client,
            table_id=mirror_table_id,
            priority=entry_priority,
            field_src_ipv6=src_ip_t,
            action_mirror_ingress=self.mirror_action,
            action_counter=action_counter_t,
            field_dscp=field_dscp)
        self.acl_rules.append(v6src_mirror_entry)
        print("v6src ACL Mirror entry created 0x%lx" % (v6src_mirror_entry))

        print("Binding ACL grp 0x%lx to Port26" % (port_acl_table_group_id))
        # bind ACL GRP to VLAN 100
        sai_thrift_set_port_attribute(
            self.client, self.port26, ingress_acl=port_acl_table_group_id)
        self.bp_list.append(self.port26)

        counter = sai_thrift_get_acl_counter_attribute(
            client=self.client,
            acl_counter_oid=v6src_mirror_acl_counter,
            packets=True)
        self.exp_counters["mirror_ip6"] = counter["packets"]

        print("Sending Packets matching Mirror ACL rules on Port26. "
              "Packets should be mirrored")
        print("Sending TCPv6 (SRC IP 3000::1) packet - port 26 -> port 27 "
              "[access vlan=200])")
        send_packet(self, self.dev_port26, self.tcpv6_pkt2)
        verify_packets(self, self.exp_tcpv6_pkt2, [self.dev_port27,
                                                   self.dev_port28])
        self.exp_counters["mirror_ip6"] += 1

        # Verifying ACL counters
        print("Verifying ACL counters")
        time.sleep(10)
        counter = sai_thrift_get_acl_counter_attribute(
            client=self.client,
            acl_counter_oid=v6src_mirror_acl_counter,
            packets=True)
        self.assertTrue(self.exp_counters["mirror_ip6"] == counter["packets"],
                        "IPv6 SRC_IP ACL Mirror Counter Mismatch")

        self.trapAclCleanup()

        print("Sending Packets matching Mirror ACL rules on Port26. "
              "Packets should not be mirrored")
        print("Sending TCPv6 (SRC IP 3000::1) packet - port 26 -> port 27 "
              "[access vlan=200])")
        send_packet(self, self.dev_port26, self.tcpv6_pkt2)
        verify_packets(self, self.exp_tcpv6_pkt2, [self.dev_port27])

    def udpMirrorAclTest(self):
        """Tests mirroring UDP packets"""
        # Create ACL Table, Group and Rules
        stage = SAI_ACL_STAGE_INGRESS
        entry_priority = 1000
        group_type = SAI_ACL_TABLE_GROUP_TYPE_PARALLEL

        table_bind_point_list = [SAI_ACL_BIND_POINT_TYPE_PORT]
        table_bind_point_type_list = sai_thrift_s32_list_t(
            count=len(table_bind_point_list),
            int32list=table_bind_point_list)

        port_acl_table_group_id = sai_thrift_create_acl_table_group(
            self.client,
            acl_stage=stage,
            acl_bind_point_type_list=table_bind_point_type_list,
            type=group_type)
        self.acl_grps.append(port_acl_table_group_id)
        print("VLAN ACL Table Group created 0x%lx" % (
            port_acl_table_group_id))

        # Create Mirror ACL table
        field_dscp = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(u8=1))

        mirror_table_id = sai_thrift_create_acl_table(
            self.client,
            acl_stage=stage,
            acl_bind_point_type_list=table_bind_point_type_list,
            field_dscp=True)
        self.acl_tables.append(mirror_table_id)

        mirror_table_group_member_id = \
            sai_thrift_create_acl_table_group_member(
                self.client,
                acl_table_group_id=port_acl_table_group_id,
                acl_table_id=mirror_table_id,
                priority=300)
        self.acl_grp_members.append(mirror_table_group_member_id)

        if entry_priority >= 1:
            entry_priority -= 1

        # Add UDP (IPv4/IPv6 common) ACL entry to Mirror ACL Table
        udp_mirror_acl_counter = sai_thrift_create_acl_counter(
            client=self.client, table_id=mirror_table_id)
        action_counter_t = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=udp_mirror_acl_counter),
            enable=True)
        self.acl_counters.append(udp_mirror_acl_counter)

        ip_protocol = sai_thrift_acl_field_data_t(
            enable=True,
            data=sai_thrift_acl_field_data_data_t(u8=17),
            mask=sai_thrift_acl_field_data_mask_t(u8=127))

        udp_mirror_entry = sai_thrift_create_acl_entry(
            self.client,
            table_id=mirror_table_id,
            priority=entry_priority,
            field_ip_protocol=ip_protocol,
            action_mirror_ingress=self.mirror_action,
            action_counter=action_counter_t,
            field_dscp=field_dscp)
        self.acl_rules.append(udp_mirror_entry)
        print("TCP ACL Mirror entry created 0x%lx" % (udp_mirror_entry))

        print("Binding ACL grp 0x%lx to Port26" % (port_acl_table_group_id))
        # bind ACL GRP to VLAN 100
        sai_thrift_set_port_attribute(
            self.client, self.port26, ingress_acl=port_acl_table_group_id)
        self.bp_list.append(self.port26)

        counter = sai_thrift_get_acl_counter_attribute(
            client=self.client,
            acl_counter_oid=udp_mirror_acl_counter,
            packets=True)
        self.exp_counters["mirror_udp"] = counter["packets"]

        print("Sending Packets matching Mirror ACL rules on Port3. "
              "Packets should be mirrored")
        print("Sending UDPv6  packet - port 26 -> port 27 "
              "[access vlan=200])")
        send_packet(self, self.dev_port26, self.udpv6_pkt)
        verify_packets(self, self.exp_udpv6_pkt, [self.dev_port27,
                                                  self.dev_port28])
        self.exp_counters["mirror_udp"] += 1

        print("Sending UDPv4  packet - port 26 -> port 27 "
              "[access vlan=200])")
        send_packet(self, self.dev_port26, self.udpv4_pkt)
        verify_packets(self, self.exp_udpv4_pkt, [self.dev_port27,
                                                  self.dev_port28])
        self.exp_counters["mirror_udp"] += 1

        # Verifying ACL counters
        print("Verifying ACL counters")
        time.sleep(10)
        counter = sai_thrift_get_acl_counter_attribute(
            client=self.client,
            acl_counter_oid=udp_mirror_acl_counter,
            packets=True)
        self.assertTrue(self.exp_counters["mirror_udp"] == counter["packets"],
                        "UDP ACL Mirror Counter Mismatch")

        self.trapAclCleanup()

        print("Sending Packets matching Mirror ACL rules on Port26. "
              "Packets should not be mirrored")
        print("Sending UDPv6  packet - port 26 -> port 27 "
              "[access vlan=200])")
        send_packet(self, self.dev_port26, self.udpv6_pkt)
        verify_packets(self, self.exp_udpv6_pkt, [self.dev_port27])

        print("Sending UDPv4  packet - port 26 -> port 27 "
              "[access vlan=200])")
        send_packet(self, self.dev_port26, self.udpv4_pkt)
        verify_packets(self, self.exp_udpv4_pkt, [self.dev_port27])

    def macMirrorAclTest(self):
        """Tests mirroring MAC packets"""
        # Create ACL Table, Group and Rules
        stage = SAI_ACL_STAGE_INGRESS
        entry_priority = 1000
        group_type = SAI_ACL_TABLE_GROUP_TYPE_PARALLEL

        table_bind_point_list = [SAI_ACL_BIND_POINT_TYPE_PORT]
        table_bind_point_type_list = sai_thrift_s32_list_t(
            count=len(table_bind_point_list),
            int32list=table_bind_point_list)

        port_acl_table_group_id = sai_thrift_create_acl_table_group(
            self.client,
            acl_stage=stage,
            acl_bind_point_type_list=table_bind_point_type_list,
            type=group_type)
        self.acl_grps.append(port_acl_table_group_id)
        print("VLAN ACL Table Group created 0x%lx" % (
            port_acl_table_group_id))

        # Create Mirror ACL table
        field_dscp = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(u8=1))

        mirror_table_id = sai_thrift_create_acl_table(
            self.client,
            acl_stage=stage,
            acl_bind_point_type_list=table_bind_point_type_list,
            field_ether_type=True,
            field_dscp=True)
        self.acl_tables.append(mirror_table_id)

        mirror_table_group_member_id = \
            sai_thrift_create_acl_table_group_member(
                self.client,
                acl_table_group_id=port_acl_table_group_id,
                acl_table_id=mirror_table_id,
                priority=300)
        self.acl_grp_members.append(mirror_table_group_member_id)

        if entry_priority >= 1:
            entry_priority -= 1

        # Add Eth type MAC ACL entry to Mirror ACL Table
        mac_mirror_acl_counter = sai_thrift_create_acl_counter(
            client=self.client, table_id=mirror_table_id)
        action_counter_t = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=mac_mirror_acl_counter),
            enable=True)
        self.acl_counters.append(mac_mirror_acl_counter)

        eth_type = 0x1234
        if eth_type > 0x7fff:
            eth_type -= 0x10000

        ether_type = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(u16=eth_type),
            mask=sai_thrift_acl_field_data_mask_t(u16=32767))

        mac_mirror_entry = sai_thrift_create_acl_entry(
            self.client,
            table_id=mirror_table_id,
            priority=entry_priority,
            action_mirror_ingress=self.mirror_action,
            action_counter=action_counter_t,
            field_ether_type=ether_type,
            field_dscp=field_dscp)
        self.acl_rules.append(mac_mirror_entry)
        print("MAC ACL Mirror entry created 0x%lx" % (mac_mirror_entry))

        print("Binding ACL grp 0x%lx to Port26" % (port_acl_table_group_id))
        # bind ACL GRP to VLAN 100
        sai_thrift_set_port_attribute(
            self.client, self.port26, ingress_acl=port_acl_table_group_id)
        self.bp_list.append(self.port26)

        counter = sai_thrift_get_acl_counter_attribute(
            client=self.client,
            acl_counter_oid=mac_mirror_acl_counter,
            packets=True)
        self.exp_counters["mirror_mac"] = counter["packets"]

        print("Sending Packets matching Mirror ACL rules on Port26. "
              "Packets should be mirrored")
        print("Sending EthType(0x1234) packet - port 26 -> port 27 "
              "[access vlan=200])")
        send_packet(self, self.dev_port26, self.mac_pkt)
        verify_packets(self, self.exp_mac_pkt, [self.dev_port27,
                                                self.dev_port28])
        self.exp_counters["mirror_mac"] += 1
        print("Sending EthType(0x4321) packet - port 26 -> port 27 "
              "[access vlan=200])")
        send_packet(self, self.dev_port26, self.mac_pkt2)
        verify_packets(self, self.exp_mac_pkt2, [self.dev_port27])

        print("Sending EthType(0x4321) packet - port 24 -> "
              "port 25 [access vlan=100])")
        send_packet(self, self.dev_port24, self.mac_pkt2)
        verify_packets(self, self.exp_mac_pkt2, [self.dev_port25])

        # Verifying ACL counters
        print("Verifying ACL counters")
        time.sleep(10)
        counter = sai_thrift_get_acl_counter_attribute(
            client=self.client,
            acl_counter_oid=mac_mirror_acl_counter,
            packets=True)
        self.assertTrue(self.exp_counters["mirror_mac"] == counter["packets"],
                        "MAC ACL Mirror Counter Mismatch")

        self.trapAclCleanup()

        print("Sending Packets matching Mirror ACL rules on Port26. "
              "Packets should not be mirrored")
        print("Sending EthType(0x1234) packet - port 26 -> port 27 "
              "[access vlan=200])")
        send_packet(self, self.dev_port26, self.mac_pkt)
        verify_packets(self, self.exp_mac_pkt, [self.dev_port27])

        print("Sending EthType(0x4321) packet - port 24 -> "
              "port 25 [access vlan=100])")
        send_packet(self, self.dev_port24, self.mac_pkt2)
        verify_packets(self, self.exp_mac_pkt2, [self.dev_port25])

    def trapAclCleanup(self):
        """ Cleans up ACL"""
        print("Cleans up")
        for bp in self.bp_list:
            if bp in self.vlans:
                print("Unbinding ACL grp from Vlan")
                sai_thrift_set_vlan_attribute(
                    self.client, vlan_oid=bp, ingress_acl=0)
            else:
                sai_thrift_set_port_attribute(
                    self.client, bp, ingress_acl=0)
                print("Unbinding ACL grp from Port")
            self.bp_list.remove(bp)
        for trap in self.traps:
            sai_thrift_remove_hostif_trap(self.client, trap)
            self.traps.remove(trap)
        for acl_rule in self.acl_rules:
            action_counter_t = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=0),
                enable=True)
            sai_thrift_set_acl_entry_attribute(
                self.client, acl_rule,
                action_counter=action_counter_t)
        for acl_counter in self.acl_counters:
            sai_thrift_remove_acl_counter(self.client, acl_counter)
            self.acl_counters.remove(acl_counter)
        for acl_grp_member in self.acl_grp_members:
            sai_thrift_remove_acl_table_group_member(self.client,
                                                     acl_grp_member)
            self.acl_grp_members.remove(acl_grp_member)
        for acl_rule in self.acl_rules:
            sai_thrift_remove_acl_entry(self.client, acl_rule)
            self.acl_rules.remove(acl_rule)
        for acl_table in self.acl_tables:
            sai_thrift_remove_acl_table(self.client, acl_table)
            self.acl_tables.remove(acl_table)
        for acl_grp in self.acl_grps:
            sai_thrift_remove_acl_table_group(self.client, acl_grp)
            self.acl_grps.remove(acl_grp)


@disabled
class AclInOutTest(SaiHelper):
    """
    Simulates the ACL setup used in ACL community tests
    Creates an ACL group per port
    Creates 1 ACL tables for mirror types
    Creates an ACL group member per table and per group
    Adds entries in each of the tables and test ACLs work as expected

    Ingress port: port 0 to port 9
    Egress port : port10, port11, port13, port24 and port25
    Mirror port : port12
    """

    def setUp(self):
        super(AclInOutTest, self).setUp()

        self.dmac1 = '00:11:22:33:44:11'
        self.dmac2 = '00:11:22:33:44:22'
        self.src_mac = '00:22:22:22:22:22'
        self.ip_addr1 = '10.0.0.1'
        self.ip_addr2 = '10.0.0.2'
        self.ip_addr3 = '10.10.10.1'
        self.ip_addr4 = '10.10.10.2'

        # creating group list and group member list
        self.acl_ingress_groups_list = []
        self.acl_ingress_group_members_list = []
        self.acl_egress_groups_list = []
        self.acl_egress_group_members_list = []
        self.route_interface_list = []
        self.acl_table = None

        # port list for sending traffic (ingress port)
        self.ports_list = [self.port24, self.port25, self.port26, self.port27,
                           self.port28, self.port29, self.port30, self.port31]

        # creating nhop
        self.nhop1 = sai_thrift_create_next_hop(
            self.client,
            ip=sai_ipaddress(self.ip_addr3),
            router_interface_id=self.port10_rif,
            type=SAI_NEXT_HOP_TYPE_IP)

        self.nhop2 = sai_thrift_create_next_hop(
            self.client,
            ip=sai_ipaddress(self.ip_addr4),
            router_interface_id=self.port11_rif,
            type=SAI_NEXT_HOP_TYPE_IP)

        # creating neighbor entry
        self.neighbor_entry1 = sai_thrift_neighbor_entry_t(
            rif_id=self.port10_rif, ip_address=sai_ipaddress(self.ip_addr3))
        sai_thrift_create_neighbor_entry(
            self.client, self.neighbor_entry1, dst_mac_address=self.dmac1)

        self.neighbor_entry2 = sai_thrift_neighbor_entry_t(
            rif_id=self.port11_rif, ip_address=sai_ipaddress(self.ip_addr4))
        sai_thrift_create_neighbor_entry(
            self.client, self.neighbor_entry2, dst_mac_address=self.dmac2)

        # creating route entry
        self.route_entry1 = sai_thrift_route_entry_t(
            vr_id=self.default_vrf, destination=sai_ipprefix('10.0.0.1/32'))
        sai_thrift_create_route_entry(
            self.client, self.route_entry1, next_hop_id=self.nhop1)

        self.route_entry2 = sai_thrift_route_entry_t(
            vr_id=self.default_vrf, destination=sai_ipprefix('10.0.0.2/32'))
        sai_thrift_create_route_entry(
            self.client, self.route_entry2, next_hop_id=self.nhop2)

        self.route_entry3 = sai_thrift_route_entry_t(
            vr_id=self.default_vrf,
            destination=sai_ipprefix(
                '1234:5678:9abc:def0:4422:1133:5577:99aa/128'))
        sai_thrift_create_route_entry(
            self.client, self.route_entry3, next_hop_id=self.nhop2)

        self.route_entry4 = sai_thrift_route_entry_t(
            vr_id=self.default_vrf,
            destination=sai_ipprefix(
                '1234:5678:9abc:def0:4422:1133:5577:88aa/128'))
        sai_thrift_create_route_entry(
            self.client, self.route_entry4, next_hop_id=self.nhop1)

        # ACL group config value
        group_stage_ingress = SAI_ACL_STAGE_INGRESS
        group_bind_point_list = [SAI_ACL_BIND_POINT_TYPE_PORT]
        group_type = SAI_ACL_TABLE_GROUP_TYPE_PARALLEL

        group_bind_point_type_list = sai_thrift_s32_list_t(
            count=len(group_bind_point_list), int32list=group_bind_point_list)

        # handling all ingress port
        for index, port in enumerate(self.ports_list):
            print("index: {}, port_handle: {}".format(index, port))

            # createing rif for all the port
            route_interface_id = sai_thrift_create_router_interface(
                self.client,
                type=SAI_ROUTER_INTERFACE_TYPE_PORT,
                virtual_router_id=self.default_vrf,
                port_id=port)

            print('route_interface_id: ', route_interface_id)
            self.route_interface_list.append(route_interface_id)

            # create ACL table group
            acl_table_group_ingress = sai_thrift_create_acl_table_group(
                self.client,
                acl_stage=group_stage_ingress,
                acl_bind_point_type_list=group_bind_point_type_list,
                type=group_type)

            self.acl_ingress_groups_list.append(acl_table_group_ingress)

            # bind this ACL group to ports object id
            print("Bind ACL ingress group 0x % lx to port 0x % lx" % (
                self.acl_ingress_groups_list[index], port))
            sai_thrift_set_port_attribute(
                self.client, port,
                ingress_acl=self.acl_ingress_groups_list[index])

    def runTest(self):
        try:
            self.testIPv4OutPortsMirrorAcl()
            self.testIPv6OutPortsMirrorAcl()
            self.testIPv4InPortsMirrorAcl()
            self.testIPv6InPortsMirrorAcl()
            self.testMaxInPortsEntry()
        finally:
            pass

    def testIPv6InPortsMirrorAcl(self):
        '''
        Test various IP mirror functionality
        '''
        print("\ntestIPv6InPortsMirrorAcl")
        pkt = simple_tcpv6_packet(
            eth_dst=ROUTER_MAC,
            ipv6_dst='1234:5678:9abc:def0:4422:1133:5577:99aa',
            ipv6_hlim=64)
        exp_pkt = simple_tcpv6_packet(
            eth_dst=self.dmac2,
            eth_src=ROUTER_MAC,
            ipv6_dst='1234:5678:9abc:def0:4422:1133:5577:99aa',
            ipv6_hlim=63)

        try:
            acl_ipv6_ingress_group_members_list = []
            # ACL table config value
            table_stage = SAI_ACL_STAGE_INGRESS
            table_bind_points = [SAI_ACL_BIND_POINT_TYPE_PORT]
            table_bind_point_type_list = sai_thrift_s32_list_t(
                count=len(table_bind_points), int32list=table_bind_points)
            actions = [SAI_ACL_ACTION_TYPE_MIRROR_INGRESS]
            action_type_list = sai_thrift_s32_list_t(
                count=len(actions), int32list=actions)

            print("Create ACL tables for IPv6 traffic")
            acl_table = sai_thrift_create_acl_table(
                self.client,
                acl_stage=table_stage,
                acl_bind_point_type_list=table_bind_point_type_list,
                acl_action_type_list=action_type_list,
                field_src_ipv6=True,
                field_dst_ipv6=True,
                field_in_ports=True)

            # create ACL ingress table group members
            print("Creates ACL group members")
            for acl_group in self.acl_ingress_groups_list:
                acl_group_ingress_member_id = \
                    sai_thrift_create_acl_table_group_member(
                        self.client,
                        acl_table_group_id=acl_group,
                        acl_table_id=acl_table,
                        priority=1)

                acl_ipv6_ingress_group_members_list.append(
                    acl_group_ingress_member_id)

            # verify packet forwarding without ACL
            send_packet(self, self.dev_port24, pkt)
            verify_packet(self, exp_pkt, self.dev_port11)
            verify_no_packet(self, pkt, self.dev_port12, timeout=2)

            # create dest_ip_t o match ACL entry
            dst_ip = '1234:5678:9abc:def0:4422:1133:5577:99aa'
            dst_ip_mask = 'FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF'
            dst_ip_t = sai_thrift_acl_field_data_t(
                data=sai_thrift_acl_field_data_data_t(ip6=dst_ip),
                mask=sai_thrift_acl_field_data_mask_t(ip6=dst_ip_mask))

            # creating a local mirror session
            mirror_session = sai_thrift_create_mirror_session(
                self.client,
                monitor_port=self.port12,
                type=SAI_MIRROR_SESSION_TYPE_LOCAL)

            mirror_session_list = sai_thrift_object_list_t(
                count=1, idlist=[mirror_session])
            mirror_action = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    objlist=mirror_session_list))

            # creating in_ports
            in_ports = [self.port24, self.port25, self.port26]
            in_ports_list_t = sai_thrift_acl_field_data_t(
                data=sai_thrift_acl_field_data_data_t(
                    objlist=sai_thrift_object_list_t(
                        count=len(in_ports),
                        idlist=in_ports)))

            # creating the ACL entry to mirror the traffic
            acl_entry_ipv6_mirror = sai_thrift_create_acl_entry(
                self.client,
                table_id=acl_table,
                priority=10,
                field_dst_ipv6=dst_ip_t,
                field_in_ports=in_ports_list_t,
                action_mirror_ingress=mirror_action)

            # create ACL counter
            acl_counter = sai_thrift_create_acl_counter(
                self.client, table_id=acl_table)

            # attach ACL counter to ACL entry
            action_counter = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=acl_counter), enable=True)

            sai_thrift_set_acl_entry_attribute(
                self.client, acl_entry_ipv6_mirror,
                action_counter=action_counter)

            # sending traffic to port with in-ports list
            print("\nTraffic using Port24")
            send_packet(self, self.dev_port24, pkt)
            verify_each_packet_on_each_port(self, [exp_pkt, pkt],
                                            [self.dev_port11, self.dev_port12])

            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter, packets=True)

            print("packets['packets']: ", packets['packets'])
            self.assertEqual(packets['packets'], 1)

            print("\nTraffic using Port25")
            send_packet(self, self.dev_port25, pkt)
            verify_each_packet_on_each_port(self, [exp_pkt, pkt],
                                            [self.dev_port11, self.dev_port12])

            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter, packets=True)

            print("packets['packets']: ", packets['packets'])
            self.assertEqual(packets['packets'], 2)

            print("\nTraffic using Port26")
            send_packet(self, self.dev_port26, pkt)
            verify_each_packet_on_each_port(self, [exp_pkt, pkt],
                                            [self.dev_port11, self.dev_port12])

            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter, packets=True)

            print("packets['packets']: ", packets['packets'])
            self.assertEqual(packets['packets'], 3)

            print("\nTraffic though non in-ports port: port27")
            send_packet(self, self.dev_port27, pkt)
            verify_packet(self, exp_pkt, self.dev_port11)
            verify_no_packet(self, pkt, self.dev_port12, timeout=2)

            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter, packets=True)

            print("packets['packets']: ", packets['packets'])
            self.assertEqual(packets['packets'], 3)

        finally:
            print("removing acl entry counter")
            action_counter = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=0), enable=True)

            sai_thrift_set_acl_entry_attribute(
                self.client, acl_entry_ipv6_mirror,
                action_counter=action_counter)

            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter, packets=True)
            self.assertEqual(packets['packets'], 0)

            sai_thrift_remove_acl_counter(self.client, acl_counter)

            print("removing acl etntry for ingress ipv6 mirror acl")
            sai_thrift_remove_acl_entry(self.client, acl_entry_ipv6_mirror)

            print("Removing ACL group members")
            for acl_group_member in acl_ipv6_ingress_group_members_list:
                sai_thrift_remove_acl_table_group_member(self.client,
                                                         acl_group_member)

            print("Removing ACL table")
            sai_thrift_remove_acl_table(self.client, acl_table)

    def testIPv6OutPortsMirrorAcl(self):
        '''
        Test various Out Ports mirror ACL functionality
        '''
        print("\ntestIPv6OutPortsMirrorAcl")
        pkt = simple_tcpv6_packet(
            eth_dst=ROUTER_MAC,
            ipv6_dst='1234:5678:9abc:def0:4422:1133:5577:99aa',
            ipv6_hlim=64)
        exp_pkt = simple_tcpv6_packet(
            eth_dst=self.dmac2,
            eth_src=ROUTER_MAC,
            ipv6_dst='1234:5678:9abc:def0:4422:1133:5577:99aa',
            ipv6_hlim=63)

        pkt2 = simple_tcpv6_packet(
            eth_dst=ROUTER_MAC,
            ipv6_dst='1234:5678:9abc:def0:4422:1133:5577:88aa',
            ipv6_hlim=64)
        exp_pkt2 = simple_tcpv6_packet(
            eth_dst=self.dmac1,
            eth_src=ROUTER_MAC,
            ipv6_dst='1234:5678:9abc:def0:4422:1133:5577:88aa',
            ipv6_hlim=63)
        acl_ipv6_egress_groups_list = []
        acl_ipv6_egress_group_members_list = []
        try:
            # ACL group config value
            group_stage_egress = SAI_ACL_STAGE_EGRESS
            group_bind_point_list = [SAI_ACL_BIND_POINT_TYPE_PORT]
            group_type = SAI_ACL_TABLE_GROUP_TYPE_PARALLEL

            group_bind_point_type_list = sai_thrift_s32_list_t(
                count=len(group_bind_point_list),
                int32list=group_bind_point_list)

            # Egress port list
            e_ports_list = [self.port10, self.port11, self.port13]

            # handling all egress port
            for index, port in enumerate(e_ports_list):
                print("index: {}, port_handle: {}".format(index, port))

                # create ACL table group
                acl_table_group_egress = sai_thrift_create_acl_table_group(
                    self.client,
                    acl_stage=group_stage_egress,
                    acl_bind_point_type_list=group_bind_point_type_list,
                    type=group_type)

                acl_ipv6_egress_groups_list.append(acl_table_group_egress)

                # bind this ACL group to ports object id
                print("Bind ACL egress group 0x % lx to port 0x % lx" % (
                    acl_ipv6_egress_groups_list[index], port))
                sai_thrift_set_port_attribute(
                    self.client, port,
                    egress_acl=acl_ipv6_egress_groups_list[index])

            # ACL table config value
            table_stage = SAI_ACL_STAGE_EGRESS
            table_bind_points = [SAI_ACL_BIND_POINT_TYPE_PORT]
            table_bind_point_type_list = sai_thrift_s32_list_t(
                count=len(table_bind_points), int32list=table_bind_points)
            actions = [SAI_ACL_ACTION_TYPE_MIRROR_EGRESS]
            action_type_list = sai_thrift_s32_list_t(
                count=len(actions), int32list=actions)

            print("Create Egress Mirror ACL tables")
            acl_table = sai_thrift_create_acl_table(
                self.client,
                acl_stage=table_stage,
                acl_bind_point_type_list=table_bind_point_type_list,
                acl_action_type_list=action_type_list,
                field_src_ipv6=True,
                field_dst_ipv6=True,
                field_out_ports=True)

            # create ACL egress table group members
            print("Creates ACL group members")
            for acl_group in acl_ipv6_egress_groups_list:
                acl_group_egress_member_id = \
                    sai_thrift_create_acl_table_group_member(
                        self.client,
                        acl_table_group_id=acl_group,
                        acl_table_id=acl_table,
                        priority=1)

                acl_ipv6_egress_group_members_list.append(
                    acl_group_egress_member_id)

            # verify packet forwarding without ACL
            send_packet(self, self.dev_port24, pkt)
            verify_packet(self, exp_pkt, self.dev_port11)
            verify_no_packet(self, pkt, self.dev_port12, timeout=2)

            # create dest_ip_t o match ACL entry
            dst_ip = '1234:5678:9abc:def0:4422:1133:5577:99aa'
            dst_ip_mask = 'FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF'
            dst_ip_t = sai_thrift_acl_field_data_t(
                data=sai_thrift_acl_field_data_data_t(ip6=dst_ip),
                mask=sai_thrift_acl_field_data_mask_t(ip6=dst_ip_mask))

            dst_ip2 = '1234:5678:9abc:def0:4422:1133:5577:88aa'
            dst_ip2_mask = 'FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF'
            dst_ip2_t = sai_thrift_acl_field_data_t(
                data=sai_thrift_acl_field_data_data_t(ip6=dst_ip2),
                mask=sai_thrift_acl_field_data_mask_t(ip6=dst_ip2_mask))

            # creating a local mirror session
            mirror_session = sai_thrift_create_mirror_session(
                self.client,
                monitor_port=self.port12,
                type=SAI_MIRROR_SESSION_TYPE_LOCAL)

            mirror_session_list = sai_thrift_object_list_t(
                count=1, idlist=[mirror_session])
            mirror_action = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    objlist=mirror_session_list))

            # creating out_ports
            out_ports = [self.port11, self.port10]
            out_ports_list_t = sai_thrift_acl_field_data_t(
                data=sai_thrift_acl_field_data_data_t(
                    objlist=sai_thrift_object_list_t(
                        count=len(out_ports),
                        idlist=out_ports)))

            # creating the ACL entry to mirror the traffic
            acl_entry = sai_thrift_create_acl_entry(
                self.client,
                table_id=acl_table,
                priority=1,
                field_dst_ipv6=dst_ip_t,
                field_out_ports=out_ports_list_t,
                action_mirror_egress=mirror_action)

            acl_entry2 = sai_thrift_create_acl_entry(
                self.client,
                table_id=acl_table,
                priority=1,
                field_dst_ipv6=dst_ip2_t,
                field_out_ports=out_ports_list_t,
                action_mirror_egress=mirror_action)

            # create ACL counter
            acl_counter = sai_thrift_create_acl_counter(
                self.client, table_id=acl_table)

            # attach ACL counter to ACL entry
            action_counter = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=acl_counter), enable=True)

            sai_thrift_set_acl_entry_attribute(
                self.client, acl_entry,
                action_counter=action_counter)

            sai_thrift_set_acl_entry_attribute(
                self.client, acl_entry2,
                action_counter=action_counter)

            # sending traffic to port with in-ports list
            print("\nchecking 1st port in out-port list for mirror ACL")
            send_packet(self, self.dev_port24, pkt)
            verify_each_packet_on_each_port(self, [exp_pkt, exp_pkt],
                                            [self.dev_port11, self.dev_port12])

            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter, packets=True)

            print("packets['packets']: ", packets['packets'])
            self.assertEqual(packets['packets'], 1)

            send_packet(self, self.dev_port24, pkt2)
            verify_each_packet_on_each_port(self, [exp_pkt2, exp_pkt2],
                                            [self.dev_port10, self.dev_port12])

            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter, packets=True)

            print("packets['packets']: ", packets['packets'])
            self.assertEqual(packets['packets'], 2)

        finally:
            print("removing acl entry counter")
            action_counter = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=0), enable=True)

            sai_thrift_set_acl_entry_attribute(
                self.client, acl_entry,
                action_counter=action_counter)

            sai_thrift_set_acl_entry_attribute(
                self.client, acl_entry2,
                action_counter=action_counter)

            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter, packets=True)
            self.assertEqual(packets['packets'], 0)

            sai_thrift_remove_acl_counter(self.client, acl_counter)

            print("removing acl etntry for egress mirror acl")
            sai_thrift_remove_acl_entry(self.client, acl_entry)
            sai_thrift_remove_acl_entry(self.client, acl_entry2)

            print("Unbind Egress ACL groups from ports object id")
            for ports in e_ports_list:
                sai_thrift_set_port_attribute(
                    self.client, ports,
                    egress_acl=int(SAI_NULL_OBJECT_ID))

            print("Removing Egress ACL group members")
            for acl_group_member in acl_ipv6_egress_group_members_list:
                sai_thrift_remove_acl_table_group_member(self.client,
                                                         acl_group_member)
            print("Removing Egress ACL table")
            sai_thrift_remove_acl_table(self.client, acl_table)

            print("Removing EgressACL groups")
            for acl_group in acl_ipv6_egress_groups_list:
                sai_thrift_remove_acl_table_group(self.client, acl_group)

    def testIPv4OutPortsMirrorAcl(self):
        '''
        Test various Out Ports mirror ACL functionality
        '''
        print("\ntestIPv4OutPortsMirrorAcl")
        pkt = simple_tcp_packet(eth_dst=ROUTER_MAC,
                                eth_src=self.src_mac,
                                ip_dst=self.ip_addr2,
                                ip_ttl=64)
        exp_pkt = simple_tcp_packet(eth_dst=self.dmac2,
                                    eth_src=ROUTER_MAC,
                                    ip_dst=self.ip_addr2,
                                    ip_ttl=63)
        pkt_2 = simple_tcp_packet(eth_dst=ROUTER_MAC,
                                  eth_src=self.src_mac,
                                  ip_dst=self.ip_addr1,
                                  ip_ttl=64)
        exp_pkt_2 = simple_tcp_packet(eth_dst=self.dmac1,
                                      eth_src=ROUTER_MAC,
                                      ip_dst=self.ip_addr1,
                                      ip_ttl=63)
        try:
            # ACL group config value
            group_stage_egress = SAI_ACL_STAGE_EGRESS
            group_bind_point_list = [SAI_ACL_BIND_POINT_TYPE_PORT]
            group_type = SAI_ACL_TABLE_GROUP_TYPE_PARALLEL

            group_bind_point_type_list = sai_thrift_s32_list_t(
                count=len(group_bind_point_list),
                int32list=group_bind_point_list)

            # Egress port list
            e_ports_list = [self.port10, self.port11, self.port13]

            # handling all egress port
            for index, port in enumerate(e_ports_list):
                print("index: {}, port_handle: {}".format(index, port))

                # create ACL table group
                acl_table_group_egress = sai_thrift_create_acl_table_group(
                    self.client,
                    acl_stage=group_stage_egress,
                    acl_bind_point_type_list=group_bind_point_type_list,
                    type=group_type)

                self.acl_egress_groups_list.append(acl_table_group_egress)

                # bind this ACL group to ports object id
                print("Bind ACL egress group 0x % lx to port 0x % lx" % (
                    self.acl_egress_groups_list[index], port))
                sai_thrift_set_port_attribute(
                    self.client, port,
                    egress_acl=self.acl_egress_groups_list[index])

            # ACL table config value
            table_stage = SAI_ACL_STAGE_EGRESS
            table_bind_points = [SAI_ACL_BIND_POINT_TYPE_PORT]
            table_bind_point_type_list = sai_thrift_s32_list_t(
                count=len(table_bind_points), int32list=table_bind_points)
            actions = [SAI_ACL_ACTION_TYPE_MIRROR_EGRESS]
            action_type_list = sai_thrift_s32_list_t(
                count=len(actions), int32list=actions)

            print("Create Egress Mirror ACL tables")
            acl_table = sai_thrift_create_acl_table(
                self.client,
                acl_stage=table_stage,
                acl_bind_point_type_list=table_bind_point_type_list,
                acl_action_type_list=action_type_list,
                field_src_ip=True,
                field_dst_ip=True,
                field_out_ports=True)

            # create ACL egress table group members
            print("Creates ACL group members")
            for acl_group in self.acl_egress_groups_list:
                acl_group_egress_member_id = \
                    sai_thrift_create_acl_table_group_member(
                        self.client,
                        acl_table_group_id=acl_group,
                        acl_table_id=acl_table,
                        priority=1)

                self.acl_egress_group_members_list.append(
                    acl_group_egress_member_id)

            # verify packet forwarding without ACL
            send_packet(self, self.dev_port24, pkt)
            verify_packet(self, exp_pkt, self.dev_port11)
            verify_no_packet(self, pkt, self.dev_port12, timeout=2)

            # create dest_ip_t o match ACL entry
            dst_ip_mask = '255.255.255.255'
            dst_ip_t = sai_thrift_acl_field_data_t(
                data=sai_thrift_acl_field_data_data_t(ip4=self.ip_addr2),
                mask=sai_thrift_acl_field_data_mask_t(ip4=dst_ip_mask))

            dst_ip2_mask = '255.255.255.255'
            dst_ip2_t = sai_thrift_acl_field_data_t(
                data=sai_thrift_acl_field_data_data_t(ip4=self.ip_addr1),
                mask=sai_thrift_acl_field_data_mask_t(ip4=dst_ip2_mask))

            # creating a local mirror session
            mirror_session = sai_thrift_create_mirror_session(
                self.client,
                monitor_port=self.port12,
                type=SAI_MIRROR_SESSION_TYPE_LOCAL)

            mirror_session_list = sai_thrift_object_list_t(
                count=1, idlist=[mirror_session])
            mirror_action = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    objlist=mirror_session_list))

            # creating out_ports
            out_ports = [self.port11, self.port10]
            out_ports_list_t = sai_thrift_acl_field_data_t(
                data=sai_thrift_acl_field_data_data_t(
                    objlist=sai_thrift_object_list_t(
                        count=len(out_ports),
                        idlist=out_ports)))

            print("Going to create the acl entry")
            # creating the ACL entry to mirror the traffic
            acl_entry = sai_thrift_create_acl_entry(
                self.client,
                table_id=acl_table,
                priority=1,
                field_dst_ip=dst_ip_t,
                field_out_ports=out_ports_list_t,
                action_mirror_egress=mirror_action)

            acl_entry2 = sai_thrift_create_acl_entry(
                self.client,
                table_id=acl_table,
                priority=1,
                field_dst_ip=dst_ip2_t,
                field_out_ports=out_ports_list_t,
                action_mirror_egress=mirror_action)

            # create ACL counter
            acl_counter = sai_thrift_create_acl_counter(
                self.client, table_id=acl_table)

            # attach ACL counter to ACL entry
            action_counter = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=acl_counter), enable=True)

            sai_thrift_set_acl_entry_attribute(
                self.client, acl_entry,
                action_counter=action_counter)

            sai_thrift_set_acl_entry_attribute(
                self.client, acl_entry2,
                action_counter=action_counter)

            # sending traffic to port with in-ports list
            print("\nchecking 1st port in out-port list for mirror ACL")
            send_packet(self, self.dev_port24, pkt)
            verify_each_packet_on_each_port(self, [exp_pkt, exp_pkt],
                                            [self.dev_port11, self.dev_port12])

            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter, packets=True)

            print("packets['packets']: ", packets['packets'])
            self.assertEqual(packets['packets'], 1)

            send_packet(self, self.dev_port24, pkt_2)
            verify_each_packet_on_each_port(self, [exp_pkt_2, exp_pkt_2],
                                            [self.dev_port10, self.dev_port12])

            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter, packets=True)

            print("packets['packets']: ", packets['packets'])
            self.assertEqual(packets['packets'], 2)

        finally:
            print("removing acl entry counter")
            action_counter = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=0), enable=True)

            sai_thrift_set_acl_entry_attribute(
                self.client, acl_entry,
                action_counter=action_counter)

            sai_thrift_set_acl_entry_attribute(
                self.client, acl_entry2,
                action_counter=action_counter)

            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter, packets=True)
            self.assertEqual(packets['packets'], 0)

            sai_thrift_remove_acl_counter(self.client, acl_counter)

            print("removing acl etntry for egress mirror acl")
            sai_thrift_remove_acl_entry(self.client, acl_entry)
            sai_thrift_remove_acl_entry(self.client, acl_entry2)

            print("Unbind Egress ACL groups from ports object id")
            for ports in e_ports_list:
                sai_thrift_set_port_attribute(
                    self.client, ports,
                    egress_acl=int(SAI_NULL_OBJECT_ID))

            print("Removing Egress ACL group members")
            for acl_group_member in self.acl_egress_group_members_list:
                sai_thrift_remove_acl_table_group_member(self.client,
                                                         acl_group_member)
            print("Removing Egress ACL table")
            sai_thrift_remove_acl_table(self.client, acl_table)

            print("Removing EgressACL groups")
            for acl_group in self.acl_egress_groups_list:
                sai_thrift_remove_acl_table_group(self.client, acl_group)

    def testMaxInPortsEntry(self):
        '''
        Test Maximum in-ports ACL entry create
        '''
        print("\ntestMaxInPortsEntry\n")
        try:
            # ACL table config value
            table_stage = SAI_ACL_STAGE_INGRESS
            table_bind_points = [SAI_ACL_BIND_POINT_TYPE_PORT]
            table_bind_point_type_list = sai_thrift_s32_list_t(
                count=len(table_bind_points), int32list=table_bind_points)
            actions = [SAI_ACL_ACTION_TYPE_MIRROR_INGRESS]
            action_type_list = sai_thrift_s32_list_t(
                count=len(actions), int32list=actions)

            print("Create ACL tables")
            acl_table = sai_thrift_create_acl_table(
                self.client,
                acl_stage=table_stage,
                acl_bind_point_type_list=table_bind_point_type_list,
                acl_action_type_list=action_type_list,
                field_src_ip=True,
                field_dst_ip=True,
                field_ttl=True,
                field_in_ports=True)

            # storing the acl entry list
            acl_table_entry_list = []

            # create dest_ip_t o match ACL entry
            dst_ip_mask = '255.255.255.255'
            dst_ip_t = sai_thrift_acl_field_data_t(
                data=sai_thrift_acl_field_data_data_t(ip4=self.ip_addr2),
                mask=sai_thrift_acl_field_data_mask_t(ip4=dst_ip_mask))

            # creating a local mirror session
            mirror_session = sai_thrift_create_mirror_session(
                self.client,
                monitor_port=self.port12,
                type=SAI_MIRROR_SESSION_TYPE_LOCAL)

            mirror_session_list = sai_thrift_object_list_t(
                count=1, idlist=[mirror_session])
            mirror_action = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    objlist=mirror_session_list))

            # creating in_ports
            in_ports = [self.port24, self.port25, self.port26]
            in_ports_list_t = sai_thrift_acl_field_data_t(
                data=sai_thrift_acl_field_data_data_t(
                    objlist=sai_thrift_object_list_t(
                        count=len(in_ports),
                        idlist=in_ports)))

            # creating the ACL entry to mirror the traffic
            # 1
            acl_entry = sai_thrift_create_acl_entry(
                self.client,
                table_id=acl_table,
                priority=10,
                field_dst_ip=dst_ip_t,
                field_in_ports=in_ports_list_t,
                action_mirror_ingress=mirror_action)
            acl_table_entry_list.append(acl_entry)

            # creating in_ports
            in_ports = [self.port24, self.port28, self.port26]
            in_ports_list_t = sai_thrift_acl_field_data_t(
                data=sai_thrift_acl_field_data_data_t(
                    objlist=sai_thrift_object_list_t(
                        count=len(in_ports),
                        idlist=in_ports)))

            # creating the ACL entry to mirror the traffic
            # 2
            acl_entry = sai_thrift_create_acl_entry(
                self.client,
                table_id=acl_table,
                priority=10,
                field_dst_ip=dst_ip_t,
                field_in_ports=in_ports_list_t,
                action_mirror_ingress=mirror_action)
            acl_table_entry_list.append(acl_entry)

            # creating in_ports
            in_ports = [self.port24]
            in_ports_list_t = sai_thrift_acl_field_data_t(
                data=sai_thrift_acl_field_data_data_t(
                    objlist=sai_thrift_object_list_t(
                        count=len(in_ports),
                        idlist=in_ports)))

            # creating the ACL entry to mirror the traffic
            # 3
            acl_entry = sai_thrift_create_acl_entry(
                self.client,
                table_id=acl_table,
                priority=10,
                field_dst_ip=dst_ip_t,
                field_in_ports=in_ports_list_t,
                action_mirror_ingress=mirror_action)
            acl_table_entry_list.append(acl_entry)

            # creating in_ports
            in_ports = [self.port28]
            in_ports_list_t = sai_thrift_acl_field_data_t(
                data=sai_thrift_acl_field_data_data_t(
                    objlist=sai_thrift_object_list_t(
                        count=len(in_ports),
                        idlist=in_ports)))

            # creating the ACL entry to mirror the traffic
            # 4
            acl_entry = sai_thrift_create_acl_entry(
                self.client,
                table_id=acl_table,
                priority=10,
                field_dst_ip=dst_ip_t,
                field_in_ports=in_ports_list_t,
                action_mirror_ingress=mirror_action)
            acl_table_entry_list.append(acl_entry)

            # creating in_ports
            in_ports = [self.port26]
            in_ports_list_t = sai_thrift_acl_field_data_t(
                data=sai_thrift_acl_field_data_data_t(
                    objlist=sai_thrift_object_list_t(
                        count=len(in_ports),
                        idlist=in_ports)))

            # creating the ACL entry to mirror the traffic
            # 5
            acl_entry = sai_thrift_create_acl_entry(
                self.client,
                table_id=acl_table,
                priority=10,
                field_dst_ip=dst_ip_t,
                field_in_ports=in_ports_list_t,
                action_mirror_ingress=mirror_action)
            acl_table_entry_list.append(acl_entry)

            # creating in_ports
            in_ports = [self.port24, self.port28]
            in_ports_list_t = sai_thrift_acl_field_data_t(
                data=sai_thrift_acl_field_data_data_t(
                    objlist=sai_thrift_object_list_t(
                        count=len(in_ports),
                        idlist=in_ports)))

            # creating the ACL entry to mirror the traffic
            # 6
            acl_entry = sai_thrift_create_acl_entry(
                self.client,
                table_id=acl_table,
                priority=10,
                field_dst_ip=dst_ip_t,
                field_in_ports=in_ports_list_t,
                action_mirror_ingress=mirror_action)
            acl_table_entry_list.append(acl_entry)

            # creating in_ports
            in_ports = [self.port26, self.port28]
            in_ports_list_t = sai_thrift_acl_field_data_t(
                data=sai_thrift_acl_field_data_data_t(
                    objlist=sai_thrift_object_list_t(
                        count=len(in_ports),
                        idlist=in_ports)))

            # creating the ACL entry to mirror the traffic
            # 7
            acl_entry = sai_thrift_create_acl_entry(
                self.client,
                table_id=acl_table,
                priority=10,
                field_dst_ip=dst_ip_t,
                field_in_ports=in_ports_list_t,
                action_mirror_ingress=mirror_action)
            acl_table_entry_list.append(acl_entry)

            # creating in_ports
            in_ports = [self.port26, self.port24]
            in_ports_list_t = sai_thrift_acl_field_data_t(
                data=sai_thrift_acl_field_data_data_t(
                    objlist=sai_thrift_object_list_t(
                        count=len(in_ports),
                        idlist=in_ports)))

            # creating the ACL entry to mirror the traffic
            # 8
            acl_entry = sai_thrift_create_acl_entry(
                self.client,
                table_id=acl_table,
                priority=10,
                field_dst_ip=dst_ip_t,
                field_in_ports=in_ports_list_t,
                action_mirror_ingress=mirror_action)
            acl_table_entry_list.append(acl_entry)

            # creating in_ports
            in_ports = [self.port25, self.port28]
            in_ports_list_t = sai_thrift_acl_field_data_t(
                data=sai_thrift_acl_field_data_data_t(
                    objlist=sai_thrift_object_list_t(
                        count=len(in_ports),
                        idlist=in_ports)))

            # creating the ACL entry to mirror the traffic
            # 9
            acl_entry = sai_thrift_create_acl_entry(
                self.client,
                table_id=acl_table,
                priority=10,
                field_dst_ip=dst_ip_t,
                field_in_ports=in_ports_list_t,
                action_mirror_ingress=mirror_action)

            print("acl_entry: ", acl_entry)
            self.assertEqual(acl_entry, 0.0)

        finally:
            print("removing acl etntry for ingress ipv4 mirror acl")
            for acl_entry_p in acl_table_entry_list:
                print("Cleanup, acl_entry_p", acl_entry_p)
                sai_thrift_remove_acl_entry(self.client, acl_entry_p)

            print("Removing ACL table")
            sai_thrift_remove_acl_table(self.client, acl_table)

    def testIPv4InPortsMirrorAcl(self):
        '''
        Test various IP mirror functionality
        '''
        print("\ntestIPv4InPortsMirrorAcl")
        pkt = simple_tcp_packet(eth_dst=ROUTER_MAC,
                                eth_src=self.src_mac,
                                ip_dst=self.ip_addr2,
                                ip_ttl=64)
        exp_pkt = simple_tcp_packet(eth_dst=self.dmac2,
                                    eth_src=ROUTER_MAC,
                                    ip_dst=self.ip_addr2,
                                    ip_ttl=63)
        try:
            # ACL table config value
            table_stage = SAI_ACL_STAGE_INGRESS
            table_bind_points = [SAI_ACL_BIND_POINT_TYPE_PORT]
            table_bind_point_type_list = sai_thrift_s32_list_t(
                count=len(table_bind_points), int32list=table_bind_points)
            actions = [SAI_ACL_ACTION_TYPE_MIRROR_INGRESS]
            action_type_list = sai_thrift_s32_list_t(
                count=len(actions), int32list=actions)

            print("Create ACL tables")
            self.acl_table = sai_thrift_create_acl_table(
                self.client,
                acl_stage=table_stage,
                acl_bind_point_type_list=table_bind_point_type_list,
                acl_action_type_list=action_type_list,
                field_src_ip=True,
                field_dst_ip=True,
                field_ttl=True,
                field_in_ports=True)

            # create ACL ingress table group members
            print("Creates ACL group members")
            for acl_group in self.acl_ingress_groups_list:
                acl_group_ingress_member_id = \
                    sai_thrift_create_acl_table_group_member(
                        self.client,
                        acl_table_group_id=acl_group,
                        acl_table_id=self.acl_table,
                        priority=1)

                self.acl_ingress_group_members_list.append(
                    acl_group_ingress_member_id)

            # verify packet forwarding without ACL
            send_packet(self, self.dev_port24, pkt)
            verify_packet(self, exp_pkt, self.dev_port11)
            verify_no_packet(self, pkt, self.dev_port12, timeout=2)

            # create dest_ip_t o match ACL entry
            dst_ip_mask = '255.255.255.255'
            dst_ip_t = sai_thrift_acl_field_data_t(
                data=sai_thrift_acl_field_data_data_t(ip4=self.ip_addr2),
                mask=sai_thrift_acl_field_data_mask_t(ip4=dst_ip_mask))

            # creating a local mirror session
            mirror_session = sai_thrift_create_mirror_session(
                self.client,
                monitor_port=self.port12,
                type=SAI_MIRROR_SESSION_TYPE_LOCAL)

            mirror_session_list = sai_thrift_object_list_t(
                count=1, idlist=[mirror_session])
            mirror_action = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    objlist=mirror_session_list))

            # creating in_ports
            in_ports = [self.port24, self.port25, self.port26]
            in_ports_list_t = sai_thrift_acl_field_data_t(
                data=sai_thrift_acl_field_data_data_t(
                    objlist=sai_thrift_object_list_t(
                        count=len(in_ports),
                        idlist=in_ports)))

            # creating the ACL entry to mirror the traffic
            acl_entry = sai_thrift_create_acl_entry(
                self.client,
                table_id=self.acl_table,
                priority=10,
                field_dst_ip=dst_ip_t,
                field_in_ports=in_ports_list_t,
                action_mirror_ingress=mirror_action)

            # create ACL counter
            acl_counter = sai_thrift_create_acl_counter(
                self.client, table_id=self.acl_table)

            # attach ACL counter to ACL entry
            action_counter = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=acl_counter), enable=True)

            sai_thrift_set_acl_entry_attribute(
                self.client, acl_entry,
                action_counter=action_counter)

            # sending traffic to port with in-ports list
            print("\nTraffic using Port24")
            send_packet(self, self.dev_port24, pkt)
            verify_each_packet_on_each_port(self, [exp_pkt, pkt],
                                            [self.dev_port11, self.dev_port12])

            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter, packets=True)

            print("packets['packets']: ", packets['packets'])
            self.assertEqual(packets['packets'], 1)

            print("\nTraffic using Port25")
            send_packet(self, self.dev_port25, pkt)
            verify_each_packet_on_each_port(self, [exp_pkt, pkt],
                                            [self.dev_port11, self.dev_port12])

            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter, packets=True)

            print("packets['packets']: ", packets['packets'])
            self.assertEqual(packets['packets'], 2)

            print("\nTraffic using Port26")
            send_packet(self, self.dev_port26, pkt)
            verify_each_packet_on_each_port(self, [exp_pkt, pkt],
                                            [self.dev_port11, self.dev_port12])

            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter, packets=True)

            print("packets['packets']: ", packets['packets'])
            self.assertEqual(packets['packets'], 3)

            print("\nTraffic though non in-ports port: port27")
            send_packet(self, self.dev_port27, pkt)
            verify_packet(self, exp_pkt, self.dev_port11)
            verify_no_packet(self, pkt, self.dev_port12, timeout=2)

            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter, packets=True)

            print("packets['packets']: ", packets['packets'])
            self.assertEqual(packets['packets'], 3)

        finally:
            print("removing acl entry counter")
            action_counter = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=0), enable=True)

            sai_thrift_set_acl_entry_attribute(
                self.client, acl_entry,
                action_counter=action_counter)

            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter, packets=True)
            self.assertEqual(packets['packets'], 0)

            sai_thrift_remove_acl_counter(self.client, acl_counter)

            print("removing acl etntry for ingress ipv4 mirror acl")
            sai_thrift_remove_acl_entry(self.client, acl_entry)

            print("cleanup mirror session")
            sai_thrift_remove_mirror_session(self.client, mirror_session)

            print("Removing ACL group members")
            for acl_group_member in self.acl_ingress_group_members_list:
                sai_thrift_remove_acl_table_group_member(self.client,
                                                         acl_group_member)

            print("Removing ACL table")
            sai_thrift_remove_acl_table(self.client, self.acl_table)

    def tearDown(self):

        # cleaning route entries
        sai_thrift_remove_route_entry(self.client, self.route_entry1)
        sai_thrift_remove_route_entry(self.client, self.route_entry2)
        sai_thrift_remove_route_entry(self.client, self.route_entry3)
        sai_thrift_remove_route_entry(self.client, self.route_entry4)

        # cleaning next hop entries
        sai_thrift_remove_next_hop(self.client, self.nhop1)
        sai_thrift_remove_next_hop(self.client, self.nhop2)

        # cleaning neighbor entries
        sai_thrift_remove_neighbor_entry(self.client, self.neighbor_entry1)
        sai_thrift_remove_neighbor_entry(self.client, self.neighbor_entry2)

        # cleaning rif
        for port_rif in self.route_interface_list:
            sai_thrift_remove_router_interface(self.client, port_rif)

        print("Unbind ACL groups from ports object id")
        for ports in self.ports_list:
            sai_thrift_set_port_attribute(
                self.client, ports,
                ingress_acl=int(SAI_NULL_OBJECT_ID))

        print("Removing ACL groups")
        for acl_group in self.acl_ingress_groups_list:
            sai_thrift_remove_acl_table_group(self.client, acl_group)

        # cleanup ACL
        super(AclInOutTest, self).tearDown()


@group('acl2')
class MacVlanPcpCfiTest(SaiHelper):
    """
    Verify ACL outer vlan Priority and Dei/CFI test case
    """

    def setUp(self):
        super(MacVlanPcpCfiTest, self).setUp()
        vlan_id = 101
        self.fdbs = []
        mac1 = '00:11:11:11:11:11'
        mac2 = '00:22:22:22:22:22'
        mac3 = '00:33:33:33:33:33'
        mac_action = SAI_PACKET_ACTION_FORWARD

        self.vlan_oid = sai_thrift_create_vlan(self.client, vlan_id)

        # Setup untagged ports
        sai_thrift_set_port_attribute(
            self.client, self.port25, port_vlan_id=vlan_id)
        sai_thrift_set_port_attribute(
            self.client, self.port26, port_vlan_id=vlan_id)

        self.port24_bp = sai_thrift_create_bridge_port(
            self.client,
            bridge_id=self.default_1q_bridge,
            port_id=self.port24,
            type=SAI_BRIDGE_PORT_TYPE_PORT,
            admin_state=True)

        self.vlan_member1 = sai_thrift_create_vlan_member(
            self.client,
            vlan_id=self.vlan_oid,
            bridge_port_id=self.port24_bp,
            vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_TAGGED)

        self.port25_bp = sai_thrift_create_bridge_port(
            self.client,
            bridge_id=self.default_1q_bridge,
            port_id=self.port25,
            type=SAI_BRIDGE_PORT_TYPE_PORT,
            admin_state=True)

        self.vlan_member2 = sai_thrift_create_vlan_member(
            self.client,
            vlan_id=self.vlan_oid,
            bridge_port_id=self.port25_bp,
            vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_TAGGED)

        self.port26_bp = sai_thrift_create_bridge_port(
            self.client,
            bridge_id=self.default_1q_bridge,
            port_id=self.port26,
            type=SAI_BRIDGE_PORT_TYPE_PORT,
            admin_state=True)

        self.vlan_member3 = sai_thrift_create_vlan_member(
            self.client,
            vlan_id=self.vlan_oid,
            bridge_port_id=self.port26_bp,
            vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_UNTAGGED)

        self.fdb_entry1 = sai_thrift_fdb_entry_t(
            switch_id=self.switch_id, mac_address=mac1, bv_id=self.vlan_oid)
        sai_thrift_create_fdb_entry(
            self.client,
            self.fdb_entry1,
            type=SAI_FDB_ENTRY_TYPE_STATIC,
            bridge_port_id=self.port24_bp,
            packet_action=mac_action)

        self.fdb_entry2 = sai_thrift_fdb_entry_t(
            switch_id=self.switch_id, mac_address=mac2, bv_id=self.vlan_oid)
        sai_thrift_create_fdb_entry(
            self.client,
            self.fdb_entry2,
            type=SAI_FDB_ENTRY_TYPE_STATIC,
            bridge_port_id=self.port25_bp,
            packet_action=mac_action)

        self.fdb_entry3 = sai_thrift_fdb_entry_t(
            switch_id=self.switch_id, mac_address=mac3, bv_id=self.vlan_oid)
        sai_thrift_create_fdb_entry(
            self.client,
            self.fdb_entry3,
            type=SAI_FDB_ENTRY_TYPE_STATIC,
            bridge_port_id=self.port26_bp,
            packet_action=mac_action)

        self.pkt1 = simple_tcp_packet(
            eth_dst='00:22:22:22:22:22',
            eth_src='00:11:11:11:11:11',
            dl_vlan_enable=True,
            vlan_vid=101,
            vlan_pcp=2,
            dl_vlan_cfi=0,
            ip_src='192.168.100.1',
            ip_dst='172.16.0.1',
            ip_id=102,
            ip_ttl=64)

        self.pkt2 = simple_tcp_packet(
            eth_dst='00:22:22:22:22:22',
            eth_src='00:33:33:33:33:33',
            dl_vlan_enable=True,
            vlan_vid=101,
            vlan_pcp=3,
            dl_vlan_cfi=0,
            ip_src='192.168.100.1',
            ip_dst='172.16.0.1',
            ip_id=102,
            ip_ttl=64)

    def runTest(self):
        print("Testing Vlan Pcp in ingress")
        self.aclOuterVlanPcpTest(SAI_ACL_STAGE_INGRESS)
        print("Testing Vlan Pcp in egress")
        self.aclOuterVlanPcpTest(SAI_ACL_STAGE_EGRESS)
        print("Testing Vlan Cfi/Dei in ingress")
        self.aclOuterVlanCfiTest(SAI_ACL_STAGE_INGRESS)
        print("Testing Vlan Cfi/Dei in egress")
        self.aclOuterVlanCfiTest(SAI_ACL_STAGE_EGRESS)

    def tearDown(self):
        sai_thrift_remove_fdb_entry(
            self.client, self.fdb_entry1)
        sai_thrift_remove_fdb_entry(self.client, self.fdb_entry2)
        sai_thrift_remove_fdb_entry(self.client, self.fdb_entry3)

        sai_thrift_set_port_attribute(
            self.client, self.port25, port_vlan_id=int(SAI_NULL_OBJECT_ID))
        sai_thrift_set_port_attribute(
            self.client, self.port26, port_vlan_id=int(SAI_NULL_OBJECT_ID))

        sai_thrift_remove_vlan_member(self.client, self.vlan_member1)
        sai_thrift_remove_vlan_member(self.client, self.vlan_member2)
        sai_thrift_remove_vlan_member(self.client, self.vlan_member3)

        sai_thrift_remove_vlan(self.client, self.vlan_oid)

        sai_thrift_remove_bridge_port(self.client, self.port24_bp)
        sai_thrift_remove_bridge_port(self.client, self.port25_bp)
        sai_thrift_remove_bridge_port(self.client, self.port26_bp)

        super(MacVlanPcpCfiTest, self).tearDown()

    def basicUntaggedTest(self):
        # Bind fdb_entry for self.mac to port24 (i.e. egress)
        self.mac = '00:11:11:11:11:12'
        mac_action = SAI_PACKET_ACTION_FORWARD
        fdb_entry = sai_thrift_fdb_entry_t(
            switch_id=self.switch_id,
            mac_address=self.mac,
            bv_id=self.vlan_oid)
        sai_thrift_create_fdb_entry(
            self.client,
            fdb_entry,
            type=SAI_FDB_ENTRY_TYPE_STATIC,
            bridge_port_id=self.port26_bp,
            packet_action=mac_action)
        self.fdbs.append(fdb_entry)

        eth_pkt1 = simple_eth_packet(pktlen=100,
                                     eth_dst=self.mac,
                                     eth_src='00:06:07:08:09:0a')

        # send the test packet(s)
        print("Sending Test packet port 25 -> port 26")
        send_packet(self, self.dev_port25, eth_pkt1)
        verify_packets(self, eth_pkt1, [self.dev_port26])

        sai_thrift_remove_fdb_entry(
            self.client, fdb_entry)
        for fdb in list(self.fdbs):
            self.fdbs.remove(fdb)

    def aclOuterVlanPcpTest(self, table_stage):
        """
        Verify Outer Vlan Pri Test
        Args:
            table_stage (int): specifies the type of ACL table stage
        """
        print("Validate Outer Vlan Priority")
        acl_action = SAI_PACKET_ACTION_DROP
        outer_vlan_id = 101
        entry_priority = 1
        vlan_pri = 2

        table_bind_points = [SAI_ACL_BIND_POINT_TYPE_SWITCH]
        table_bind_point_type_list = sai_thrift_s32_list_t(
            count=len(table_bind_points), int32list=table_bind_points)

        print("Alloc ACL Table")
        acl_table_id = sai_thrift_create_acl_table(
            self.client,
            acl_stage=table_stage,
            acl_bind_point_type_list=table_bind_point_type_list,
            field_outer_vlan_id=101,
            field_outer_vlan_pri=True)

        print("Alloc ACL Action")
        packet_action = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                s32=acl_action))

        print("Alloc ACL Field Data")
        outer_vlan_id = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(u16=101),
            mask=sai_thrift_acl_field_data_mask_t(u16=4095))

        vlan_pri_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(u8=vlan_pri),
            mask=sai_thrift_acl_field_data_mask_t(u8=0x7))

        print("Alloc ACL Entry")
        acl_entry_id = sai_thrift_create_acl_entry(
            self.client,
            table_id=acl_table_id,
            priority=entry_priority,
            action_packet_action=packet_action,
            field_outer_vlan_id=outer_vlan_id,
            field_outer_vlan_pri=vlan_pri_t)

        print("Alloc ACL Counter")
        acl_counter = sai_thrift_create_acl_counter(
            self.client, table_id=acl_table_id)

        # attach ACL counter to ACL entry
        print("Attach ACL Counter to ACL Entry")
        action_counter = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=acl_counter),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, acl_entry_id,
            action_counter=action_counter)

        # Attach ACL in ingress/egress direction
        if table_stage == SAI_ACL_STAGE_INGRESS:
            print("Attach ACL in ingress direcion")
            sai_thrift_set_switch_attribute(
                    self.client, ingress_acl=acl_table_id)
        else:
            print("Attach ACL in egress direcion")
            sai_thrift_set_switch_attribute(
                    self.client, egress_acl=acl_table_id)
        try:
            # Send VLAN tagged packet
            print("Sending Tagged packet on port 24, ACL Drop")
            send_packet(
                self, self.dev_port24, self.pkt1)
            verify_no_other_packets(self, timeout=1)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter, packets=True)
            self.assertEqual(packets['packets'], 1)
            # Send VLAN untagged packet
            print("Sending Untagged packet with ACL applied, No Drop")
            self.basicUntaggedTest()
            # Send different VLAN priority (No Drop)
            print("Sending different VLAN Pri with ACL applied, No Drop")
            send_packet(self, self.dev_port24, self.pkt2)
            verify_packet(self, self.pkt2, self.dev_port25)
            time.sleep(1)

        finally:
            # cleanup ACL
            sai_thrift_set_switch_attribute(self.client, ingress_acl=0)
            sai_thrift_set_switch_attribute(self.client, egress_acl=0)
            action_counter = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=0),
                enable=True)
            sai_thrift_set_acl_entry_attribute(
                self.client, acl_entry_id,
                action_counter=action_counter)
            sai_thrift_set_acl_counter_attribute(
                self.client, acl_counter, packets=None)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter, packets=True)
            self.assertEqual(packets['packets'], 0)
            sai_thrift_remove_acl_counter(
                self.client, acl_counter)

            sai_thrift_remove_acl_entry(self.client, acl_entry_id)
            sai_thrift_remove_acl_table(self.client, acl_table_id)

    def aclOuterVlanCfiTest(self, table_stage):
        """
        Verify Outer Vlan Dei/Cfi Test
        Args:
            table_stage (int): specifies the type of ACL table stage
        """
        print("Validate Outer Vlan Dei/CFI")
        acl_action = SAI_PACKET_ACTION_DROP
        outer_vlan_id = 101
        entry_priority = 1
        vlan_dei = 0

        table_bind_points = [SAI_ACL_BIND_POINT_TYPE_SWITCH]
        table_bind_point_type_list = sai_thrift_s32_list_t(
            count=len(table_bind_points), int32list=table_bind_points)

        print("Alloc ACL Table")
        acl_table_id = sai_thrift_create_acl_table(
            self.client,
            acl_stage=table_stage,
            acl_bind_point_type_list=table_bind_point_type_list,
            field_outer_vlan_id=101,
            field_outer_vlan_cfi=True)

        print("Alloc ACL Action")
        packet_action = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                s32=acl_action))

        print("Alloc ACL Field Data")
        outer_vlan_id = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(u16=101),
            mask=sai_thrift_acl_field_data_mask_t(u16=4095))

        vlan_dei_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(u8=vlan_dei),
            mask=sai_thrift_acl_field_data_mask_t(u8=0x1))

        print("Alloc ACL Entry")
        acl_entry_id = sai_thrift_create_acl_entry(
            self.client,
            table_id=acl_table_id,
            priority=entry_priority,
            action_packet_action=packet_action,
            field_outer_vlan_id=outer_vlan_id,
            field_outer_vlan_cfi=vlan_dei_t)

        print("Alloc ACL Counter")
        acl_counter = sai_thrift_create_acl_counter(
            self.client, table_id=acl_table_id)

        # attach ACL counter to ACL entry
        print("Attach ACL Counter to ACL Entry")
        action_counter = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=acl_counter),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, acl_entry_id,
            action_counter=action_counter)

        # Attach ACL in ingress/egress direction
        if table_stage == SAI_ACL_STAGE_INGRESS:
            print("Attach ACL in ingress direcion")
            sai_thrift_set_switch_attribute(
                    self.client, ingress_acl=acl_table_id)
        else:
            print("Attach ACL in egress direcion")
            sai_thrift_set_switch_attribute(
                    self.client, egress_acl=acl_table_id)
        try:
            # Send VLAN tagged packet
            print("Sending Tagged packet on port 24, ACL Drop")
            send_packet(
                self, self.dev_port24, self.pkt1)
            verify_no_other_packets(self, timeout=1)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter, packets=True)
            self.assertEqual(packets['packets'], 1)
            # Send VLAN untagged packet
            print("Sending Untagged packet with ACL applied, No Drop")
            self.basicUntaggedTest()
            # Send different VLAN Cfi (No Drop) todo
            #  print("Sending VLAN_cfi=1 with ACL applied, No Drop")
            #  send_packet(self, self.dev_port24, self.pkt2)
            #  verify_packet(self, self.pkt2, self.dev_port25)
            time.sleep(1)

        finally:
            # cleanup ACL
            sai_thrift_set_switch_attribute(self.client, ingress_acl=0)
            sai_thrift_set_switch_attribute(self.client, egress_acl=0)
            action_counter = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=0),
                enable=True)
            sai_thrift_set_acl_entry_attribute(
                self.client, acl_entry_id,
                action_counter=action_counter)
            sai_thrift_set_acl_counter_attribute(
                self.client, acl_counter, packets=None)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter, packets=True)
            self.assertEqual(packets['packets'], 0)
            sai_thrift_remove_acl_counter(
                self.client, acl_counter)

            sai_thrift_remove_acl_entry(self.client, acl_entry_id)
            sai_thrift_remove_acl_table(self.client, acl_table_id)


@group('acl2')
class EgressMirrorVlanPcpCfiTest(SaiHelper):
    """
    Verify ACL outer vlan Priority and Dei/CFI test case
    """

    def setUp(self):
        super(EgressMirrorVlanPcpCfiTest, self).setUp()
        vlan_id = 101
        self.fdbs = []
        mac1 = '00:11:11:11:11:11'
        mac2 = '00:22:22:22:22:22'
        mac3 = '00:33:33:33:33:33'
        mac_action = SAI_PACKET_ACTION_FORWARD

        self.vlan_oid = sai_thrift_create_vlan(self.client, vlan_id)

        # Setup untagged ports
        sai_thrift_set_port_attribute(
            self.client, self.port25, port_vlan_id=vlan_id)
        sai_thrift_set_port_attribute(
            self.client, self.port26, port_vlan_id=vlan_id)

        # Create VLAN and Add Members
        self.port24_bp = sai_thrift_create_bridge_port(
            self.client,
            bridge_id=self.default_1q_bridge,
            port_id=self.port24,
            type=SAI_BRIDGE_PORT_TYPE_PORT,
            admin_state=True)

        self.vlan_member1 = sai_thrift_create_vlan_member(
            self.client,
            vlan_id=self.vlan_oid,
            bridge_port_id=self.port24_bp,
            vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_TAGGED)

        self.port25_bp = sai_thrift_create_bridge_port(
            self.client,
            bridge_id=self.default_1q_bridge,
            port_id=self.port25,
            type=SAI_BRIDGE_PORT_TYPE_PORT,
            admin_state=True)

        self.vlan_member2 = sai_thrift_create_vlan_member(
            self.client,
            vlan_id=self.vlan_oid,
            bridge_port_id=self.port25_bp,
            vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_TAGGED)

        self.port26_bp = sai_thrift_create_bridge_port(
            self.client,
            bridge_id=self.default_1q_bridge,
            port_id=self.port26,
            type=SAI_BRIDGE_PORT_TYPE_PORT,
            admin_state=True)

        self.vlan_member3 = sai_thrift_create_vlan_member(
            self.client,
            vlan_id=self.vlan_oid,
            bridge_port_id=self.port26_bp,
            vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_UNTAGGED)

        self.fdb_entry1 = sai_thrift_fdb_entry_t(
            switch_id=self.switch_id, mac_address=mac1, bv_id=self.vlan_oid)
        sai_thrift_create_fdb_entry(
            self.client,
            self.fdb_entry1,
            type=SAI_FDB_ENTRY_TYPE_STATIC,
            bridge_port_id=self.port24_bp,
            packet_action=mac_action)

        self.fdb_entry2 = sai_thrift_fdb_entry_t(
            switch_id=self.switch_id, mac_address=mac2, bv_id=self.vlan_oid)
        sai_thrift_create_fdb_entry(
            self.client,
            self.fdb_entry2,
            type=SAI_FDB_ENTRY_TYPE_STATIC,
            bridge_port_id=self.port25_bp,
            packet_action=mac_action)

        self.fdb_entry3 = sai_thrift_fdb_entry_t(
            switch_id=self.switch_id, mac_address=mac3, bv_id=self.vlan_oid)
        sai_thrift_create_fdb_entry(
            self.client,
            self.fdb_entry3,
            type=SAI_FDB_ENTRY_TYPE_STATIC,
            bridge_port_id=self.port26_bp,
            packet_action=mac_action)

        self.pkt1 = simple_tcp_packet(
            eth_dst='00:22:22:22:22:22',
            eth_src='00:11:11:11:11:11',
            dl_vlan_enable=True,
            vlan_vid=101,
            vlan_pcp=2,
            dl_vlan_cfi=0,
            ip_src='192.168.100.1',
            ip_dst='172.16.0.1',
            ip_id=102,
            ip_ttl=64)

        self.pkt2 = simple_tcp_packet(
            eth_dst='00:22:22:22:22:22',
            eth_src='00:33:33:33:33:33',
            dl_vlan_enable=True,
            vlan_vid=101,
            vlan_pcp=3,
            dl_vlan_cfi=0,
            ip_src='192.168.100.1',
            ip_dst='172.16.0.1',
            ip_id=102,
            ip_ttl=64)

    def runTest(self):
        print("Testing Vlan Pcp in egress")
        self.mirrorOuterVlanPcpTest(SAI_ACL_STAGE_EGRESS)
        print("Testing Vlan Cfi in egress")
        self.mirrorOuterVlanCfiTest(SAI_ACL_STAGE_EGRESS)

    def tearDown(self):
        sai_thrift_remove_fdb_entry(
            self.client, self.fdb_entry1)
        sai_thrift_remove_fdb_entry(self.client, self.fdb_entry2)
        sai_thrift_remove_fdb_entry(self.client, self.fdb_entry3)

        sai_thrift_set_port_attribute(
            self.client, self.port25, port_vlan_id=int(SAI_NULL_OBJECT_ID))
        sai_thrift_set_port_attribute(
            self.client, self.port26, port_vlan_id=int(SAI_NULL_OBJECT_ID))

        sai_thrift_remove_vlan_member(self.client, self.vlan_member1)
        sai_thrift_remove_vlan_member(self.client, self.vlan_member2)
        sai_thrift_remove_vlan_member(self.client, self.vlan_member3)

        sai_thrift_remove_vlan(self.client, self.vlan_oid)

        sai_thrift_remove_bridge_port(self.client, self.port24_bp)
        sai_thrift_remove_bridge_port(self.client, self.port25_bp)
        sai_thrift_remove_bridge_port(self.client, self.port26_bp)

        super(EgressMirrorVlanPcpCfiTest, self).tearDown()

    def basicUntaggedTest(self):
        # Bind fdb_entry for self.mac to port24 (i.e. egress)
        self.mac = '00:11:11:11:11:12'
        mac_action = SAI_PACKET_ACTION_FORWARD
        fdb_entry = sai_thrift_fdb_entry_t(
            switch_id=self.switch_id,
            mac_address=self.mac,
            bv_id=self.vlan_oid)
        sai_thrift_create_fdb_entry(
            self.client,
            fdb_entry,
            type=SAI_FDB_ENTRY_TYPE_STATIC,
            bridge_port_id=self.port26_bp,
            packet_action=mac_action)
        self.fdbs.append(fdb_entry)

        eth_pkt1 = simple_eth_packet(pktlen=100,
                                     eth_dst=self.mac,
                                     eth_src='00:06:07:08:09:0a')

        # send the test packet(s)
        print("Sending Test packet port 25 -> port 26")
        send_packet(self, self.dev_port25, eth_pkt1)
        verify_packets(self, eth_pkt1, [self.dev_port26])

        sai_thrift_remove_fdb_entry(
            self.client, fdb_entry)
        for fdb in list(self.fdbs):
            self.fdbs.remove(fdb)

    def mirrorOuterVlanPcpTest(self, table_stage):
        """
        Verify Outer Vlan Pri Test
        Args:
            table_stage (int): specifies the type of ACL table stage
        """
        print("Validate Outer Vlan Priority")
        self.mirror_port = self.port8
        outer_vlan_id = 101
        entry_priority = 1
        vlan_pri = 2

        table_bind_points = [SAI_ACL_BIND_POINT_TYPE_SWITCH]
        table_bind_point_type_list = sai_thrift_s32_list_t(
                count=len(table_bind_points), int32list=table_bind_points)

        action_type = [SAI_ACL_ACTION_TYPE_MIRROR_EGRESS]
        action_type_list = sai_thrift_s32_list_t(
                count=len(action_type), int32list=action_type)

        #  ACL table entry
        print("Alloc ACL Table")
        acl_table_id = sai_thrift_create_acl_table(
                self.client,
                acl_stage=table_stage,
                acl_bind_point_type_list=table_bind_point_type_list,
                acl_action_type_list=action_type_list,
                field_outer_vlan_pri=True,
                field_outer_vlan_id=True)
        self.assertNotEqual(acl_table_id, 0)

        print("  IP Mirror Acl entry action in-mirror port 8 ")
        #  alloc mirror port 8 for mirror session
        self.mirror_session = sai_thrift_create_mirror_session(
            self.client,
            monitor_port=self.mirror_port,
            type=SAI_MIRROR_SESSION_TYPE_LOCAL)

        #  setup action to mirror
        print("Alloc ACL Action")
        mirror_session_list = sai_thrift_object_list_t(
            count=1, idlist=[self.mirror_session])
        action_mirror = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                objlist=mirror_session_list))

        print("Alloc ACL Field Data")
        outer_vlan_id = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(u16=101),
            mask=sai_thrift_acl_field_data_mask_t(u16=4095))

        vlan_pri_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(u8=vlan_pri),
            mask=sai_thrift_acl_field_data_mask_t(u8=0x7))

        print("Alloc ACL Entry")
        acl_entry_id = sai_thrift_create_acl_entry(
            self.client,
            table_id=acl_table_id,
            priority=entry_priority,
            field_outer_vlan_id=outer_vlan_id,
            field_outer_vlan_pri=vlan_pri_t,
            action_mirror_egress=action_mirror)

        print("Alloc ACL Counter")
        acl_counter = sai_thrift_create_acl_counter(
            self.client, table_id=acl_table_id)

        # attach ACL counter to ACL entry
        print("Attach ACL Counter to ACL Entry")
        action_counter = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=acl_counter),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, acl_entry_id,
            action_counter=action_counter)

        # Attach ACL in egress direction
        print("Attach ACL in egress direcion")
        sai_thrift_set_switch_attribute(
                self.client, egress_acl=acl_table_id)
        try:
            # Send VLAN tagged packet
            print("Sending Tagged packet on port 24, ACL Mirror")
            send_packet(
                self, self.dev_port24, self.pkt1)
            verify_each_packet_on_each_port(
                self,
                [self.pkt1, self.pkt1],
                [self.dev_port25, self.dev_port8])
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter, packets=True)
            self.assertEqual(packets['packets'], 1)
            # Send VLAN untagged packet
            print("Sending Untagged packet with ACL applied, No Mirror")
            self.basicUntaggedTest()
            # Send different VLAN priority (No Drop)
            print("Sending different VLAN Pri with ACL applied, No Mirror")
            send_packet(self, self.dev_port24, self.pkt2)
            verify_packet(self, self.pkt2, self.dev_port25)
            time.sleep(1)

        finally:
            # cleanup ACL
            sai_thrift_set_switch_attribute(self.client, ingress_acl=0)
            sai_thrift_set_switch_attribute(self.client, egress_acl=0)
            action_counter = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=0),
                enable=True)
            sai_thrift_set_acl_entry_attribute(
                self.client, acl_entry_id,
                action_counter=action_counter)
            sai_thrift_set_acl_counter_attribute(
                self.client, acl_counter, packets=None)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter, packets=True)
            self.assertEqual(packets['packets'], 0)
            sai_thrift_remove_acl_counter(
                self.client, acl_counter)

            sai_thrift_remove_acl_entry(self.client, acl_entry_id)
            sai_thrift_remove_acl_table(self.client, acl_table_id)

    def mirrorOuterVlanCfiTest(self, table_stage):
        """
        Verify Outer Vlan Dei/Cfi Test
        Args:
            table_stage (int): specifies the type of ACL table stage
        """
        print("Validate Outer Vlan Dei/CFI")
        self.mirror_port = self.port8
        outer_vlan_id = 101
        entry_priority = 1
        vlan_dei = 0

        table_bind_points = [SAI_ACL_BIND_POINT_TYPE_SWITCH]
        table_bind_point_type_list = sai_thrift_s32_list_t(
                count=len(table_bind_points), int32list=table_bind_points)

        action_type = [SAI_ACL_ACTION_TYPE_MIRROR_EGRESS]
        action_type_list = sai_thrift_s32_list_t(
                count=len(action_type), int32list=action_type)

        #  ACL table entry
        print("Alloc ACL Table")
        acl_table_id = sai_thrift_create_acl_table(
                self.client,
                acl_stage=table_stage,
                acl_bind_point_type_list=table_bind_point_type_list,
                acl_action_type_list=action_type_list,
                field_outer_vlan_pri=True,
                field_outer_vlan_id=True)
        self.assertNotEqual(acl_table_id, 0)

        print("  IP Mirror Acl entry action in-mirror port 8 ")
        #  alloc mirror port 8 for mirror session
        self.mirror_session = sai_thrift_create_mirror_session(
            self.client,
            monitor_port=self.mirror_port,
            type=SAI_MIRROR_SESSION_TYPE_LOCAL)

        #  setup action to mirror
        print("Alloc ACL Action")
        mirror_session_list = sai_thrift_object_list_t(
            count=1, idlist=[self.mirror_session])
        action_mirror = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                objlist=mirror_session_list))

        print("Alloc ACL Field Data")
        outer_vlan_id = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(u16=101),
            mask=sai_thrift_acl_field_data_mask_t(u16=4095))

        vlan_dei_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(u8=vlan_dei),
            mask=sai_thrift_acl_field_data_mask_t(u8=0x1))

        print("Alloc ACL Entry")
        acl_entry_id = sai_thrift_create_acl_entry(
            self.client,
            table_id=acl_table_id,
            priority=entry_priority,
            field_outer_vlan_id=outer_vlan_id,
            field_outer_vlan_cfi=vlan_dei_t,
            action_mirror_egress=action_mirror)

        print("Alloc ACL Counter")
        acl_counter = sai_thrift_create_acl_counter(
            self.client, table_id=acl_table_id)

        # attach ACL counter to ACL entry
        print("Attach ACL Counter to ACL Entry")
        action_counter = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=acl_counter),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, acl_entry_id,
            action_counter=action_counter)

        # Attach ACL in egress direction
        print("Attach ACL in egress direcion")
        sai_thrift_set_switch_attribute(
                self.client, egress_acl=acl_table_id)
        try:
            # Send VLAN tagged packet
            print("Sending Tagged packet on port 24, ACL Mirror")
            send_packet(
                self, self.dev_port24, self.pkt1)
            verify_each_packet_on_each_port(
                self,
                [self.pkt1, self.pkt1],
                [self.dev_port25, self.dev_port8])
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter, packets=True)
            self.assertEqual(packets['packets'], 1)
            # Send VLAN untagged packet
            print("Sending Untagged packet with ACL applied, No Mirror")
            self.basicUntaggedTest()
            # Send different VLAN CFI (No Drop) todo
            #  print("Sending VLAN_cfi=1 with ACL applied, No Mirror")
            #  send_packet(self, self.dev_port24, self.pkt2)
            #  verify_packet(self, self.pkt2, self.dev_port25)
            time.sleep(1)

        finally:
            # cleanup ACL
            sai_thrift_set_switch_attribute(self.client, egress_acl=0)
            action_counter = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=0),
                enable=True)
            sai_thrift_set_acl_entry_attribute(
                self.client, acl_entry_id,
                action_counter=action_counter)
            sai_thrift_set_acl_counter_attribute(
                self.client, acl_counter, packets=None)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter, packets=True)
            self.assertEqual(packets['packets'], 0)
            sai_thrift_remove_acl_counter(
                self.client, acl_counter)

            sai_thrift_remove_acl_entry(self.client, acl_entry_id)
            sai_thrift_remove_acl_table(self.client, acl_table_id)


@group('acl2')
class EgressQoSVlanPcpRewriteSVITest(SaiHelper):
    """
    Verify PCP rewrite for egress ip qos ACL on SVI
    """

    def setUp(self):
        super(EgressQoSVlanPcpRewriteSVITest, self).setUp()

        self.dmac1 = "00:22:22:33:44:55"
        self.dmac2 = "00:22:33:33:44:55"
        self.dst_v6 = '1234:5678:8ab4:5ef0:4422:1133:5500:55aa'
        self.dst_v6_subnet = '1234:5678:8ab4:5ef0:4422:1133:5500:0000/114'

        self.port26_bp = sai_thrift_create_bridge_port(
            self.client,
            bridge_id=self.default_1q_bridge,
            port_id=self.port26,
            type=SAI_BRIDGE_PORT_TYPE_PORT,
            admin_state=True)

        self.port27_bp = sai_thrift_create_bridge_port(
            self.client,
            bridge_id=self.default_1q_bridge,
            port_id=self.port27,
            type=SAI_BRIDGE_PORT_TYPE_PORT,
            admin_state=True)

        #  create vlan 111 with member port 26, tagged
        self.vlan111 = sai_thrift_create_vlan(self.client, vlan_id=111)
        self.vlan111_member1 = sai_thrift_create_vlan_member(
            self.client,
            vlan_id=self.vlan111,
            bridge_port_id=self.port26_bp,
            vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_TAGGED)

        #  vlan 111 router interface
        self.vlan111_rif = sai_thrift_create_router_interface(
            self.client,
            type=SAI_ROUTER_INTERFACE_TYPE_VLAN,
            virtual_router_id=self.default_vrf,
            vlan_id=self.vlan111)

        #  create nexthop, neighbor and route for SVI
        self.nexthop1 = sai_thrift_create_next_hop(
            self.client,
            ip=sai_ipaddress('10.10.0.2'),
            router_interface_id=self.vlan111_rif,
            type=SAI_NEXT_HOP_TYPE_IP)
        self.neighbor_entry1 = sai_thrift_neighbor_entry_t(
            rif_id=self.vlan111_rif, ip_address=sai_ipaddress('10.10.0.2'))
        sai_thrift_create_neighbor_entry(
            self.client, self.neighbor_entry1, dst_mac_address=self.dmac1)
        self.route_entry1 = sai_thrift_route_entry_t(
            vr_id=self.default_vrf, destination=sai_ipprefix('10.10.10.2/32'))
        sai_thrift_create_route_entry(
            self.client, self.route_entry1, next_hop_id=self.nexthop1)

        #  create vlan 222 with member port 27, tagged
        self.vlan222 = sai_thrift_create_vlan(self.client, vlan_id=222)
        self.vlan222_member1 = sai_thrift_create_vlan_member(
            self.client,
            vlan_id=self.vlan222,
            bridge_port_id=self.port27_bp,
            vlan_tagging_mode=SAI_VLAN_TAGGING_MODE_TAGGED)

        #  vlan 222 router interface
        self.vlan222_rif = sai_thrift_create_router_interface(
            self.client,
            type=SAI_ROUTER_INTERFACE_TYPE_VLAN,
            virtual_router_id=self.default_vrf,
            vlan_id=self.vlan222)

        #  create nexthop, neighbor and route for SVI
        self.nexthop2 = sai_thrift_create_next_hop(
            self.client,
            ip=sai_ipaddress('20.10.0.2'),
            router_interface_id=self.vlan222_rif,
            type=SAI_NEXT_HOP_TYPE_IP)
        self.neighbor_entry2 = sai_thrift_neighbor_entry_t(
            rif_id=self.vlan222_rif, ip_address=sai_ipaddress('20.10.0.2'))
        sai_thrift_create_neighbor_entry(
            self.client, self.neighbor_entry2, dst_mac_address=self.dmac2)
        self.route_entry2 = sai_thrift_route_entry_t(
            vr_id=self.default_vrf, destination=sai_ipprefix('20.10.10.2/32'))
        sai_thrift_create_route_entry(
            self.client, self.route_entry2, next_hop_id=self.nexthop2)

        #  allocate v6 neighbor, nhop, route
        self.v6_nbr_entry = sai_thrift_neighbor_entry_t(
                    rif_id=self.vlan222_rif,
                    ip_address=sai_ipaddress(self.dst_v6))
        sai_thrift_create_neighbor_entry(
                    self.client,
                    self.v6_nbr_entry,
                    dst_mac_address=self.dmac2)

        self.v6_nhop = sai_thrift_create_next_hop(
                    self.client,
                    ip=sai_ipaddress(self.dst_v6),
                    router_interface_id=self.vlan222_rif,
                    type=SAI_NEXT_HOP_TYPE_IP)

        self.v6_route_entry = sai_thrift_route_entry_t(
                    vr_id=self.default_vrf,
                    destination=sai_ipprefix(self.dst_v6_subnet))
        sai_thrift_create_route_entry(
                    self.client,
                    self.v6_route_entry,
                    next_hop_id=self.v6_nhop)

        mac_action = SAI_PACKET_ACTION_FORWARD

        #  FDB entries
        self.fdb_entry26 = sai_thrift_fdb_entry_t(switch_id=self.switch_id,
                                                  mac_address=self.dmac1,
                                                  bv_id=self.vlan111)
        sai_thrift_create_fdb_entry(self.client,
                                    self.fdb_entry26,
                                    type=SAI_FDB_ENTRY_TYPE_STATIC,
                                    bridge_port_id=self.port26_bp,
                                    packet_action=mac_action)

        self.fdb_entry27 = sai_thrift_fdb_entry_t(switch_id=self.switch_id,
                                                  mac_address=self.dmac2,
                                                  bv_id=self.vlan222)
        sai_thrift_create_fdb_entry(self.client,
                                    self.fdb_entry27,
                                    type=SAI_FDB_ENTRY_TYPE_STATIC,
                                    bridge_port_id=self.port27_bp,
                                    packet_action=mac_action)

        print("Configuring PCP maps")
        #  setup pcp to tc mapping
        #  Port 26 qos map
        ingress_pcp_list = [1, 2]
        ingress_tc_list = [20, 24]
        self.p0_qos_pcp_to_tc_map = create_and_verify_qos_map(
            self.client, SAI_QOS_MAP_TYPE_DOT1P_TO_TC, ingress_pcp_list,
            ingress_tc_list)
        #  Verify QosMap value list
        self.assertTrue(self.p0_qos_pcp_to_tc_map != 0,
                        "Failed to create pcp_to_tc map")

        #  setup tc to dscp mapping
        #  Port 27 qos map
        egress_tc_color_list = [
            [20, 0],
            [24, 0],
        ]
        egress_pcp_list = [4, 5]
        self.p1_qos_tc_to_pcp_map = create_and_verify_qos_map(
            self.client,
            SAI_QOS_MAP_TYPE_TC_AND_COLOR_TO_DOT1P,
            egress_tc_color_list,
            egress_pcp_list)
        self.assertTrue(self.p1_qos_tc_to_pcp_map != 0,
                        "Failed to create tc_to_pcp map")

        table_stage_egress = SAI_ACL_STAGE_EGRESS
        table_bind_point_list = [SAI_ACL_BIND_POINT_TYPE_SWITCH]
        action = SAI_PACKET_ACTION_FORWARD

        table_bind_point_type_list = sai_thrift_s32_list_t(
            count=len(table_bind_point_list),
            int32list=table_bind_point_list)

        self.packet_action = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                s32=action))

        self.acl_table = sai_thrift_create_acl_table(
            self.client,
            acl_stage=table_stage_egress,
            field_outer_vlan_pri=True,
            acl_bind_point_type_list=table_bind_point_type_list)

    def runTest(self):
        try:
            sai_thrift_set_port_attribute(
                self.client,
                self.port26,
                qos_dot1p_to_tc_map=self.p0_qos_pcp_to_tc_map)
            sai_thrift_set_port_attribute(
                self.client,
                self.port27,
                qos_tc_and_color_to_dot1p_map=self.p1_qos_tc_to_pcp_map)

            #  match vlan pcp 4
            vlan_pri = 4
            vlan_pri_t = sai_thrift_acl_field_data_t(
                    data=sai_thrift_acl_field_data_data_t(u8=vlan_pri),
                    mask=sai_thrift_acl_field_data_mask_t(u8=0x7))

            #  set pcp to 5
            action_set_outer_vlan_pri = sai_thrift_acl_action_data_t(
                enable=True,
                parameter=sai_thrift_acl_action_parameter_t(u8=5))

            acl_entry_id = sai_thrift_create_acl_entry(
                self.client,
                table_id=self.acl_table,
                action_set_outer_vlan_pri=action_set_outer_vlan_pri,
                field_outer_vlan_pri=vlan_pri_t,
                action_packet_action=self.packet_action)

            #  ACL counter
            acl_counter_egress = sai_thrift_create_acl_counter(
                self.client, table_id=self.acl_table)
            #  attach ACL counter to ACL entry
            action_counter_egress = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=acl_counter_egress),
                enable=True)
            sai_thrift_set_acl_entry_attribute(
                self.client, acl_entry_id,
                action_counter=action_counter_egress)

            tagged_pkt = simple_tcp_packet(eth_dst=ROUTER_MAC,
                                           eth_src=self.dmac1,
                                           ip_dst='20.10.10.2',
                                           ip_src='192.168.0.1',
                                           dl_vlan_enable=True,
                                           vlan_vid=111,
                                           vlan_pcp=1,
                                           ip_ttl=64,
                                           pktlen=104)

            tagged_exp_pkt = simple_tcp_packet(eth_dst=self.dmac2,
                                               eth_src=ROUTER_MAC,
                                               ip_dst='20.10.10.2',
                                               ip_src='192.168.0.1',
                                               dl_vlan_enable=True,
                                               vlan_vid=222,
                                               vlan_pcp=4,
                                               ip_ttl=63,
                                               pktlen=104)

            tagged_pktv6 = simple_tcpv6_packet(eth_dst=ROUTER_MAC,
                                               eth_src=self.dmac1,
                                               dl_vlan_enable=True,
                                               vlan_vid=111,
                                               vlan_pcp=1,
                                               ipv6_src='2000::1',
                                               ipv6_dst=self.dst_v6,
                                               ipv6_hlim=64,
                                               pktlen=100)

            tagged_exp_pktv6 = simple_tcpv6_packet(eth_dst=self.dmac2,
                                                   eth_src=ROUTER_MAC,
                                                   dl_vlan_enable=True,
                                                   vlan_vid=222,
                                                   vlan_pcp=4,
                                                   ipv6_src='2000::1',
                                                   ipv6_dst=self.dst_v6,
                                                   ipv6_hlim=63,
                                                   pktlen=100)

            #  Test traffic without QoS ACL applied
            #  pcp 1 -> ingress qos_map -> tc 20 -> pcp 4
            print("Sending v4 traffic without ACL applied")
            send_packet(self, self.dev_port26, tagged_pkt)
            verify_packet(self, tagged_exp_pkt, self.dev_port27)

            print("Sending v6 traffic without ACL applied")
            send_packet(self, self.dev_port26, tagged_pktv6)
            verify_packet(self, tagged_exp_pktv6, self.dev_port27)

            #  Test traffic with QoS ACL applied
            #  pcp 1 -> tc 20 -> pcp 4-> QoS ACL -> pcp 5
            #  ACL entry should take precedence over qos-map
            sai_thrift_set_switch_attribute(
                self.client, egress_acl=self.acl_table)
            tagged_exp_pkt[Dot1Q].prio = 5
            tagged_exp_pktv6[Dot1Q].prio = 5

            print("Sending v4 traffic with ACL applied")
            send_packet(self, self.dev_port26, tagged_pkt)
            verify_packet(self, tagged_exp_pkt, self.dev_port27)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter_egress, packets=True)
            self.assertEqual(packets['packets'], 1)
            print("pass packet w/ mapped pcp 1 -> 5")

            print("Sending v6 traffic with ACL applied")
            send_packet(self, self.dev_port26, tagged_pktv6)
            verify_packet(self, tagged_exp_pktv6, self.dev_port27)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter_egress, packets=True)
            self.assertEqual(packets['packets'], 2)
            print("pass packet w/ mapped pcp 1 -> 5")

        finally:
            #  delete qos map and acl counter and entry
            action_counter_egress = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=0),
                enable=True)
            sai_thrift_set_acl_entry_attribute(
                self.client, acl_entry_id,
                action_counter=action_counter_egress)
            sai_thrift_set_acl_counter_attribute(
                self.client, acl_counter_egress, packets=None)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter_egress, packets=True)
            self.assertEqual(packets['packets'], 0)
            sai_thrift_remove_acl_counter(self.client, acl_counter_egress)
            sai_thrift_set_port_attribute(self.client, self.port26,
                                          qos_dot1p_to_tc_map=0)
            sai_thrift_set_port_attribute(self.client, self.port27,
                                          qos_tc_and_color_to_dot1p_map=0)
            sai_thrift_remove_qos_map(self.client, self.p0_qos_pcp_to_tc_map)
            sai_thrift_remove_qos_map(self.client, self.p1_qos_tc_to_pcp_map)
            sai_thrift_remove_acl_entry(self.client, acl_entry_id)

    def tearDown(self):
        sai_thrift_set_switch_attribute(self.client, egress_acl=0)
        sai_thrift_remove_fdb_entry(self.client, self.fdb_entry26)
        sai_thrift_remove_fdb_entry(self.client, self.fdb_entry27)
        sai_thrift_remove_vlan_member(self.client, self.vlan111_member1)
        sai_thrift_remove_vlan_member(self.client, self.vlan222_member1)
        sai_thrift_remove_bridge_port(self.client, self.port26_bp)
        sai_thrift_remove_bridge_port(self.client, self.port27_bp)

        sai_thrift_remove_route_entry(self.client, self.route_entry1)
        sai_thrift_remove_route_entry(self.client, self.route_entry2)
        sai_thrift_remove_route_entry(self.client, self.v6_route_entry)
        sai_thrift_remove_next_hop(self.client, self.nexthop1)
        sai_thrift_remove_next_hop(self.client, self.nexthop2)
        sai_thrift_remove_next_hop(self.client, self.v6_nhop)
        sai_thrift_remove_neighbor_entry(self.client, self.neighbor_entry1)
        sai_thrift_remove_neighbor_entry(self.client, self.neighbor_entry2)
        sai_thrift_remove_neighbor_entry(self.client, self.v6_nbr_entry)
        sai_thrift_remove_router_interface(self.client, self.vlan111_rif)
        sai_thrift_remove_router_interface(self.client, self.vlan222_rif)
        sai_thrift_remove_vlan(self.client, self.vlan111)
        sai_thrift_remove_vlan(self.client, self.vlan222)
        sai_thrift_remove_acl_table(self.client, self.acl_table)
        super(EgressQoSVlanPcpRewriteSVITest, self).tearDown()


@group('acl2')
class IngressVlanPcpTest(SaiHelper):
    """
    Verify matching on Vlan PCP for V4&V6 traffic
    for Mirror, Qos and PBR Acl Tables
    """
    dst_ip_subnet = '100.55.155.0'
    dst_ip = '100.55.155.100'
    dst_mac = '00:11:22:33:44:55'
    port_smac = '00:22:22:22:22:22'
    port_src_ip = '55.55.55.100'
    tcp_dst_port = 5555
    tcp_src_port = 4444

    dst_v6_subnet = '1234:5678:8ab4:5ef0:4422:1133:5500:0000/114'
    dst_v6 = '1234:5678:8ab4:5ef0:4422:1133:5500:55aa'
    port_src_v6 = '2000::100'
    dscp_val = 14

    lower_prio = 5

    def setUp(self):
        super(IngressVlanPcpTest, self).setUp()

        egress_rif1 = self.port10_rif

        #  allocate v4 neighbor, nhop, route
        print("Allocate V4 neighbor with ip %s, router interface %x"
              " dst_mac %s " % (self.dst_ip, egress_rif1, self.dst_mac))
        self.nbr_entry = sai_thrift_neighbor_entry_t(
            rif_id=egress_rif1,
            ip_address=sai_ipaddress(self.dst_ip))
        sai_thrift_create_neighbor_entry(
            self.client,
            self.nbr_entry,
            dst_mac_address=self.dst_mac)

        print("Allocate nhop with ip %s, router interface %x"
              % (self.dst_ip, egress_rif1))
        self.nhop = sai_thrift_create_next_hop(
            self.client,
            ip=sai_ipaddress(self.dst_ip),
            router_interface_id=egress_rif1,
            type=SAI_NEXT_HOP_TYPE_IP)

        print("Allocate route with ip subnet %s --> router interface %x"
              % (self.dst_ip_subnet, egress_rif1))
        self.route_entry = sai_thrift_route_entry_t(
            vr_id=self.default_vrf,
            destination=sai_ipprefix(self.dst_ip_subnet))
        sai_thrift_create_route_entry(
            self.client,
            self.route_entry,
            next_hop_id=egress_rif1)

        #  allocate v6 neighbor, nhop, route
        print("Allocate V6 neighbor with ip %s, router interface %x"
              " dst_mac %s " % (self.dst_v6, egress_rif1, self.dst_mac))
        self.v6_nbr_entry = sai_thrift_neighbor_entry_t(
            rif_id=egress_rif1,
            ip_address=sai_ipaddress(self.dst_v6))
        sai_thrift_create_neighbor_entry(
            self.client,
            self.v6_nbr_entry,
            dst_mac_address=self.dst_mac)

        print("Allocate v6 nhop with ip %s, router interface %x"
              % (self.dst_v6, egress_rif1))
        self.v6_nhop = sai_thrift_create_next_hop(
            self.client,
            ip=sai_ipaddress(self.dst_v6),
            router_interface_id=egress_rif1,
            type=SAI_NEXT_HOP_TYPE_IP)

        print("Allocate v6 route with ip prefix %s --> nhop %x"
              % (self.dst_v6_subnet, self.v6_nhop))
        self.v6_route_entry = sai_thrift_route_entry_t(
            vr_id=self.default_vrf,
            destination=sai_ipprefix(self.dst_v6_subnet))
        sai_thrift_create_route_entry(
            self.client,
            self.v6_route_entry,
            next_hop_id=self.v6_nhop)

        #  ACL table
        self.table_stage = SAI_ACL_STAGE_INGRESS

        bpoints = [SAI_ACL_BIND_POINT_TYPE_SWITCH]
        self.bpoint_type_list = sai_thrift_s32_list_t(
            count=len(bpoints), int32list=bpoints)

        #  v4 pkt for in-port 11
        self.pkt = simple_tcp_packet(
            eth_dst=ROUTER_MAC,
            eth_src=self.port_smac,
            ip_dst=self.dst_ip,
            ip_src=self.port_src_ip,
            ip_id=105,
            tcp_sport=self.tcp_src_port,
            tcp_dport=self.tcp_dst_port,
            tcp_flags=41,
            pktlen=104,
            ip_ttl=64,
            ip_dscp=self.dscp_val,
            dl_vlan_enable=True,
            vlan_pcp=3)
        self.e_pkt = simple_tcp_packet(
            eth_dst=self.dst_mac,
            eth_src=ROUTER_MAC,
            ip_dst=self.dst_ip,
            ip_src=self.port_src_ip,
            ip_id=105,
            tcp_sport=self.tcp_src_port,
            tcp_dport=self.tcp_dst_port,
            tcp_flags=41,
            pktlen=100,
            ip_ttl=63,
            ip_dscp=self.dscp_val)
        self.tpkt = simple_tcp_packet(
            eth_dst=ROUTER_MAC,
            eth_src=self.port_smac,
            ip_dst=self.dst_ip,
            ip_src=self.port_src_ip,
            ip_id=105,
            tcp_sport=self.tcp_src_port,
            tcp_dport=self.tcp_dst_port,
            tcp_flags=41,
            pktlen=104,
            ip_ttl=64,
            ip_dscp=self.dscp_val,
            dl_vlan_enable=True,
            vlan_pcp=2)
        self.te_pkt = simple_tcp_packet(
            eth_dst=self.dst_mac,
            eth_src=ROUTER_MAC,
            ip_dst=self.dst_ip,
            ip_src=self.port_src_ip,
            ip_id=105,
            tcp_sport=self.tcp_src_port,
            tcp_dport=self.tcp_dst_port,
            tcp_flags=41,
            pktlen=100,
            ip_ttl=63,
            ip_dscp=self.dscp_val)
        #  v6 pkt for in-port 11
        self.pkt6 = simple_tcpv6_packet(
            eth_dst=ROUTER_MAC,
            eth_src=self.port_smac,
            ipv6_dst=self.dst_v6,
            ipv6_src=self.port_src_v6,
            tcp_sport=self.tcp_src_port,
            tcp_dport=self.tcp_dst_port,
            tcp_flags=41,
            pktlen=104,
            ipv6_hlim=64,
            ipv6_dscp=self.dscp_val,
            dl_vlan_enable=True,
            vlan_pcp=3)
        self.e_pkt6 = simple_tcpv6_packet(
            eth_dst=self.dst_mac,
            eth_src=ROUTER_MAC,
            ipv6_dst=self.dst_v6,
            ipv6_src=self.port_src_v6,
            tcp_sport=self.tcp_src_port,
            tcp_dport=self.tcp_dst_port,
            tcp_flags=41,
            pktlen=100,
            ipv6_hlim=63,
            ipv6_dscp=self.dscp_val)
        self.tpkt6 = simple_tcpv6_packet(
            eth_dst=ROUTER_MAC,
            eth_src=self.port_smac,
            ipv6_dst=self.dst_v6,
            ipv6_src=self.port_src_v6,
            tcp_sport=self.tcp_src_port,
            tcp_dport=self.tcp_dst_port,
            tcp_flags=41,
            pktlen=104,
            ipv6_hlim=64,
            ipv6_dscp=self.dscp_val,
            dl_vlan_enable=True,
            vlan_pcp=2)
        self.te_pkt6 = simple_tcpv6_packet(
            eth_dst=self.dst_mac,
            eth_src=ROUTER_MAC,
            ipv6_dst=self.dst_v6,
            ipv6_src=self.port_src_v6,
            tcp_sport=self.tcp_src_port,
            tcp_dport=self.tcp_dst_port,
            tcp_flags=41,
            pktlen=100,
            ipv6_hlim=63,
            ipv6_dscp=self.dscp_val)

    def AllTrafficTest(self,
                       table_type,
                       pkt_test_type="v4"):
        '''
        Verify Vlan PCP for V4/V6 tcp pkts for ingress ACl tables/entries
        '''
        print("    Test with %s traffic " % (pkt_test_type))

        if pkt_test_type != "v4" and pkt_test_type != "v6":
            print("    Incorrect traffic pkt type, must be v4 or v6 ")
            return

        print('   -----------------------------------------------------------')
        if pkt_test_type == "v6":
            port_pkt = self.pkt6
            port_e_pkt = self.e_pkt6
            port_tpkt = self.tpkt6
            port_te_pkt = self.te_pkt6
            print("    Tx below V6 tcp packet from port 11 ")
            print("     [%s to %s] " % (self.port_src_v6, self.dst_v6))
            print("     L4 port src [%d] dst [%d], flags 41, ip dscp 14"
                  % (self.tcp_src_port, self.tcp_dst_port))
        else:
            port_pkt = self.pkt
            port_e_pkt = self.e_pkt
            port_tpkt = self.tpkt
            port_te_pkt = self.te_pkt
            print("    Tx below V4 tcp packet from port 11 ")
            print("     [%s to %s] " % (self.port_src_ip, self.dst_ip))
            print("     L4 port src [%d] dst [%d], flags 41, ip dscp 14"
                  % (self.tcp_src_port, self.tcp_dst_port))

        #  Qos Acl set-tc action --> verify tc-dscp map
        #  To verify, change Rx pkt to have new tos value
        #  For Acl entry action tc 10 --> 40 dscp
        if table_type == "Qos-Acl":
            temp_e_pkt = port_e_pkt.copy()
            if pkt_test_type == "v6":
                temp_e_pkt[IPv6].tc = 40 << 2
            else:
                temp_e_pkt[IP].tos = 40 << 2
            port_e_pkt = temp_e_pkt

        #  verify traffic
        send_packet(self, self.dev_port11, port_pkt)
        #  verify acl entry action/stats
        if table_type == "Mir-Acl":
            print("      ----> route to port 10 ")
            print("      ----> mirror in-pkt to port 8 ")
            verify_each_packet_on_each_port(
                self,
                [port_e_pkt, port_pkt],
                [self.dev_port10, self.rx_mirror_port])
            #  verify non-matching pkt
            print("      ----> Non-Matching packet route to port 10 ")
            send_packet(self, self.dev_port11, port_tpkt)
            verify_packets(self, port_te_pkt, [self.dev_port10])
        elif table_type == "Pbr-Acl":
            print("      ----> pbr to nhop[port 13] ")
            verify_packets(self, port_e_pkt, [self.rx_pbr_port])
            #  verify non-matching pkt
            print("      ----> Non-Matching packet route to port 10 ")
            send_packet(self, self.dev_port11, port_tpkt)
            verify_packets(self, port_te_pkt, [self.dev_port10])
        else:
            print("      ----> route to port 10 ")
            verify_packets(self, port_e_pkt, [self.dev_port10])
            #  verify non-matching pkt
            print("      ----> Non-Matching packet route to port 10 ")
            print("      ----> with out setting tc ")
            send_packet(self, self.dev_port11, port_tpkt)
            verify_packets(self, port_te_pkt, [self.dev_port10])
        self.acl_cnt += 1
        time.sleep(1)
        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.acl_counter, packets=True)
        self.assertEqual(packets['packets'], self.acl_cnt)
        print('   -----------------------------------------------------------')

    def ingressPcpQosAclTableTest(self):
        '''
        Verify Vlan PCP field with port as in-port
        using switch b-point in QoS ACL table
        '''
        print(" ingressPcpQosAclTableTest")

        try:
            action_type = [SAI_ACL_ACTION_TYPE_SET_TC]
            qos_action_type_list = sai_thrift_s32_list_t(
                count=len(action_type), int32list=action_type)

            qos_acl_table = sai_thrift_create_acl_table(
                self.client,
                acl_stage=self.table_stage,
                acl_bind_point_type_list=self.bpoint_type_list,
                field_outer_vlan_pri=True,
                acl_action_type_list=qos_action_type_list)
            self.assertNotEqual(qos_acl_table, 0)

            #  map all tc values with color green to dscp
            #  This will change the dscp value on egress
            #  based of tc value set by qos Acl entry
            egress_tc_color_list = [
                [10, 0],
                [7, 0],
                [8, 0],
                [5, 0],  # green
            ]
            egress_dscp_list = [
                40, 25, 18, 55,  # mapping green
            ]
            qos_tc_color_to_dscp_map = create_and_verify_qos_map(
                self.client,
                SAI_QOS_MAP_TYPE_TC_AND_COLOR_TO_DSCP,
                egress_tc_color_list,
                egress_dscp_list)
            self.assertTrue(qos_tc_color_to_dscp_map != 0,
                            "  Fail to alloc tc_color_to_dscp map  ")

            #  map above qos map to egress port
            status = sai_thrift_set_port_attribute(
                self.client,
                self.port10,
                qos_tc_and_color_to_dscp_map=qos_tc_color_to_dscp_map)
            self.assertEqual(status, SAI_STATUS_SUCCESS,
                             "  Fail to set tc_color_to_dscp map to port 10  ")
            attr = sai_thrift_get_port_attribute(
                self.client, self.port10,
                qos_tc_and_color_to_dscp_map=True)
            self.assertEqual(attr['qos_tc_and_color_to_dscp_map'],
                             qos_tc_color_to_dscp_map)

            print("  Qos Acl entry action set-tc to 10-->40 dscp  ")
            #  setup action to set tc
            action_tc_set = sai_thrift_acl_action_data_t(
                enable=True,
                parameter=sai_thrift_acl_action_parameter_t(u8=10))
            a_type_t = "action_set_tc"
            a_value_t = {a_type_t: action_tc_set}

            self.testAllTableField(qos_acl_table, a_value_t, "Qos-Acl", "v4")
            self.testAllTableField(qos_acl_table, a_value_t, "Qos-Acl", "v6")

        finally:
            #  cleanup egress qos map
            status = sai_thrift_set_port_attribute(
                self.client, self.port10,
                qos_tc_and_color_to_dscp_map=0)
            self.assertEqual(status, SAI_STATUS_SUCCESS,
                             "  Fail to reset tc_color_to_dscp for port 10  ")
            sai_thrift_remove_qos_map(self.client, qos_tc_color_to_dscp_map)

            #  cleanup acl group member, table
            sai_thrift_remove_acl_table(self.client, qos_acl_table)

    def ingressPcpMirrorAclTableTest(self):
        '''
        Verify Vlan PCP field with port as in-port
        using switch b-point in IP Mirror ACL table
        '''
        print(" ingressPcpMirrorAclTableTest ")

        self.rx_mirror_port = self.dev_port8
        self.mirror_port = self.port8

        try:
            action_type = [SAI_ACL_ACTION_TYPE_MIRROR_INGRESS]
            action_type_list = sai_thrift_s32_list_t(
                count=len(action_type), int32list=action_type)

            mir_acl_table = sai_thrift_create_acl_table(
                self.client,
                acl_stage=self.table_stage,
                acl_bind_point_type_list=self.bpoint_type_list,
                field_outer_vlan_pri=True,
                acl_action_type_list=action_type_list)
            self.assertNotEqual(mir_acl_table, 0)

            #  alloc mirror port 8 for mirror session
            self.mirror_session = sai_thrift_create_mirror_session(
                self.client,
                monitor_port=self.mirror_port,
                type=SAI_MIRROR_SESSION_TYPE_LOCAL)

            print("  IP Mirror Acl entry action in-mirror port 8 ")
            #  setup action to mirror
            mirror_session_list = sai_thrift_object_list_t(
                count=1, idlist=[self.mirror_session])
            action_mirror = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    objlist=mirror_session_list))
            a_type_t = "action_mirror_ingress"
            a_value_t = {a_type_t: action_mirror}

            self.testAllTableField(mir_acl_table, a_value_t, "Mir-Acl", "v4")
            self.testAllTableField(mir_acl_table, a_value_t, "Mir-Acl", "v6")

        finally:
            #  cleanup mirror sessions
            sai_thrift_remove_mirror_session(
                self.client,
                self.mirror_session)

            #  cleanup acl table
            sai_thrift_remove_acl_table(self.client, mir_acl_table)

    def ingressPcpPbrAclTableTest(self):
        '''
        Verify Vlan PCP field with port as in-port
        using switch b-point in IP Pbr ACL table
        '''
        print(" ingressPcpPbrAclTableTest ")

        self.rx_pbr_port = self.dev_port13

        try:
            action_type = [SAI_ACL_ACTION_TYPE_REDIRECT]
            action_type_list = sai_thrift_s32_list_t(
                count=len(action_type), int32list=action_type)

            pbr_acl_table = sai_thrift_create_acl_table(
                self.client,
                acl_stage=self.table_stage,
                acl_bind_point_type_list=self.bpoint_type_list,
                field_outer_vlan_pri=True,
                acl_action_type_list=action_type_list)
            self.assertNotEqual(pbr_acl_table, 0)

            pbr_nbr = sai_thrift_neighbor_entry_t(
                rif_id=self.port13_rif,
                ip_address=sai_ipaddress(self.dst_ip))
            sai_thrift_create_neighbor_entry(
                self.client,
                pbr_nbr,
                dst_mac_address=self.dst_mac,
                no_host_route=True)
            pbr_nhop = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_IP,
                router_interface_id=self.port13_rif,
                ip=sai_ipaddress(self.dst_ip))

            print("  Pbr Acl entry action forw to port 13 ")
            #  setup action to redirect
            action_re = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    s32=SAI_ACL_ENTRY_ATTR_ACTION_REDIRECT,
                    oid=pbr_nhop))
            a_type_t = "action_redirect"
            a_value_t = {a_type_t: action_re}

            self.testAllTableField(pbr_acl_table, a_value_t, "Pbr-Acl", "v4")
            self.testAllTableField(pbr_acl_table, a_value_t, "Pbr-Acl", "v6")

        finally:
            sai_thrift_remove_next_hop(self.client, pbr_nhop)
            sai_thrift_remove_neighbor_entry(self.client, pbr_nbr)

            #  cleanup acl table
            sai_thrift_remove_acl_table(self.client, pbr_acl_table)

    def TestDisableActionAllTable(self, table_type, pkt_test_type):
        print('''Test disable actions with %s Table with
                %s traffic''' % (table_type, pkt_test_type))
        if table_type == "Qos-Acl":
            print("Test to set tc value is zero ")
            # set tc to 0
            action_tc_set = sai_thrift_acl_action_data_t(
                    enable=True,
                    parameter=sai_thrift_acl_action_parameter_t(u8=0))
            sai_thrift_set_acl_entry_attribute(
                    self.client, self.acl_entry,
                    action_set_tc=action_tc_set)

            if pkt_test_type == "v4":
                print("Testing V4 traffic tos value  ")
                send_packet(self, self.dev_port11, self.pkt)
                verify_packet(self, self.e_pkt, self.dev_port10)
            elif pkt_test_type == "v6":
                print("Testing V6 traffic ")
                send_packet(self, self.dev_port11, self.pkt6)
                verify_packet(self, self.e_pkt6, self.dev_port10)
            packets = sai_thrift_get_acl_counter_attribute(
                    self.client, self.acl_counter, packets=True)
            self.assertEqual(packets['packets'], 1)
            print("pass packet w/ mapped dscp value 0 -> 14")
        elif table_type == "Mir-Acl":
            print("Test to mirror Acl disabled or not ")
            # passing invalid mirror session id to disable mirror session
            mirror_session_list = sai_thrift_object_list_t(
                count=1, idlist=[0])
            action_mirror = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    objlist=mirror_session_list))
            # modifying acl entry with invalid mirror session id
            status = sai_thrift_set_acl_entry_attribute(
                    self.client, self.acl_entry,
                    action_mirror_ingress=action_mirror)
            self.assertEqual(status, SAI_STATUS_SUCCESS,
                             "Failed to clear port ingress_mirror_session")

            send_packet(self, self.dev_port11, self.pkt)
            verify_no_packet(self, self.pkt, self.rx_mirror_port, timeout=5)
            verify_packets(self, self.e_pkt, ports=[self.dev_port10])
            verify_no_other_packets(self, timeout=5)
            packets = sai_thrift_get_acl_counter_attribute(
                    self.client, self.acl_counter, packets=True)
            self.assertEqual(packets['packets'], 1)
            print("Test completed successfully - packets not mirrored")
        elif table_type == "Pbr-Acl":
            print("Test to Pbr-Acl disabled or not ")
            # passing oid is 0 to disable redirect action
            action_re = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    s32=SAI_ACL_ENTRY_ATTR_ACTION_REDIRECT,
                    oid=0))
            status = sai_thrift_set_acl_entry_attribute(
                    self.client, self.acl_entry,
                    action_redirect=action_re)
            send_packet(self, self.dev_port11, self.pkt)
            verify_no_packet(self, self.e_pkt, self.rx_pbr_port, timeout=2)
            verify_packets(self, self.e_pkt, [self.dev_port10])
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, self.acl_counter, packets=True)
            self.assertEqual(packets['packets'], 1)
            print("Test completed successfully - packets not redirected ")

    def testAllTableField(self, acl_table, action_catch,
                          table_type, pkt_test_type):
        print("  Test Vlan PCP field in %s Table with %s traffic "
              % (table_type, pkt_test_type))

        #  install/verify traffic with catch-all rules first
        print("  Acl entry switch bindpoint ")
        vlan_pri = 3
        vlan_pri_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(u8=vlan_pri),
            mask=sai_thrift_acl_field_data_mask_t(u8=0x7))

        self.acl_entry = sai_thrift_create_acl_entry(
            self.client,
            table_id=acl_table,
            priority=self.lower_prio,
            field_outer_vlan_pri=vlan_pri_t,
            **action_catch)
        self.assertNotEqual(self.acl_entry, 0)

        #  ACL counter
        self.acl_counter = sai_thrift_create_acl_counter(
            self.client, table_id=acl_table)
        #  Attach acl counter
        action_counter_t = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=self.acl_counter),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, self.acl_entry,
            action_counter=action_counter_t)

        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.acl_counter, packets=True)
        self.assertEqual(packets['packets'], 0)
        self.acl_cnt = packets['packets']

        # Attach ACL in ingress direction
        sai_thrift_set_switch_attribute(
                self.client, ingress_acl=acl_table)

        self.AllTrafficTest(table_type, pkt_test_type)
        self.TestDisableActionAllTable(table_type, pkt_test_type)

        #  cleanup acl entry, counter
        sai_thrift_set_switch_attribute(self.client, ingress_acl=0)
        action_counter_t = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=0),
                enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, self.acl_entry,
            action_counter=action_counter_t)
        sai_thrift_set_acl_counter_attribute(
            self.client, self.acl_counter, packets=None)
        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.acl_counter, packets=True)
        self.assertEqual(packets['packets'], 0)

        sai_thrift_remove_acl_counter(self.client, self.acl_counter)
        sai_thrift_remove_acl_entry(self.client, self.acl_entry)

    def runTest(self):
        print(" IngressVlanPcpTest ")
        self.ingressPcpQosAclTableTest()
        print(" ")
        self.ingressPcpMirrorAclTableTest()
        print(" ")
        self.ingressPcpPbrAclTableTest()

    def tearDown(self):
        sai_thrift_remove_route_entry(self.client, self.v6_route_entry)
        sai_thrift_remove_next_hop(self.client, self.v6_nhop)
        sai_thrift_remove_neighbor_entry(self.client, self.v6_nbr_entry)
        sai_thrift_remove_route_entry(self.client, self.route_entry)
        sai_thrift_remove_next_hop(self.client, self.nhop)
        sai_thrift_remove_neighbor_entry(self.client, self.nbr_entry)
        super(IngressVlanPcpTest, self).tearDown()


@group('acl2')
class IngressVlanV4CfiTest(SaiHelper):
    """
    Verify matching on Vlan CFI for V4 traffic
    for Mirror, Qos and PBR Acl Tables
    """
    dst_ip_subnet = '100.55.155.0'
    dst_ip = '100.55.155.100'
    dst_mac = '00:11:22:33:44:55'
    port_smac = '00:22:22:22:22:22'
    port_src_ip = '55.55.55.100'
    tcp_dst_port = 5555
    tcp_src_port = 4444
    dscp_val = 14
    lower_prio = 5

    def setUp(self):
        super(IngressVlanV4CfiTest, self).setUp()

        egress_rif1 = self.port10_rif

        #  allocate v4 neighbor, nhop, route
        print("Allocate V4 neighbor with ip %s, router interface %x"
              " dst_mac %s " % (self.dst_ip, egress_rif1, self.dst_mac))
        self.nbr_entry = sai_thrift_neighbor_entry_t(
            rif_id=egress_rif1,
            ip_address=sai_ipaddress(self.dst_ip))
        sai_thrift_create_neighbor_entry(
            self.client,
            self.nbr_entry,
            dst_mac_address=self.dst_mac)

        print("Allocate nhop with ip %s, router interface %x"
              % (self.dst_ip, egress_rif1))
        self.nhop = sai_thrift_create_next_hop(
            self.client,
            ip=sai_ipaddress(self.dst_ip),
            router_interface_id=egress_rif1,
            type=SAI_NEXT_HOP_TYPE_IP)

        print("Allocate route with ip subnet %s --> router interface %x"
              % (self.dst_ip_subnet, egress_rif1))
        self.route_entry = sai_thrift_route_entry_t(
            vr_id=self.default_vrf,
            destination=sai_ipprefix(self.dst_ip_subnet))
        sai_thrift_create_route_entry(
            self.client,
            self.route_entry,
            next_hop_id=egress_rif1)

        #  ACL table
        self.table_stage = SAI_ACL_STAGE_INGRESS

        bpoints = [SAI_ACL_BIND_POINT_TYPE_SWITCH]
        self.bpoint_type_list = sai_thrift_s32_list_t(
            count=len(bpoints), int32list=bpoints)

        #  v4 pkt for in-port 11
        self.pkt = simple_tcp_packet(
            eth_dst=ROUTER_MAC,
            eth_src=self.port_smac,
            ip_dst=self.dst_ip,
            ip_src=self.port_src_ip,
            ip_id=105,
            tcp_sport=self.tcp_src_port,
            tcp_dport=self.tcp_dst_port,
            tcp_flags=41,
            pktlen=104,
            ip_ttl=64,
            ip_dscp=self.dscp_val,
            dl_vlan_enable=True,
            dl_vlan_cfi=0)
        self.e_pkt = simple_tcp_packet(
            eth_dst=self.dst_mac,
            eth_src=ROUTER_MAC,
            ip_dst=self.dst_ip,
            ip_src=self.port_src_ip,
            ip_id=105,
            tcp_sport=self.tcp_src_port,
            tcp_dport=self.tcp_dst_port,
            tcp_flags=41,
            pktlen=100,
            ip_ttl=63,
            ip_dscp=self.dscp_val)
        self.tpkt = simple_tcp_packet(
            eth_dst=ROUTER_MAC,
            eth_src=self.port_smac,
            ip_dst=self.dst_ip,
            ip_src=self.port_src_ip,
            ip_id=105,
            tcp_sport=self.tcp_src_port,
            tcp_dport=self.tcp_dst_port,
            tcp_flags=41,
            pktlen=104,
            ip_ttl=64,
            ip_dscp=self.dscp_val,
            dl_vlan_enable=True,
            dl_vlan_cfi=0)
        self.te_pkt = simple_tcp_packet(
            eth_dst=self.dst_mac,
            eth_src=ROUTER_MAC,
            ip_dst=self.dst_ip,
            ip_src=self.port_src_ip,
            ip_id=105,
            tcp_sport=self.tcp_src_port,
            tcp_dport=self.tcp_dst_port,
            tcp_flags=41,
            pktlen=100,
            ip_ttl=63,
            ip_dscp=self.dscp_val)

    def AllTrafficTest(self,
                       table_type,
                       pkt_test_type="v4"):
        '''
        Verify Vlan CFI for V4 tcp pkts for ingress ACl tables/entries
        '''
        print("    Test with %s traffic on port " % (pkt_test_type))

        if pkt_test_type != "v4" and pkt_test_type != "v6":
            print("    Incorrect traffic pkt type, must be v4 or v6 ")
            return

        print('   -----------------------------------------------------------')
        port_pkt = self.pkt
        port_e_pkt = self.e_pkt
        print("    Tx below V4 tcp packet from port 11 ")
        print("     [%s to %s] " % (self.port_src_ip, self.dst_ip))
        print("     L4 port src [%d] dst [%d], flags 41, ip dscp 14"
              % (self.tcp_src_port, self.tcp_dst_port))

        #  Qos Acl set-tc action --> verify tc-dscp map
        #  To verify, change Rx pkt to have new tos value
        #  For acl entry action tc 10 --> 40 dscp
        if table_type == "Qos-Acl":
            temp_e_pkt = port_e_pkt.copy()
            temp_e_pkt[IP].tos = 40 << 2
            port_e_pkt = temp_e_pkt

        #  verify traffic
        send_packet(self, self.dev_port11, port_pkt)
        #  verify acl entry action/stats
        if table_type == "Mir-Acl":
            print("      ----> route to port 10 ")
            print("      ----> mirror in-pkt to port 8 ")
            verify_each_packet_on_each_port(
                self,
                [port_e_pkt, port_pkt],
                [self.dev_port10, self.rx_mirror_port])
            #  verify non-matching pkt todo
            #  print("      ----> Non-Matching packet route to port 10 ")
            #  send_packet(self, self.dev_port11, self.tpkt)
            #  verify_packets(self, self.te_pkt, [self.dev_port10])
        elif table_type == "Pbr-Acl":
            print("      ----> pbr to nhop[port 13] ")
            verify_packets(self, port_e_pkt, [self.rx_pbr_port])
            #  verify non-matching pkt todo
            #  print("      ----> Non-Matching packet route to port 10 ")
            #  send_packet(self, self.dev_port11, self.tpkt)
            #  verify_packets(self, self.te_pkt, [self.dev_port10])
        else:
            print("      ----> route to port 10 ")
            verify_packets(self, port_e_pkt, [self.dev_port10])
            #  verify non-matching pkt todo
            #  print("      ----> Non-Matching packet route to port 10 ")
            #  print("      ----> with out setting tc ")
            #  send_packet(self, self.dev_port11, self.tpkt)
            #  verify_packets(self, self.te_pkt, [self.dev_port10])
        self.acl_cnt += 1
        time.sleep(1)
        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.acl_counter, packets=True)
        self.assertEqual(packets['packets'], self.acl_cnt)
        print('   -----------------------------------------------------------')

    def ingressCfiQosAclTableTest(self):
        '''
        Verify Vlan CFI field with port as in-port
        using switch b-point in QoS ACL table
        '''
        print(" ingressCfiQosAclTableTest ")

        try:
            action_type = [SAI_ACL_ACTION_TYPE_SET_TC]
            qos_action_type_list = sai_thrift_s32_list_t(
                count=len(action_type), int32list=action_type)

            qos_acl_table = sai_thrift_create_acl_table(
                self.client,
                acl_stage=self.table_stage,
                acl_bind_point_type_list=self.bpoint_type_list,
                field_outer_vlan_cfi=True,
                acl_action_type_list=qos_action_type_list)
            self.assertNotEqual(qos_acl_table, 0)

            #  map all tc values with color green to dscp
            #  This will change the dscp value on egress
            #  based of tc value set by qos Acl entry
            egress_tc_color_list = [
                [10, 0],
                [7, 0],
                [8, 0],
                [5, 0],  # green
            ]
            egress_dscp_list = [
                40, 25, 18, 55,  # mapping green
            ]
            qos_tc_color_to_dscp_map = create_and_verify_qos_map(
                self.client,
                SAI_QOS_MAP_TYPE_TC_AND_COLOR_TO_DSCP,
                egress_tc_color_list,
                egress_dscp_list)
            self.assertTrue(qos_tc_color_to_dscp_map != 0,
                            "  Fail to alloc tc_color_to_dscp map  ")

            #  map above qos map to egress port
            status = sai_thrift_set_port_attribute(
                self.client,
                self.port10,
                qos_tc_and_color_to_dscp_map=qos_tc_color_to_dscp_map)
            self.assertEqual(status, SAI_STATUS_SUCCESS,
                             "  Fail to set tc_color_to_dscp map to port 10  ")
            attr = sai_thrift_get_port_attribute(
                self.client, self.port10,
                qos_tc_and_color_to_dscp_map=True)
            self.assertEqual(attr['qos_tc_and_color_to_dscp_map'],
                             qos_tc_color_to_dscp_map)

            print("  Qos Acl entry action set-tc to 10-->40 dscp  ")
            #  setup action to set tc
            action_tc_set = sai_thrift_acl_action_data_t(
                enable=True,
                parameter=sai_thrift_acl_action_parameter_t(u8=10))
            a_type_t = "action_set_tc"
            a_value_t = {a_type_t: action_tc_set}

            self.testAllTableField(qos_acl_table, a_value_t, "Qos-Acl", "v4")

        finally:
            #  cleanup egress qos map
            status = sai_thrift_set_port_attribute(
                self.client, self.port10,
                qos_tc_and_color_to_dscp_map=0)
            self.assertEqual(status, SAI_STATUS_SUCCESS,
                             "  Fail to reset tc_color_to_dscp for port 10  ")
            sai_thrift_remove_qos_map(self.client, qos_tc_color_to_dscp_map)

            #  cleanup acl table
            sai_thrift_remove_acl_table(self.client, qos_acl_table)

    def ingressCfiMirrorAclTableTest(self):
        '''
        Verify Vlan CFI field with port as in-port
        using switch b-point in IP Mirror ACL table
        '''
        print(" ingressCfiMirrorAclTableTest ")

        self.rx_mirror_port = self.dev_port8
        self.mirror_port = self.port8

        try:
            action_type = [SAI_ACL_ACTION_TYPE_MIRROR_INGRESS]
            action_type_list = sai_thrift_s32_list_t(
                count=len(action_type), int32list=action_type)

            mir_acl_table = sai_thrift_create_acl_table(
                self.client,
                acl_stage=self.table_stage,
                acl_bind_point_type_list=self.bpoint_type_list,
                field_outer_vlan_cfi=True,
                acl_action_type_list=action_type_list)
            self.assertNotEqual(mir_acl_table, 0)

            #  alloc mirror port 8 for mirror session
            self.mirror_session = sai_thrift_create_mirror_session(
                self.client,
                monitor_port=self.mirror_port,
                type=SAI_MIRROR_SESSION_TYPE_LOCAL)

            print("  IP Mirror Acl entry action in-mirror port 8 ")
            #  setup action to mirror
            mirror_session_list = sai_thrift_object_list_t(
                count=1, idlist=[self.mirror_session])
            action_mirror = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    objlist=mirror_session_list))
            a_type_t = "action_mirror_ingress"
            a_value_t = {a_type_t: action_mirror}

            self.testAllTableField(mir_acl_table, a_value_t, "Mir-Acl", "v4")

        finally:
            #  cleanup mirror sessions
            sai_thrift_remove_mirror_session(
                self.client,
                self.mirror_session)

            #  cleanup acl table
            sai_thrift_remove_acl_table(self.client, mir_acl_table)

    def ingressCfiPbrAclTableTest(self):
        '''
        Verify Vlan CFI field with port as in-port
        using switch b-point in IP Pbr ACL table
        '''
        print(" ingressCfiPbrAclTableTest ")

        self.rx_pbr_port = self.dev_port13

        try:
            action_type = [SAI_ACL_ACTION_TYPE_REDIRECT]
            action_type_list = sai_thrift_s32_list_t(
                count=len(action_type), int32list=action_type)

            pbr_acl_table = sai_thrift_create_acl_table(
                self.client,
                acl_stage=self.table_stage,
                acl_bind_point_type_list=self.bpoint_type_list,
                field_outer_vlan_cfi=True,
                acl_action_type_list=action_type_list)
            self.assertNotEqual(pbr_acl_table, 0)

            pbr_nbr = sai_thrift_neighbor_entry_t(
                rif_id=self.port13_rif,
                ip_address=sai_ipaddress(self.dst_ip))
            sai_thrift_create_neighbor_entry(
                self.client,
                pbr_nbr,
                dst_mac_address=self.dst_mac,
                no_host_route=True)
            pbr_nhop = sai_thrift_create_next_hop(
                self.client,
                type=SAI_NEXT_HOP_TYPE_IP,
                router_interface_id=self.port13_rif,
                ip=sai_ipaddress(self.dst_ip))

            print("  Pbr Acl action forw to port 13 ")
            #  setup action to redirect
            action_re = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    s32=SAI_ACL_ENTRY_ATTR_ACTION_REDIRECT,
                    oid=pbr_nhop))
            a_type_t = "action_redirect"
            a_value_t = {a_type_t: action_re}

            self.testAllTableField(pbr_acl_table, a_value_t, "Pbr-Acl", "v4")

        finally:
            sai_thrift_remove_next_hop(self.client, pbr_nhop)
            sai_thrift_remove_neighbor_entry(self.client, pbr_nbr)

            #  cleanup acl group member, table
            sai_thrift_remove_acl_table(self.client, pbr_acl_table)

    def testAllTableField(self, acl_table, action_catch,
                          table_type, pkt_test_type):
        print("  Test cfi match field in %s Table with %s traffic "
              % (table_type, pkt_test_type))

        #  install/verify traffic
        print("  Acl entry switch bindpoint ")
        vlan_dei = 0
        vlan_dei_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(u8=vlan_dei),
            mask=sai_thrift_acl_field_data_mask_t(u8=0x1))

        acl_entry = sai_thrift_create_acl_entry(
            self.client,
            table_id=acl_table,
            priority=self.lower_prio,
            field_outer_vlan_cfi=vlan_dei_t,
            **action_catch)
        self.assertNotEqual(acl_entry, 0)

        #  ACL counter
        self.acl_counter = sai_thrift_create_acl_counter(
            self.client, table_id=acl_table)
        #  Attach counter to ACL Entry
        action_counter_t = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=self.acl_counter),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, acl_entry,
            action_counter=action_counter_t)

        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.acl_counter, packets=True)
        self.assertEqual(packets['packets'], 0)
        self.acl_cnt = packets['packets']

        # Attach ACL in ingress direction
        sai_thrift_set_switch_attribute(
                self.client, ingress_acl=acl_table)

        self.AllTrafficTest(table_type, pkt_test_type)

        #  cleanup acl entry, counter
        sai_thrift_set_switch_attribute(self.client, ingress_acl=0)
        action_counter_t = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=0),
                enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, acl_entry,
            action_counter=action_counter_t)
        sai_thrift_set_acl_counter_attribute(
            self.client, self.acl_counter, packets=None)
        packets = sai_thrift_get_acl_counter_attribute(
            self.client, self.acl_counter, packets=True)
        self.assertEqual(packets['packets'], 0)

        #  cleanup acl entry, counter
        sai_thrift_remove_acl_counter(self.client, self.acl_counter)
        sai_thrift_remove_acl_entry(self.client, acl_entry)

    def runTest(self):
        print(" IngressVlanCfiTest ")
        self.ingressCfiQosAclTableTest()
        print(" ")
        self.ingressCfiMirrorAclTableTest()
        print(" ")
        self.ingressCfiPbrAclTableTest()

    def tearDown(self):
        sai_thrift_remove_route_entry(self.client, self.route_entry)
        sai_thrift_remove_next_hop(self.client, self.nhop)
        sai_thrift_remove_neighbor_entry(self.client, self.nbr_entry)
        super(IngressVlanV4CfiTest, self).tearDown()


@group('acl2')
class UserDefinedTrapMACAclTest(SaiHelper):
    """
    Verify User Defined Trap for MAC Table
    """

    def setUp(self):
        super(UserDefinedTrapMACAclTest, self).setUp()

        rif_id1 = self.port10_rif
        self.rif_id2 = self.port11_rif

        ip_addr_subnet = '172.16.10.0'
        ip_addr = '172.16.10.1'
        dmac = '00:11:22:33:44:55'
        self.mac_src = '00:22:22:22:22:22'
        ip_addr_src = '192.168.0.1'

        print("Alloc neighbor with %s ip address, %d router interface"
              " id and %s destination mac" % (
                  ip_addr, rif_id1, dmac))
        self.nbr_entry = sai_thrift_neighbor_entry_t(
            rif_id=rif_id1,
            ip_address=sai_ipaddress(ip_addr))
        sai_thrift_create_neighbor_entry(
            self.client, self.nbr_entry, dst_mac_address=dmac)

        print("Alloc nhop with %s ip address and %d router"
              " interface id" % (ip_addr, rif_id1))
        self.nhop = sai_thrift_create_next_hop(
            self.client,
            ip=sai_ipaddress(ip_addr),
            router_interface_id=rif_id1,
            type=SAI_NEXT_HOP_TYPE_IP)

        self.pkt = simple_tcp_packet(eth_dst=ROUTER_MAC,
                                     eth_src=self.mac_src,
                                     ip_dst=ip_addr,
                                     ip_src=ip_addr_src,
                                     ip_id=105,
                                     pktlen=100,
                                     ip_ttl=64)
        self.exp_pkt = simple_tcp_packet(eth_dst=dmac,
                                         eth_src=ROUTER_MAC,
                                         ip_dst=ip_addr,
                                         ip_src=ip_addr_src,
                                         ip_id=105,
                                         ip_ttl=63)

    def basicMacTrafficTest(self):
        '''
        Verify mac traffic test before
        applying ingress mac ACl table entry.
        '''
        print("basicMacTrafficTest")

        print('--------------------------------------------------------------')
        print("Sending packet port 11 -> port 10 (192.168.0.1 --->"
              " 172.16.10.1 [id = 105])")

        try:
            print('#### NO ACL Applied ####')
            print('#### Sending  ', ROUTER_MAC, '| 00:22:22:22:22:22 | '
                  '172.16.10.1 | 192.168.100.1 | @ port 11 ')
            send_packet(self, self.dev_port11, self.pkt)
            print('#### Expecting 00:11:22:33:44:55 |', ROUTER_MAC, '| '
                  '172.16.10.1 | 192.168.100.1 | @ port 10 ')
            verify_packets(self, self.exp_pkt, [self.dev_port10])
        finally:
            print('----------------------------------------------------------')

    def ingressUDTAcltest(self):
        '''
        Verify user defined trap with switch b-point to
        ingress MAC ACL table entry with Src Mac match
        '''
        print("ingressUDTAcltest")

        table_stage_ingress = SAI_ACL_STAGE_INGRESS
        entry_priority = 1
        mac_src = ROUTER_MAC
        mac_src_mask = 'ff:ff:ff:ff:ff:ff'
        out_port_id = self.port10

        table_bind_points = [SAI_ACL_BIND_POINT_TYPE_SWITCH]
        table_bind_point_type_list = sai_thrift_s32_list_t(
            count=len(table_bind_points), int32list=table_bind_points)

        print("Create Policer ID")
        sai_policer_id = sai_thrift_create_policer(
                self.client,
                meter_type=SAI_METER_TYPE_PACKETS,
                mode=SAI_POLICER_MODE_SR_TCM,
                cir=5,
                cbs=10,
                pir=10,
                pbs=10,
                red_packet_action=SAI_PACKET_ACTION_DROP)

        print("Create Trap Group")
        trap_group = sai_thrift_create_hostif_trap_group(
                self.client, queue=2, policer=sai_policer_id)

        print("Create User Defined Trap")
        udt1 = sai_thrift_create_hostif_user_defined_trap(
            self.client,
            trap_group=trap_group,
            type=SAI_HOSTIF_USER_DEFINED_TRAP_TYPE_ACL)
        self.assertTrue(udt1 != 0)

        print("Create host interface")
        hostif1_name = "hostif1"
        hostif1 = sai_thrift_create_hostif(self.client,
                                           name=hostif1_name,
                                           obj_id=self.port11,
                                           type=SAI_HOSTIF_TYPE_NETDEV)
        self.assertTrue(hostif1 != 0)
        time.sleep(6)
        hostif1_socket = open_packet_socket(hostif1_name)

        # associate user defined trap 1 with hostif 1
        channel = SAI_HOSTIF_TABLE_ENTRY_CHANNEL_TYPE_NETDEV_PHYSICAL_PORT
        hostif_table_entry_udt1_hif1 = \
            sai_thrift_create_hostif_table_entry(
                self.client,
                channel_type=channel,
                host_if=hostif1,
                trap_id=udt1,
                type=SAI_HOSTIF_TABLE_ENTRY_TYPE_TRAP_ID)
        self.assertTrue(hostif_table_entry_udt1_hif1 != 0)

        print("Alloc ACL Table")
        acl_ingress_table_id = sai_thrift_create_acl_table(
            self.client,
            acl_stage=table_stage_ingress,
            acl_bind_point_type_list=table_bind_point_type_list,
            field_src_mac=True)
        self.assertNotEqual(acl_ingress_table_id, 0)

        print("Alloc ACL Field Data")
        src_mac_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(mac=self.mac_src),
            mask=sai_thrift_acl_field_data_mask_t(mac=mac_src_mask))

        set_user_trap_id = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(oid=udt1))

        print("Alloc Packet Action")
        packet_action = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                s32=SAI_PACKET_ACTION_TRAP))

        print("Alloc ACL Entry")
        acl_ingress_entry_id = sai_thrift_create_acl_entry(
            self.client,
            table_id=acl_ingress_table_id,
            priority=entry_priority,
            field_src_mac=src_mac_t,
            action_set_user_trap_id=set_user_trap_id,
            action_packet_action=packet_action)
        self.assertNotEqual(acl_ingress_entry_id, 0)

        #  ACL counter
        acl_counter_ingress = sai_thrift_create_acl_counter(
            self.client, table_id=acl_ingress_table_id)
        # attach ACL counter to ACL entry
        action_counter_ingress = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=acl_counter_ingress),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, acl_ingress_entry_id,
            action_counter=action_counter_ingress)

        # attach acl in ingress
        sai_thrift_set_switch_attribute(
            self.client, ingress_acl=acl_ingress_table_id)

        try:
            print('#### ACL \'Trap, src mac 00:22:22:22:22:22 '
                  '\' Applied ####')
            print('#### Sending      ', ROUTER_MAC, '| 00:22:22:22:22:22 | '
                  '172.16.10.1 | 192.168.0.1 | @ Port 11')
            cpu_queue_pkt_count = 0
            pre_stats = sai_thrift_get_queue_stats(
                self.client, self.cpu_queue2)
            # send packets
            for i in range(0, 15):
                print('Sending packet', i)
                send_packet(self, self.dev_port11, self.pkt)
                time.sleep(0.1)
            # sleep for sometime
            print('\nSleep for 4s to allow buckets to fully refill\n')
            time.sleep(4)
            print('Getting CPU stats')
            post_stats = sai_thrift_get_queue_stats(
                self.client, self.cpu_queue2)
            print('Getting policer stats')
            stats = sai_thrift_get_policer_stats(self.client, sai_policer_id)
            # remove entry which is not a statistic
            del stats['SAI_POLICER_STAT_CUSTOM_RANGE_BASE']

            for stat, value in stats.items():
                print(stat, value)

            print("Verifying CPU port queue stats")
            queue2_count = post_stats["SAI_QUEUE_STAT_PACKETS"] \
                - pre_stats["SAI_QUEUE_STAT_PACKETS"]
            self.assertEqual(
                queue2_count, (stats['SAI_POLICER_STAT_GREEN_PACKETS'] +
                               stats['SAI_POLICER_STAT_YELLOW_PACKETS']))

            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter_ingress, packets=True)
            self.assertEqual(packets['packets'], 15)
        finally:
            # cleanup Policer
            sai_thrift_clear_policer_stats(self.client, sai_policer_id)
            stats = sai_thrift_get_policer_stats(self.client, sai_policer_id)
            print("Policer statistics after clear")
            print('SAI_POLICER_STAT_PACKETS:',
                  stats['SAI_POLICER_STAT_PACKETS'])
            print('SAI_POLICER_STAT_YELLOW_PACKETS:',
                  stats['SAI_POLICER_STAT_YELLOW_PACKETS'])
            print('SAI_POLICER_STAT_GREEN_PACKETS:',
                  stats['SAI_POLICER_STAT_GREEN_PACKETS'])
            print('SAI_POLICER_STAT_RED_PACKETS:',
                  stats['SAI_POLICER_STAT_RED_PACKETS'])

            self.assertEqual(stats['SAI_POLICER_STAT_PACKETS'], 0)
            self.assertEqual(stats['SAI_POLICER_STAT_YELLOW_PACKETS'], 0)
            self.assertEqual(stats['SAI_POLICER_STAT_GREEN_PACKETS'], 0)
            self.assertEqual(stats['SAI_POLICER_STAT_RED_PACKETS'], 0)

            # cleanup ACL
            sai_thrift_set_switch_attribute(self.client, ingress_acl=0)
            action_counter_ingress = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=0),
                enable=True)
            sai_thrift_set_acl_entry_attribute(
                self.client, acl_ingress_entry_id,
                action_counter=action_counter_ingress)
            sai_thrift_set_acl_counter_attribute(
                self.client, acl_counter_ingress, packets=None)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter_ingress, packets=True)
            self.assertEqual(packets['packets'], 0)
            sai_thrift_remove_acl_counter(self.client, acl_counter_ingress)

            # cleanup ACL
            sai_thrift_remove_acl_entry(self.client, acl_ingress_entry_id)
            sai_thrift_remove_acl_table(self.client, acl_ingress_table_id)
            sai_thrift_remove_hostif_table_entry(
                self.client, hostif_table_entry_udt1_hif1)
            sai_thrift_remove_hostif_user_defined_trap(
                self.client, udt1)
            sai_thrift_remove_hostif_trap_group(
                self.client, trap_group)
            sai_thrift_remove_policer(self.client, sai_policer_id)
            hostif1_socket.close()
            sai_thrift_remove_hostif(self.client, hostif1)

    def runTest(self):
        print("Testing UserDefinedTrapMACAclTest")
        self.basicMacTrafficTest()
        self.ingressUDTAcltest()

    def tearDown(self):
        sai_thrift_remove_next_hop(self.client, self.nhop)
        sai_thrift_remove_neighbor_entry(self.client, self.nbr_entry)
        super(UserDefinedTrapMACAclTest, self).tearDown()


@group('acl2')
class UserDefinedTrapV4AclTest(SaiHelper):
    """
    Verify User Defined Traps for ipv4
    """

    def setUp(self):
        super(UserDefinedTrapV4AclTest, self).setUp()

        l4_src_port = 1000

        rif_id1 = self.port10_rif
        self.rif_id2 = self.port11_rif
        self.rif_id3 = self.port12_rif

        ip_addr_subnet = '172.16.10.0'
        ip_addr = '172.16.10.1'
        dmac = '00:11:22:33:44:55'
        mac_src = '00:22:22:22:22:22'
        ip_addr_src = '192.168.100.100'

        print("Alloc neighbor with %s ip address, %d router interface"
              " id and %s destination mac" % (
                  ip_addr, rif_id1, dmac))
        self.nbr_entry = sai_thrift_neighbor_entry_t(
            rif_id=rif_id1,
            ip_address=sai_ipaddress(ip_addr))
        sai_thrift_create_neighbor_entry(
            self.client, self.nbr_entry, dst_mac_address=dmac)

        print("Alloc nhop with %s ip address and %d router"
              " interface id" % (ip_addr, rif_id1))
        self.nhop = sai_thrift_create_next_hop(
            self.client,
            ip=sai_ipaddress(ip_addr),
            router_interface_id=rif_id1,
            type=SAI_NEXT_HOP_TYPE_IP)

        self.pkt = simple_tcp_packet(eth_dst=ROUTER_MAC,
                                     eth_src=mac_src,
                                     ip_dst=ip_addr,
                                     ip_src=ip_addr_src,
                                     tcp_sport=l4_src_port,
                                     ip_id=105,
                                     ip_ttl=64)
        self.exp_pkt = simple_tcp_packet(eth_dst=dmac,
                                         eth_src=ROUTER_MAC,
                                         ip_dst=ip_addr,
                                         ip_src=ip_addr_src,
                                         tcp_sport=l4_src_port,
                                         ip_id=105,
                                         ip_ttl=63)

    def basicV4TrafficTest(self):
        '''
        Verify v4 traffic test before
        applying ingress ipv4 ACl table entry.
        '''
        print("basicV4TrafficTest")

        print('--------------------------------------------------------------')
        print("Sending packet port 11 -> port 10 (192.168.100.100 "
              "--->172.16.10.1 [id = 105])")

        try:
            print('#### NO ACL Applied ####')
            print('#### Sending  ', ROUTER_MAC, '| 00:22:22:22:22:22 | '
                  '172.16.10.1 | 192.168.100.100 | @ port 11')
            send_packet(self, self.dev_port11, self.pkt)
            print('#### Expecting 00:11:22:33:44:55 |', ROUTER_MAC, '| '
                  '172.16.10.1 | 192.168.100.100 | @ port 10')
            verify_packets(self, self.exp_pkt, [self.dev_port10])
        finally:
            print('----------------------------------------------------------'
                  '------------------------------------')

    def ingressV4UDTAcltest(self):
        '''
        Verify User Defined Trap with switch b-point to
        ingress ipv4 ACL table entry with src-ip match
        '''
        print("ingressV4UDTAcltest")

        table_stage_ingress = SAI_ACL_STAGE_INGRESS
        entry_priority = 1
        ip_src = "192.168.100.1"
        ip_src_mask = "255.255.255.0"
        out_port_id = self.port10

        table_bind_points = [SAI_ACL_BIND_POINT_TYPE_SWITCH]
        table_bind_point_type_list = sai_thrift_s32_list_t(
            count=len(table_bind_points), int32list=table_bind_points)

        print("Create Policer ID")
        sai_policer_id = sai_thrift_create_policer(
                self.client,
                meter_type=SAI_METER_TYPE_PACKETS,
                mode=SAI_POLICER_MODE_SR_TCM,
                cir=5,
                cbs=10,
                pir=10,
                pbs=10,
                red_packet_action=SAI_PACKET_ACTION_DROP)

        print("Create Trap Group")
        trap_group = sai_thrift_create_hostif_trap_group(
                self.client, queue=2, policer=sai_policer_id)

        print("Create User Defined Trap")
        udt1 = sai_thrift_create_hostif_user_defined_trap(
            self.client,
            trap_group=trap_group,
            type=SAI_HOSTIF_USER_DEFINED_TRAP_TYPE_ACL)
        self.assertTrue(udt1 != 0)

        print("Create host interface")
        hostif1_name = "hostif1"
        hostif1 = sai_thrift_create_hostif(self.client,
                                           name=hostif1_name,
                                           obj_id=self.port11,
                                           type=SAI_HOSTIF_TYPE_NETDEV)
        self.assertTrue(hostif1 != 0)
        time.sleep(6)
        hostif1_socket = open_packet_socket(hostif1_name)

        # associate user defined trap 1 with hostif 1
        channel = SAI_HOSTIF_TABLE_ENTRY_CHANNEL_TYPE_NETDEV_PHYSICAL_PORT
        hostif_table_entry_udt1_hif1 = \
            sai_thrift_create_hostif_table_entry(
                self.client,
                channel_type=channel,
                host_if=hostif1,
                trap_id=udt1,
                type=SAI_HOSTIF_TABLE_ENTRY_TYPE_TRAP_ID)
        self.assertTrue(hostif_table_entry_udt1_hif1 != 0)

        print("Alloc ACL Table")
        acl_ingress_table_id = sai_thrift_create_acl_table(
            self.client,
            acl_stage=table_stage_ingress,
            acl_bind_point_type_list=table_bind_point_type_list,
            field_src_ip=True)
        self.assertNotEqual(acl_ingress_table_id, 0)

        print("Alloc ACL Field Data")
        src_ip_t = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(ip4=ip_src),
            mask=sai_thrift_acl_field_data_mask_t(ip4=ip_src_mask))

        set_user_trap_id = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(oid=udt1))

        print("Alloc ACL Action")
        packet_action = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                s32=SAI_PACKET_ACTION_TRAP))

        print("Alloc ACL Entry")
        acl_ingress_entry_id = sai_thrift_create_acl_entry(
            self.client,
            table_id=acl_ingress_table_id,
            priority=entry_priority,
            field_src_ip=src_ip_t,
            action_set_user_trap_id=set_user_trap_id,
            action_packet_action=packet_action)
        self.assertNotEqual(acl_ingress_entry_id, 0)

        # ACL counter
        acl_counter_ingress = sai_thrift_create_acl_counter(
            self.client, table_id=acl_ingress_table_id)
        # attach ACL counter to ACL entry
        action_counter_ingress = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=acl_counter_ingress),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, acl_ingress_entry_id,
            action_counter=action_counter_ingress)

        # Attach ACL in ingress direction
        sai_thrift_set_switch_attribute(
            self.client, ingress_acl=acl_ingress_table_id)

        try:
            print("Sending packet port 11 -[ACL]-> port 10 (192.168.0.1"
                  "-[ACL]-> 172.16.10.1 [id = 105])")
            print('#### ACL \'TRAP, src ip 192.168.100.1/255.255.255.0, '
                  ' \' Applied ####')
            cpu_queue_pkt_count = 0
            pre_stats = sai_thrift_get_queue_stats(
                self.client, self.cpu_queue2)
            # send packets
            for i in range(0, 15):
                print('Sending packet', i)
                send_packet(self, self.dev_port11, self.pkt)
                time.sleep(0.1)
            # sleep for sometime
            print('\nSleep for 4s to allow buckets to fully refill\n')
            time.sleep(4)
            print('Getting CPU stats')
            post_stats = sai_thrift_get_queue_stats(
                self.client, self.cpu_queue2)
            print('Getting policer stats')
            stats = sai_thrift_get_policer_stats(self.client, sai_policer_id)
            # remove entry which is not a statistic
            del stats['SAI_POLICER_STAT_CUSTOM_RANGE_BASE']

            for stat, value in stats.items():
                print(stat, value)

            print("Verifying CPU port queue stats")
            queue2_count = post_stats["SAI_QUEUE_STAT_PACKETS"] \
                - pre_stats["SAI_QUEUE_STAT_PACKETS"]
            self.assertEqual(
                queue2_count, (stats['SAI_POLICER_STAT_GREEN_PACKETS'] +
                               stats['SAI_POLICER_STAT_YELLOW_PACKETS']))

            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter_ingress, packets=True)
            self.assertEqual(packets['packets'], 15)
        finally:
            # cleanup Policer
            sai_thrift_clear_policer_stats(self.client, sai_policer_id)
            stats = sai_thrift_get_policer_stats(self.client, sai_policer_id)
            print("Policer statistics after clear")
            print('SAI_POLICER_STAT_PACKETS:',
                  stats['SAI_POLICER_STAT_PACKETS'])
            print('SAI_POLICER_STAT_YELLOW_PACKETS:',
                  stats['SAI_POLICER_STAT_YELLOW_PACKETS'])
            print('SAI_POLICER_STAT_GREEN_PACKETS:',
                  stats['SAI_POLICER_STAT_GREEN_PACKETS'])
            print('SAI_POLICER_STAT_RED_PACKETS:',
                  stats['SAI_POLICER_STAT_RED_PACKETS'])

            self.assertEqual(stats['SAI_POLICER_STAT_PACKETS'], 0)
            self.assertEqual(stats['SAI_POLICER_STAT_YELLOW_PACKETS'], 0)
            self.assertEqual(stats['SAI_POLICER_STAT_GREEN_PACKETS'], 0)
            self.assertEqual(stats['SAI_POLICER_STAT_RED_PACKETS'], 0)

            # cleanup ACL
            sai_thrift_set_switch_attribute(self.client, ingress_acl=0)
            action_counter_ingress = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=0),
                enable=True)
            sai_thrift_set_acl_entry_attribute(
                self.client, acl_ingress_entry_id,
                action_counter=action_counter_ingress)
            sai_thrift_set_acl_counter_attribute(
                self.client, acl_counter_ingress, packets=None)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter_ingress, packets=True)
            self.assertEqual(packets['packets'], 0)
            sai_thrift_remove_acl_counter(self.client, acl_counter_ingress)

            sai_thrift_remove_acl_entry(self.client, acl_ingress_entry_id)
            sai_thrift_remove_acl_table(self.client, acl_ingress_table_id)
            sai_thrift_remove_hostif_table_entry(
                self.client, hostif_table_entry_udt1_hif1)
            sai_thrift_remove_hostif_user_defined_trap(
                self.client, udt1)
            sai_thrift_remove_hostif_trap_group(
                self.client, trap_group)
            sai_thrift_remove_policer(self.client, sai_policer_id)
            hostif1_socket.close()
            sai_thrift_remove_hostif(self.client, hostif1)

    def runTest(self):
        print("Testing UserDefinedTrapV4AclTest")
        self.basicV4TrafficTest()
        self.ingressV4UDTAcltest()

    def tearDown(self):
        sai_thrift_remove_next_hop(self.client, self.nhop)
        sai_thrift_remove_neighbor_entry(self.client, self.nbr_entry)
        super(UserDefinedTrapV4AclTest, self).tearDown()


@group('acl2')
class UserDefinedTrapV6AclTest(SaiHelper):
    """
    Verify User Defined Trap for ipv6
    """
    def setUp(self):
        super(UserDefinedTrapV6AclTest, self).setUp()

        rif_id1 = self.port10_rif

        self.ipv6_addr = '4000::1'
        self.dmac = '00:22:22:22:22:22'
        ipv6_mask = "ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff"
        self.ipv6_addr_src = '2000::1'
        self.POLICER_CIR = 32000
        self.POLICER_PIR = 32000

        print("Alloc neighbor with %s ip address, %d router interface"
              " id and %s destination mac" % (
                  self.ipv6_addr, rif_id1, self.dmac))
        self.nbr_entry = sai_thrift_neighbor_entry_t(
            rif_id=rif_id1,
            ip_address=sai_ipaddress(self.ipv6_addr))
        sai_thrift_create_neighbor_entry(
            self.client, self.nbr_entry, dst_mac_address=self.dmac)

        print("Alloc nhop with %s ip address and %d router"
              " interface id" % (self.ipv6_addr, rif_id1))
        self.nhop = sai_thrift_create_next_hop(
            self.client,
            ip=sai_ipaddress(self.ipv6_addr),
            router_interface_id=rif_id1,
            type=SAI_NEXT_HOP_TYPE_IP)

        self.pktv6 = simple_tcpv6_packet(eth_dst=ROUTER_MAC,
                                         eth_src=self.dmac,
                                         ipv6_dst=self.ipv6_addr,
                                         ipv6_src=self.ipv6_addr_src,
                                         ipv6_hlim=64)
        self.exp_pktv6 = simple_tcpv6_packet(eth_dst=self.dmac,
                                             eth_src=ROUTER_MAC,
                                             ipv6_dst=self.ipv6_addr,
                                             ipv6_src=self.ipv6_addr_src,
                                             ipv6_hlim=63)

    def basicV6TrafficTest(self):
        '''
        Verify v6 traffic test before
        applying ingress ipv6 ACl table entry.
        '''
        print("basicV6TrafficTest")

        print('--------------------------------------------------------------')
        print("Sending packet port 11 -> port 10 (2000::1 ---> 4000::1)")

        try:
            print('#### NO ACL APPLIED ####')
            print('#### Sending  ', ROUTER_MAC, '| 00:22:22:22:22:22 | 4000::1'
                  ' | 2000::1 | @ port 11')
            send_packet(self, self.dev_port11, self.pktv6)
            print('#### Expecting ', self.dmac, ' | ', ROUTER_MAC, '| 4000::1'
                  ' | 2000::1 | @ port 10')
            verify_packets(self, self.exp_pktv6, [self.dev_port10])

        finally:
            print('----------------------------------------------------------'
                  '------------------------------------')

    def ingressV6UDTAcltest(self):
        '''
        Verify User Defined Trap with switch b-point to
        ingress ipv6 ACL table entry with src-ip match
        '''
        print("ingressV6UDTAcltest")

        table_stage_ingress = SAI_ACL_STAGE_INGRESS
        ipv6_mask = "ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff"
        out_port_id = self.port10

        table_bind_points = [SAI_ACL_BIND_POINT_TYPE_SWITCH]
        table_bind_point_type_list = sai_thrift_s32_list_t(
            count=len(table_bind_points), int32list=table_bind_points)

        print("Create Policer ID")
        sai_policer_id = sai_thrift_create_policer(
                self.client,
                meter_type=SAI_METER_TYPE_PACKETS,
                mode=SAI_POLICER_MODE_SR_TCM,
                cir=5,
                cbs=10,
                pir=10,
                pbs=10,
                red_packet_action=SAI_PACKET_ACTION_DROP)

        print("Create Trap Group")
        trap_group = sai_thrift_create_hostif_trap_group(
                self.client, queue=2, policer=sai_policer_id)

        print("Create User Defined Trap")
        udt1 = sai_thrift_create_hostif_user_defined_trap(
            self.client,
            trap_group=trap_group,
            type=SAI_HOSTIF_USER_DEFINED_TRAP_TYPE_ACL)
        self.assertTrue(udt1 != 0)

        print("Create host interface")
        hostif1_name = "hostif1"
        hostif1 = sai_thrift_create_hostif(self.client,
                                           name=hostif1_name,
                                           obj_id=self.port11,
                                           type=SAI_HOSTIF_TYPE_NETDEV)
        self.assertTrue(hostif1 != 0)
        time.sleep(6)
        hostif1_socket = open_packet_socket(hostif1_name)

        # associate user defined trap 1 with hostif 1
        channel = SAI_HOSTIF_TABLE_ENTRY_CHANNEL_TYPE_NETDEV_PHYSICAL_PORT
        hostif_table_entry_udt1_hif1 = \
            sai_thrift_create_hostif_table_entry(
                self.client,
                channel_type=channel,
                host_if=hostif1,
                trap_id=udt1,
                type=SAI_HOSTIF_TABLE_ENTRY_TYPE_TRAP_ID)
        self.assertTrue(hostif_table_entry_udt1_hif1 != 0)

        print("Alloc ACL Table")
        acl_ingress_table_id = sai_thrift_create_acl_table(
            self.client,
            acl_stage=table_stage_ingress,
            acl_bind_point_type_list=table_bind_point_type_list,
            field_src_ipv6=True)
        self.assertNotEqual(acl_ingress_table_id, 0)

        print("Alloc ACL field data")
        src_ip_t_ipv6 = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(ip6=self.ipv6_addr_src),
            mask=sai_thrift_acl_field_data_mask_t(
                ip6=ipv6_mask))

        set_user_trap_id = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(oid=udt1))

        print("Alloc ACL Action")
        packet_action = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                s32=SAI_PACKET_ACTION_TRAP))

        #  ACL entries
        print("Alloc ACL entries")

        ipv6_acl_ingress_entry_id = sai_thrift_create_acl_entry(
            self.client,
            table_id=acl_ingress_table_id,
            priority=9998,
            field_src_ipv6=src_ip_t_ipv6,
            action_set_user_trap_id=set_user_trap_id,
            action_packet_action=packet_action)
        self.assertNotEqual(ipv6_acl_ingress_entry_id, 0)

        #  ACL counter
        acl_counter_ingress_ipv6 = sai_thrift_create_acl_counter(
            self.client, table_id=acl_ingress_table_id)

        # attach ACL counter to ACL entry
        action_counter_ingress_ipv6 = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                oid=acl_counter_ingress_ipv6),
            enable=True)
        sai_thrift_set_acl_entry_attribute(
            self.client, ipv6_acl_ingress_entry_id,
            action_counter=action_counter_ingress_ipv6)

        # attach ACL in ingress direction
        sai_thrift_set_switch_attribute(
            self.client, ingress_acl=acl_ingress_table_id)

        try:
            print('#### ACL \'TRAP, src ip 2000::1, Applied ####')
            print('#### Sending  ', ROUTER_MAC, '| 00:22:22:22:22:22 | 4000::1'
                  ' | 2000::1 | @ Port 11')
            cpu_queue_pkt_count = 0
            pre_stats = sai_thrift_get_queue_stats(
                self.client, self.cpu_queue2)
            # send packets
            for i in range(0, 15):
                print('Sending packet', i)
                send_packet(self, self.dev_port11, self.pktv6)
                time.sleep(0.1)
            # sleep for sometime
            print('\nSleep for 4s to allow buckets to fully refill\n')
            time.sleep(4)
            print('Getting CPU stats')
            post_stats = sai_thrift_get_queue_stats(
                self.client, self.cpu_queue2)
            print('Getting policer stats')
            stats = sai_thrift_get_policer_stats(self.client, sai_policer_id)
            # remove entry which is not a statistic
            del stats['SAI_POLICER_STAT_CUSTOM_RANGE_BASE']

            for stat, value in stats.items():
                print(stat, value)

            print("Verifying CPU port queue stats")
            queue2_count = post_stats["SAI_QUEUE_STAT_PACKETS"] \
                - pre_stats["SAI_QUEUE_STAT_PACKETS"]
            self.assertEqual(
                queue2_count, (stats['SAI_POLICER_STAT_GREEN_PACKETS'] +
                               stats['SAI_POLICER_STAT_YELLOW_PACKETS']))

            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter_ingress_ipv6, packets=True)
            self.assertEqual(packets['packets'], 15)
        finally:
            # cleanup Policer
            sai_thrift_clear_policer_stats(self.client, sai_policer_id)
            stats = sai_thrift_get_policer_stats(self.client, sai_policer_id)
            print("Policer statistics after clear")
            print('SAI_POLICER_STAT_PACKETS:',
                  stats['SAI_POLICER_STAT_PACKETS'])
            print('SAI_POLICER_STAT_YELLOW_PACKETS:',
                  stats['SAI_POLICER_STAT_YELLOW_PACKETS'])
            print('SAI_POLICER_STAT_GREEN_PACKETS:',
                  stats['SAI_POLICER_STAT_GREEN_PACKETS'])
            print('SAI_POLICER_STAT_RED_PACKETS:',
                  stats['SAI_POLICER_STAT_RED_PACKETS'])

            self.assertEqual(stats['SAI_POLICER_STAT_PACKETS'], 0)
            self.assertEqual(stats['SAI_POLICER_STAT_YELLOW_PACKETS'], 0)
            self.assertEqual(stats['SAI_POLICER_STAT_GREEN_PACKETS'], 0)
            self.assertEqual(stats['SAI_POLICER_STAT_RED_PACKETS'], 0)

            # cleanup ACL
            sai_thrift_set_switch_attribute(self.client, ingress_acl=0)
            action_counter_ingress_ipv6 = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(
                    oid=0),
                enable=True)
            sai_thrift_set_acl_entry_attribute(
                self.client, ipv6_acl_ingress_entry_id,
                action_counter=action_counter_ingress_ipv6)
            sai_thrift_set_acl_counter_attribute(
                self.client, acl_counter_ingress_ipv6, packets=None)
            packets = sai_thrift_get_acl_counter_attribute(
                self.client, acl_counter_ingress_ipv6, packets=True)
            self.assertEqual(packets['packets'], 0)
            sai_thrift_remove_acl_counter(self.client,
                                          acl_counter_ingress_ipv6)

            sai_thrift_remove_acl_entry(self.client, ipv6_acl_ingress_entry_id)
            sai_thrift_remove_acl_table(self.client, acl_ingress_table_id)
            sai_thrift_remove_hostif_table_entry(
                self.client, hostif_table_entry_udt1_hif1)
            sai_thrift_remove_hostif_user_defined_trap(
                self.client, udt1)
            sai_thrift_remove_hostif_trap_group(
                self.client, trap_group)
            sai_thrift_remove_policer(self.client, sai_policer_id)
            hostif1_socket.close()
            sai_thrift_remove_hostif(self.client, hostif1)

    def runTest(self):
        print("Testing UserDefinedTrapV6AclTest")
        self.basicV6TrafficTest()
        self.ingressV6UDTAcltest()

    def tearDown(self):
        sai_thrift_remove_next_hop(self.client, self.nhop)
        sai_thrift_remove_neighbor_entry(self.client, self.nbr_entry)
        super(UserDefinedTrapV6AclTest, self).tearDown()


@group('acl2-qos-meters')
class IngressIpQosAclPermitMeterTest(MinimalPortVlanConfig):
    '''
    Verify policer binds to ACL entry by sending traffic which should be
    colored red and dropped. Verify if traffic was dropped and policer
    statistics.
    Ingress ACL meters need to be enabled.
    '''

    def __init__(self):
        super(IngressIpQosAclPermitMeterTest, self).__init__(port_num=3)

    def setUp(self):
        super(IngressIpQosAclPermitMeterTest, self).setUp()

        self.pol_id = sai_thrift_create_policer(
            self.client, mode=SAI_POLICER_MODE_TR_TCM,
            meter_type=SAI_METER_TYPE_BYTES, cbs=125, pbs=125,
            cir=1000, pir=1000,
            red_packet_action=SAI_PACKET_ACTION_DROP)

        self.acl_table_id = None
        self.acl_entry_id = None

    def runTest(self):
        print("IngressIpQosAclPermitMeterTest")

        print('Create ACL table')
        action_type = [SAI_ACL_ACTION_TYPE_SET_POLICER]
        action = sai_thrift_s32_list_t(
            count=len(action_type), int32list=action_type)

        bind_point = [SAI_ACL_BIND_POINT_TYPE_SWITCH]
        acl_bpt_list = sai_thrift_s32_list_t(count=len(bind_point),
                                             int32list=bind_point)

        self.acl_table_id = sai_thrift_create_acl_table(
            self.client, acl_stage=SAI_ACL_STAGE_INGRESS, field_dst_ip=True,
            acl_action_type_list=action, acl_bind_point_type_list=acl_bpt_list)

        print('Bind ACL table to switch')
        status = sai_thrift_set_switch_attribute(
            self.client, ingress_acl=self.acl_table_id)
        self.assertEqual(status, SAI_STATUS_SUCCESS)

        print('Create ACL entry with action_set_policer')
        dst_ip = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(ip4='192.168.0.0'),
            mask=sai_thrift_acl_field_data_mask_t(ip4='255.255.255.0'))

        param = sai_thrift_acl_action_parameter_t(oid=self.pol_id)
        obj_acl_action_data = sai_thrift_acl_action_data_t(parameter=param)

        self.acl_entry_id = sai_thrift_create_acl_entry(
            self.client, table_id=self.acl_table_id, field_dst_ip=dst_ip,
            action_set_policer=obj_acl_action_data, admin_state=True)
        self.assertGreater(self.acl_entry_id, 0)

        print('Send traffic')
        pkt = simple_udp_packet(ip_dst='192.168.0.2')
        tx_cnt = 10
        total_bytes = 1040
        for i in range(tx_cnt):
            print('Sending UDP packet', i)
            send_packet(self, self.dev_port0, pkt)
            time.sleep(0.1)

        print('Verify traffic')
        rx_cnt = count_matched_packets_all_ports(
            self, pkt, [self.dev_port1, self.dev_port2])
        print('Flooded packets:', rx_cnt)
        self.assertLessEqual(rx_cnt, tx_cnt * 2)
        verify_no_other_packets(self)

        stats = sai_thrift_get_policer_stats(self.client, self.pol_id)
        # remove entry which is not a statistic
        del stats['SAI_POLICER_STAT_CUSTOM_RANGE_BASE']
        for stat, value in stats.items():
            print(stat, value)

        metered_bytes = stats['SAI_POLICER_STAT_ATTR_BYTES']
        self.assertEqual(total_bytes, metered_bytes)

        sai_thrift_remove_acl_entry(self.client, self.acl_entry_id)
        sai_thrift_clear_policer_stats(self.client, self.pol_id)

        # verify set_qos_params actions by setting tc, color and meter_index
        color = SAI_PACKET_COLOR_YELLOW
        action_set_color = sai_thrift_acl_action_data_t(
                parameter=sai_thrift_acl_action_parameter_t(s32=color))
        action_tc_set = sai_thrift_acl_action_data_t(
                enable=True,
                parameter=sai_thrift_acl_action_parameter_t(u8=20))
        self.acl_entry_id = sai_thrift_create_acl_entry(
            self.client, table_id=self.acl_table_id, field_dst_ip=dst_ip,
            action_set_policer=obj_acl_action_data,
            action_set_packet_color=action_set_color,
            action_set_tc=action_tc_set, admin_state=True)
        self.assertGreater(self.acl_entry_id, 0)

        print('Send traffic')
        pkt = simple_udp_packet(ip_dst='192.168.0.2')
        tx_cnt = 10
        total_bytes = 1040
        for i in range(tx_cnt):
            print('Sending UDP packet', i)
            send_packet(self, self.dev_port0, pkt)
            time.sleep(0.1)
        print('Verify traffic')
        rx_cnt = count_matched_packets_all_ports(
            self, pkt, [self.dev_port1, self.dev_port2])
        print('Flooded packets:', rx_cnt)
        self.assertLessEqual(rx_cnt, tx_cnt * 2)
        verify_no_other_packets(self)

        stats = sai_thrift_get_policer_stats(self.client, self.pol_id)
        # remove entry which is not a statistic
        del stats['SAI_POLICER_STAT_CUSTOM_RANGE_BASE']
        for stat, value in stats.items():
            print(stat, value)

        metered_bytes = stats['SAI_POLICER_STAT_ATTR_BYTES']
        self.assertEqual(total_bytes, metered_bytes)

    def tearDown(self):
        sai_thrift_clear_policer_stats(self.client, self.pol_id)
        stats = sai_thrift_get_policer_stats(self.client, self.pol_id)
        print("Policer statistics after clear")
        print('SAI_POLICER_STAT_PACKETS:',
              stats['SAI_POLICER_STAT_PACKETS'])
        print('SAI_POLICER_STAT_YELLOW_PACKETS:',
              stats['SAI_POLICER_STAT_YELLOW_PACKETS'])
        print('SAI_POLICER_STAT_GREEN_PACKETS:',
              stats['SAI_POLICER_STAT_GREEN_PACKETS'])
        print('SAI_POLICER_STAT_RED_PACKETS:',
              stats['SAI_POLICER_STAT_RED_PACKETS'])

        self.assertEqual(stats['SAI_POLICER_STAT_PACKETS'], 0)
        self.assertEqual(stats['SAI_POLICER_STAT_YELLOW_PACKETS'], 0)
        self.assertEqual(stats['SAI_POLICER_STAT_GREEN_PACKETS'], 0)
        self.assertEqual(stats['SAI_POLICER_STAT_RED_PACKETS'], 0)

        sai_thrift_remove_acl_entry(self.client, self.acl_entry_id)
        sai_thrift_set_switch_attribute(self.client, ingress_acl=0)
        sai_thrift_remove_acl_table(self.client, self.acl_table_id)
        sai_thrift_remove_policer(self.client, self.pol_id)

        super(IngressIpQosAclPermitMeterTest, self).tearDown()


@group('acl2-qos-meters')
class EgressIpQosAclPermitMeterTest(MinimalPortVlanConfig):
    '''
    Verify policer binds to ACL entry by sending traffic which should be
    colored red and dropped. Verify if traffic was dropped and policer
    statistics.
    Egress ACL meters need to be enabled.
    '''

    def __init__(self):
        super(EgressIpQosAclPermitMeterTest, self).__init__(port_num=3)

    def setUp(self):
        super(EgressIpQosAclPermitMeterTest, self).setUp()

        self.pol_id = sai_thrift_create_policer(
            self.client, mode=SAI_POLICER_MODE_TR_TCM,
            meter_type=SAI_METER_TYPE_BYTES, cbs=125, pbs=125,
            cir=1000, pir=1000,
            red_packet_action=SAI_PACKET_ACTION_DROP)

        self.acl_table_id = None
        self.acl_entry_id = None

    def runTest(self):
        print("EgressIpQosAclPermitMeterTest")

        print('Create ACL table')
        action_type = [SAI_ACL_ACTION_TYPE_SET_POLICER]
        action = sai_thrift_s32_list_t(
            count=len(action_type), int32list=action_type)

        bind_point = [SAI_ACL_BIND_POINT_TYPE_SWITCH]
        acl_bpt_list = sai_thrift_s32_list_t(count=len(bind_point),
                                             int32list=bind_point)

        self.acl_table_id = sai_thrift_create_acl_table(
            self.client, acl_stage=SAI_ACL_STAGE_EGRESS, field_dst_ip=True,
            acl_action_type_list=action, acl_bind_point_type_list=acl_bpt_list)

        print('Bind ACL table to switch')
        status = sai_thrift_set_switch_attribute(
            self.client, egress_acl=self.acl_table_id)
        self.assertEqual(status, SAI_STATUS_SUCCESS)

        print('Create ACL entry with action_set_policer')
        dst_ip = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(ip4='192.168.0.0'),
            mask=sai_thrift_acl_field_data_mask_t(ip4='255.255.255.0'))

        param = sai_thrift_acl_action_parameter_t(oid=self.pol_id)
        obj_acl_action_data = sai_thrift_acl_action_data_t(parameter=param)

        self.acl_entry_id = sai_thrift_create_acl_entry(
            self.client, table_id=self.acl_table_id, field_dst_ip=dst_ip,
            action_set_policer=obj_acl_action_data, admin_state=True)
        self.assertGreater(self.acl_entry_id, 0)

        print('Send traffic')
        pkt = simple_udp_packet(ip_dst='192.168.0.2')
        tx_cnt = 10
        total_bytes = 2600
        for i in range(tx_cnt):
            print('Sending UDP packet', i)
            send_packet(self, self.dev_port0, pkt)
            time.sleep(0.1)

        print('Verify traffic')
        rx_cnt = count_matched_packets_all_ports(
            self, pkt, [self.dev_port1, self.dev_port2])
        print('Flooded packets:', rx_cnt)
        self.assertLessEqual(rx_cnt, tx_cnt * 2)
        verify_no_other_packets(self)

        stats = sai_thrift_get_policer_stats(self.client, self.pol_id)
        # remove entry which is not a statistic
        del stats['SAI_POLICER_STAT_CUSTOM_RANGE_BASE']
        for stat, value in stats.items():
            print(stat, value)

        metered_bytes = stats['SAI_POLICER_STAT_ATTR_BYTES']
        self.assertEqual(total_bytes, metered_bytes)

    def tearDown(self):
        sai_thrift_clear_policer_stats(self.client, self.pol_id)
        stats = sai_thrift_get_policer_stats(self.client, self.pol_id)
        print("Policer statistics after clear")
        print('SAI_POLICER_STAT_PACKETS:',
              stats['SAI_POLICER_STAT_PACKETS'])
        print('SAI_POLICER_STAT_YELLOW_PACKETS:',
              stats['SAI_POLICER_STAT_YELLOW_PACKETS'])
        print('SAI_POLICER_STAT_GREEN_PACKETS:',
              stats['SAI_POLICER_STAT_GREEN_PACKETS'])
        print('SAI_POLICER_STAT_RED_PACKETS:',
              stats['SAI_POLICER_STAT_RED_PACKETS'])

        self.assertEqual(stats['SAI_POLICER_STAT_PACKETS'], 0)
        self.assertEqual(stats['SAI_POLICER_STAT_YELLOW_PACKETS'], 0)
        self.assertEqual(stats['SAI_POLICER_STAT_GREEN_PACKETS'], 0)
        self.assertEqual(stats['SAI_POLICER_STAT_RED_PACKETS'], 0)

        sai_thrift_remove_acl_entry(self.client, self.acl_entry_id)
        sai_thrift_set_switch_attribute(self.client, egress_acl=0)
        sai_thrift_remove_acl_table(self.client, self.acl_table_id)
        sai_thrift_remove_policer(self.client, self.pol_id)

        super(EgressIpQosAclPermitMeterTest, self).tearDown()


@group('acl2-mirror-meters')
class IngressIpMirrorAclPermitMeterTest(MinimalPortVlanConfig):
    '''
    Verify policer binds to ACL entry by sending traffic which should be
    colored red and dropped. Verify if traffic was dropped and policer
    statistics.
    Ingress ACL meters need to be enabled.
    '''

    def __init__(self):
        super(IngressIpMirrorAclPermitMeterTest, self).__init__(port_num=3)

    def setUp(self):
        super(IngressIpMirrorAclPermitMeterTest, self).setUp()

        self.pol_id = sai_thrift_create_policer(
            self.client, mode=SAI_POLICER_MODE_TR_TCM,
            meter_type=SAI_METER_TYPE_BYTES, cbs=125, pbs=125,
            cir=1000, pir=1000,
            red_packet_action=SAI_PACKET_ACTION_DROP)

        self.acl_table_id = None
        self.acl_entry_id = None

    def runTest(self):
        print("IngressIpMirrorAclPermitMeterTest")

        print('Create ACL table')
        action_type = [SAI_ACL_ACTION_TYPE_MIRROR_INGRESS]
        action = sai_thrift_s32_list_t(
            count=len(action_type), int32list=action_type)

        bind_point = [SAI_ACL_BIND_POINT_TYPE_SWITCH]
        acl_bpt_list = sai_thrift_s32_list_t(count=len(bind_point),
                                             int32list=bind_point)

        self.acl_table_id = sai_thrift_create_acl_table(
            self.client, acl_stage=SAI_ACL_STAGE_INGRESS, field_dst_ip=True,
            acl_action_type_list=action, acl_bind_point_type_list=acl_bpt_list)

        print('Bind ACL table to switch')
        status = sai_thrift_set_switch_attribute(
            self.client, ingress_acl=self.acl_table_id)
        self.assertEqual(status, SAI_STATUS_SUCCESS)

        print('Create ACL entry with action_set_policer')
        dst_ip = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(ip4='192.168.0.0'),
            mask=sai_thrift_acl_field_data_mask_t(ip4='255.255.255.0'))

        param = sai_thrift_acl_action_parameter_t(oid=self.pol_id)
        obj_acl_action_data = sai_thrift_acl_action_data_t(parameter=param)

        self.mirror_session = sai_thrift_create_mirror_session(
            self.client,
            monitor_port=self.port2,
            type=SAI_MIRROR_SESSION_TYPE_LOCAL,
            policer=self.pol_id)

        mirror_session_list = sai_thrift_object_list_t(
            count=1, idlist=[self.mirror_session])
        mirror_action = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                objlist=mirror_session_list))
        self.acl_entry_id = sai_thrift_create_acl_entry(
            self.client, table_id=self.acl_table_id, field_dst_ip=dst_ip,
            action_mirror_ingress=mirror_action,
            action_set_policer=obj_acl_action_data, admin_state=True)
        self.assertGreater(self.acl_entry_id, 0)

        print('Send traffic')
        pkt = simple_udp_packet(ip_dst='192.168.0.2')
        tx_cnt = 10
        total_bytes = 1210
        for i in range(tx_cnt):
            print('Sending UDP packet', i)
            send_packet(self, self.dev_port0, pkt)
            time.sleep(0.1)

        print('Verify traffic')
        rx_cnt = count_matched_packets_all_ports(
            self, pkt, [self.dev_port2])
        print('Flooded packets:', rx_cnt)

        self.assertLessEqual(rx_cnt, tx_cnt * 2)
        verify_no_other_packets(self)

        stats = sai_thrift_get_policer_stats(self.client, self.pol_id)
        # remove entry which is not a statistic
        del stats['SAI_POLICER_STAT_CUSTOM_RANGE_BASE']
        for stat, value in stats.items():
            print(stat, value)

        metered_bytes = stats['SAI_POLICER_STAT_ATTR_BYTES']
        self.assertEqual(total_bytes, metered_bytes)

    def tearDown(self):
        sai_thrift_clear_policer_stats(self.client, self.pol_id)
        stats = sai_thrift_get_policer_stats(self.client, self.pol_id)
        print("Policer statistics after clear")
        print('SAI_POLICER_STAT_PACKETS:',
              stats['SAI_POLICER_STAT_PACKETS'])
        print('SAI_POLICER_STAT_YELLOW_PACKETS:',
              stats['SAI_POLICER_STAT_YELLOW_PACKETS'])
        print('SAI_POLICER_STAT_GREEN_PACKETS:',
              stats['SAI_POLICER_STAT_GREEN_PACKETS'])
        print('SAI_POLICER_STAT_RED_PACKETS:',
              stats['SAI_POLICER_STAT_RED_PACKETS'])

        self.assertEqual(stats['SAI_POLICER_STAT_PACKETS'], 0)
        self.assertEqual(stats['SAI_POLICER_STAT_YELLOW_PACKETS'], 0)
        self.assertEqual(stats['SAI_POLICER_STAT_GREEN_PACKETS'], 0)
        self.assertEqual(stats['SAI_POLICER_STAT_RED_PACKETS'], 0)

        sai_thrift_remove_acl_entry(self.client, self.acl_entry_id)
        sai_thrift_set_switch_attribute(self.client, ingress_acl=0)
        sai_thrift_remove_acl_table(self.client, self.acl_table_id)
        sai_thrift_remove_mirror_session(self.client, self.mirror_session)
        sai_thrift_remove_policer(self.client, self.pol_id)

        super(IngressIpMirrorAclPermitMeterTest, self).tearDown()


@group('acl2-mirror-meters')
class EgressIpMirrorAclPermitMeterTest(MinimalPortVlanConfig):
    '''
    Verify policer binds to ACL entry by sending traffic which should be
    colored red and dropped. Verify if traffic was dropped and policer
    statistics.
    Egress ACL meters need to be enabled.
    '''

    def __init__(self):
        super(EgressIpMirrorAclPermitMeterTest, self).__init__(port_num=3)

    def setUp(self):
        super(EgressIpMirrorAclPermitMeterTest, self).setUp()

        self.pol_id = sai_thrift_create_policer(
            self.client, mode=SAI_POLICER_MODE_TR_TCM,
            meter_type=SAI_METER_TYPE_BYTES, cbs=125, pbs=125,
            cir=1000, pir=1000,
            red_packet_action=SAI_PACKET_ACTION_DROP)

        self.acl_table_id = None
        self.acl_entry_id = None

    def runTest(self):
        print("EgressIpMirrorAclPermitMeterTest")

        print('Create ACL table')
        action_type = [SAI_ACL_ACTION_TYPE_MIRROR_EGRESS]
        action = sai_thrift_s32_list_t(
            count=len(action_type), int32list=action_type)

        bind_point = [SAI_ACL_BIND_POINT_TYPE_SWITCH]
        acl_bpt_list = sai_thrift_s32_list_t(count=len(bind_point),
                                             int32list=bind_point)

        self.acl_table_id = sai_thrift_create_acl_table(
            self.client, acl_stage=SAI_ACL_STAGE_EGRESS, field_dst_ip=True,
            acl_action_type_list=action, acl_bind_point_type_list=acl_bpt_list)

        print('Bind ACL table to switch')
        status = sai_thrift_set_switch_attribute(
            self.client, egress_acl=self.acl_table_id)
        self.assertEqual(status, SAI_STATUS_SUCCESS)

        print('Create ACL entry with action_set_policer')
        dst_ip = sai_thrift_acl_field_data_t(
            data=sai_thrift_acl_field_data_data_t(ip4='192.168.0.0'),
            mask=sai_thrift_acl_field_data_mask_t(ip4='255.255.255.0'))

        param = sai_thrift_acl_action_parameter_t(oid=self.pol_id)
        obj_acl_action_data = sai_thrift_acl_action_data_t(parameter=param)

        self.mirror_session = sai_thrift_create_mirror_session(
            self.client,
            monitor_port=self.port2,
            type=SAI_MIRROR_SESSION_TYPE_LOCAL,
            policer=self.pol_id)

        mirror_session_list = sai_thrift_object_list_t(
            count=1, idlist=[self.mirror_session])
        mirror_action = sai_thrift_acl_action_data_t(
            parameter=sai_thrift_acl_action_parameter_t(
                objlist=mirror_session_list))
        self.acl_entry_id = sai_thrift_create_acl_entry(
            self.client, table_id=self.acl_table_id, field_dst_ip=dst_ip,
            action_mirror_egress=mirror_action,
            action_set_policer=obj_acl_action_data, admin_state=True)
        self.assertGreater(self.acl_entry_id, 0)

        print('Send traffic')
        pkt = simple_udp_packet(ip_dst='192.168.0.2')
        tx_cnt = 10
        total_bytes = 2600
        for i in range(tx_cnt):
            print('Sending UDP packet', i)
            send_packet(self, self.dev_port0, pkt)
            time.sleep(0.1)

        print('Verify traffic')
        rx_cnt = count_matched_packets_all_ports(
            self, pkt, [self.dev_port1, self.dev_port2])
        print('Flooded packets:', rx_cnt)
        self.assertLessEqual(rx_cnt, tx_cnt * 2)
        verify_no_other_packets(self)

        stats = sai_thrift_get_policer_stats(self.client, self.pol_id)
        # remove entry which is not a statistic
        del stats['SAI_POLICER_STAT_CUSTOM_RANGE_BASE']
        for stat, value in stats.items():
            print(stat, value)

        metered_bytes = stats['SAI_POLICER_STAT_ATTR_BYTES']
        self.assertEqual(total_bytes, metered_bytes)

    def tearDown(self):
        sai_thrift_clear_policer_stats(self.client, self.pol_id)
        stats = sai_thrift_get_policer_stats(self.client, self.pol_id)
        print("Policer statistics after clear")
        print('SAI_POLICER_STAT_PACKETS:',
              stats['SAI_POLICER_STAT_PACKETS'])
        print('SAI_POLICER_STAT_YELLOW_PACKETS:',
              stats['SAI_POLICER_STAT_YELLOW_PACKETS'])
        print('SAI_POLICER_STAT_GREEN_PACKETS:',
              stats['SAI_POLICER_STAT_GREEN_PACKETS'])
        print('SAI_POLICER_STAT_RED_PACKETS:',
              stats['SAI_POLICER_STAT_RED_PACKETS'])

        self.assertEqual(stats['SAI_POLICER_STAT_PACKETS'], 0)
        self.assertEqual(stats['SAI_POLICER_STAT_YELLOW_PACKETS'], 0)
        self.assertEqual(stats['SAI_POLICER_STAT_GREEN_PACKETS'], 0)
        self.assertEqual(stats['SAI_POLICER_STAT_RED_PACKETS'], 0)

        sai_thrift_remove_acl_entry(self.client, self.acl_entry_id)
        sai_thrift_set_switch_attribute(self.client, egress_acl=0)
        sai_thrift_remove_acl_table(self.client, self.acl_table_id)
        sai_thrift_remove_mirror_session(self.client, self.mirror_session)
        sai_thrift_remove_policer(self.client, self.pol_id)

        super(EgressIpMirrorAclPermitMeterTest, self).tearDown()
